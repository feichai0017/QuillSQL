<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>QuillSQL Internals</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">QuillSQL Internals</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div align="center">
  <img src="assets/rust-db.png" alt="QuillSQL Logo" width="500"/>
</div>
<h1 id="quillsql-internals"><a class="header" href="#quillsql-internals">QuillSQL Internals</a></h1>
<p>Welcome to the technical documentation for QuillSQL.</p>
<p>This book provides a deep dive into the internal architecture and implementation details of the database. It is intended for developers, contributors, and anyone interested in understanding how a relational database is built from the ground up, referencing concepts from classic database courses like CMU 15-445.</p>
<hr />
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li>
<p><a href="./architecture.html"><strong>Overall Architecture</strong></a>: A high-level overview of the entire system.</p>
</li>
<li>
<p><strong>Core Modules</strong></p>
<ul>
<li><a href="./modules/buffer.html"><strong>Buffer Manager</strong></a>: The in-memory page cache.
<ul>
<li><a href="./buffer/page.html">Page &amp; Page Guards</a></li>
<li><a href="./buffer/buffer_pool.html">The Buffer Pool</a></li>
</ul>
</li>
<li><a href="./modules/storage.html"><strong>Storage Engine</strong></a>: How data is physically stored.
<ul>
<li><a href="./storage/disk_io.html">Disk I/O</a></li>
<li><a href="./storage/page_layouts.html">Page &amp; Tuple Layout</a></li>
<li><a href="./storage/table_heap.html">Table Heap &amp; MVCC</a></li>
</ul>
</li>
<li><a href="./modules/index.html"><strong>Indexes</strong></a>: The B+Tree implementation.
<ul>
<li><a href="./index/btree_index.html">B+Tree Details</a></li>
</ul>
</li>
<li><a href="./modules/recovery.html"><strong>Recovery Manager (WAL)</strong></a>: Crash recovery and the ARIES protocol.</li>
<li><a href="./modules/transaction.html"><strong>Transaction Manager</strong></a>: Concurrency control with MVCC and 2PL.</li>
<li><a href="./modules/plan.html"><strong>Query Plan</strong></a>: The journey from SQL to an executable plan.</li>
<li><a href="./modules/optimizer.html"><strong>Query Optimizer</strong></a>: Rule-based plan transformations.</li>
<li><a href="./modules/execution.html"><strong>Execution Engine</strong></a>: The Volcano (iterator) execution model.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quillsql-architecture"><a class="header" href="#quillsql-architecture">QuillSQL Architecture</a></h1>
<p>This document explains how a SQL request flows through QuillSQL, how transactional MVCC and background services plug in, and how the main modules collaborate. All diagrams use Mermaid so you can paste them into any compatible renderer for a richer view.</p>
<hr />
<h2 id="1-end-to-end-request-pipeline"><a class="header" href="#1-end-to-end-request-pipeline">1. End-to-End Request Pipeline</a></h2>
<pre class="mermaid">flowchart TD
    Client[&quot;CLI / HTTP client&quot;] --&gt; API[&quot;bin/client / bin/server&quot;]
    API --&gt; Parser[&quot;sql::parser&quot;]
    Parser --&gt; LPlanner[&quot;plan::LogicalPlanner&quot;]
    LPlanner --&gt; Optimizer[&quot;optimizer::LogicalOptimizer&quot;]
    Optimizer --&gt; PhysPlanner[&quot;plan::PhysicalPlanner&quot;]
    PhysPlanner --&gt; Exec[&quot;execution::ExecutionEngine (Volcano)&quot;]

    subgraph Txn[&quot;Transaction Layer&quot;]
        Session[&quot;session::SessionContext&quot;]
        TM[&quot;transaction::TransactionManager&quot;]
        LM[&quot;transaction::LockManager&quot;]
        Session --&gt; TM --&gt; LM
    end

    Exec --&gt;|Tuple meta &amp; locks| Txn
    Exec --&gt; Storage

    subgraph Storage[&quot;Storage &amp; I/O&quot;]
        TableHeap[&quot;storage::table_heap::TableHeap&quot;]
        Index[&quot;storage::index::B+Tree&quot;]
        Buffer[&quot;buffer::BufferManager&quot;]
        Scheduler[&quot;storage::disk_scheduler (io_uring)&quot;]
        WAL[&quot;recovery::WalManager&quot;]
        TableHeap &lt;--&gt; Buffer
        Index &lt;--&gt; Buffer
        Buffer &lt;--&gt; Scheduler
        WAL --&gt; Scheduler
    end

    Txn --&gt;|WAL payloads| WAL

    Background[&quot;background::workers\n(checkpoint, bg writer, MVCC vacuum)&quot;] --&gt; Buffer
    Background --&gt; WAL
    Background --&gt; TM
</pre>
<p><strong>High-level flow</strong></p>
<ol>
<li>SQL text is parsed into an AST, planned into a <code>LogicalPlan</code>, optimized by a handful of safe rewrite rules, then lowered into a physical operator tree.</li>
<li><code>SessionContext</code> either reuses or creates a transaction and injects isolation/access modes.</li>
<li>Each physical operator is driven by the Volcano pull model (<code>init</code>/<code>next</code>). On entry it obtains a <code>TxnRuntime</code> which supplies a command id plus an MVCC snapshot consistent with the transaction’s isolation level.</li>
<li>Operators consult the snapshot for tuple visibility, acquire table/row locks through <code>TxnRuntime</code>, and issue heap/index operations.</li>
<li>DML operators register undo records and append WAL entries via the transaction manager. When the user commits, the manager emits <code>Commit</code> records, waits for durability as configured, and releases locks.</li>
</ol>
<hr />
<h2 id="2-transaction--mvcc-mechanics"><a class="header" href="#2-transaction--mvcc-mechanics">2. Transaction &amp; MVCC Mechanics</a></h2>
<pre class="mermaid">sequenceDiagram
    participant Session
    participant TM as TransactionManager
    participant Runtime as TxnRuntime
    participant Exec as Operator
    participant Heap as TableHeap

    Session-&gt;&gt;TM: begin(isolation, access_mode)
    TM--&gt;&gt;Session: Transaction handle
    Exec-&gt;&gt;Runtime: TxnRuntime::new(&amp;TM, &amp;mut txn)
    Runtime--&gt;&gt;Exec: {snapshot, command_id}
    loop per tuple
        Exec-&gt;&gt;Heap: next()
        Heap--&gt;&gt;Exec: (rid, meta, tuple)
        Exec-&gt;&gt;Runtime: is_visible(meta)?
        Runtime--&gt;&gt;Exec: yes/no (uses cached snapshot)
        alt Visible
            Exec-&gt;&gt;Runtime: lock_row(...)
            Exec-&gt;&gt;TM: record undo + WAL
        end
    end
    Session-&gt;&gt;TM: commit(txn)
    TM-&gt;&gt;WAL: Transaction(Commit)
    TM-&gt;&gt;TM: wait_for_durable / flush_until
    TM--&gt;&gt;Session: release locks, clear snapshot
</pre>
<ul>
<li>
<p><strong>Snapshots</strong></p>
<ul>
<li><em>Read Committed / Read Uncommitted:</em> Every command refreshes its snapshot and clears any cached value on the transaction handle.</li>
<li><em>Repeatable Read / Serializable:</em> The first command captures a snapshot (<code>xmin</code>, <code>xmax</code>, <code>active_txns</code>) and stores it inside <code>Transaction</code>. Subsequent commands reuse it, ensuring consistent reads.</li>
<li>Background MVCC vacuum consults <code>TransactionManager::oldest_active_txn()</code> to compute <code>safe_xmin</code> and prunes tuple versions whose inserting/deleting transactions precede that boundary.</li>
</ul>
</li>
<li>
<p><strong>Locking</strong><br />
Multi-granularity 2PL (IS/IX/S/SIX/X) enforced by <code>LockManager</code>. Repeatable Read releases shared locks at the end of each command (after verifying visibility). Serializable keeps shared locks through commit. Deadlocks are detected via a wait-for graph; a victim simply fails its lock request.</p>
</li>
<li>
<p><strong>Undo &amp; WAL</strong><br />
<code>Transaction</code> maintains logical undo entries. On abort, the manager emits CLR records and performs the inverse heap operations. Commit waits depend on <code>synchronous_commit</code>. Buffer frames retain their <code>page_lsn</code> so WAL-before-data holds.</p>
</li>
<li>
<p><strong>Executor safeguards</strong><br />
<code>PhysicalUpdate</code> now skips tuple versions created by the same <code>(txn_id, command_id)</code> during the current command. This prevents re-processing the freshly inserted MVCC version and thereby avoids infinite loops.</p>
</li>
</ul>
<hr />
<h2 id="3-storage--buffering"><a class="header" href="#3-storage--buffering">3. Storage &amp; Buffering</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Highlights</th></tr></thead><tbody>
<tr><td><code>TableHeap</code></td><td>Tuple metadata (<code>TupleMeta</code>) stores inserting/deleting txn ids, command ids, and forward/back pointers for version chains. Helpers like <code>mvcc_update</code> stitch new versions while marking old ones deleted.</td></tr>
<tr><td><code>B+Tree</code></td><td>B-link tree implementation with separate codecs for header/internal/leaf pages. Index maintenance occurs in DML operators after the heap change succeeds.</td></tr>
<tr><td><code>BufferManager</code></td><td>Combines a page table, LRU-K replacer (with TinyLFU admission option), and per-frame guards. Dirty pages record their first-dirty LSN, feeding checkpoints. The background writer periodically flushes dirty frames and drives lazy index cleanup.</td></tr>
<tr><td><code>DiskScheduler</code></td><td>Uses io_uring worker threads. Foreground tasks push <code>ReadPage</code>, <code>WritePage</code>, <code>WriteWal</code>, and <code>FsyncWal</code> commands through lock-free queues and receive completion on dedicated channels.</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="4-write-ahead-logging--recovery"><a class="header" href="#4-write-ahead-logging--recovery">4. Write-Ahead Logging &amp; Recovery</a></h2>
<ul>
<li><code>WalManager</code> manages log sequence numbers, buffers frames, writes physical (<code>PageWrite</code>, <code>PageDelta</code>) and logical (<code>HeapInsert/Update/Delete</code>) records, and coordinates flushes. First-page-writes guard against torn pages.</li>
<li><code>background::spawn_checkpoint_worker</code> emits <code>Checkpoint</code> records capturing the dirty page table and active transactions so recovery can cut replay short.</li>
<li><code>RecoveryManager</code> executes ARIES-style <strong>analysis → redo → undo</strong> on restart, leveraging CLRs to keep undo idempotent.</li>
<li>WAL and data I/O both use the <code>DiskScheduler</code>, keeping durability guarantees in one place.</li>
</ul>
<hr />
<h2 id="5-background-services"><a class="header" href="#5-background-services">5. Background Services</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Worker</th><th>Description</th><th>Trigger</th></tr></thead><tbody>
<tr><td>WAL writer</td><td>Coalesces buffered WAL into durable segments</td><td><code>WalManager::start_background_flush</code></td></tr>
<tr><td>Checkpoint</td><td>Flushes LSNs, records ATT + DPT snapshots, resets FPW epoch</td><td>Configurable interval (<code>WalOptions::checkpoint_interval_ms</code>)</td></tr>
<tr><td>Buffer writer</td><td>Flushes dirty frames, runs index lazy cleanup based on pending garbage counters</td><td><code>IndexVacuumConfig</code></td></tr>
<tr><td>MVCC vacuum</td><td>Iterates table heaps, removing committed-deleted or aborted-inserted tuples older than <code>safe_xmin</code></td><td><code>MvccVacuumConfig</code> (interval + batch limit)</td></tr>
</tbody></table>
</div>
<p>All workers are registered with <code>background::BackgroundWorkers</code>, which stops and joins them on database shutdown.</p>
<hr />
<h2 id="6-example-timeline-repeatable-read-update"><a class="header" href="#6-example-timeline-repeatable-read-update">6. Example Timeline: Repeatable Read UPDATE</a></h2>
<pre><code>T1 (RR)                               T2 (RC)
-----------                           -----------
BEGIN;                                BEGIN;
SELECT ... (snapshot S0)              UPDATE row -&gt; new version V1
                                      COMMIT (WAL + flush)
SELECT again -&gt; sees original value
COMMIT
-- background vacuum later reclaims deleted version when safe_xmin &gt; delete_txn
</code></pre>
<ul>
<li>T1’s <code>TxnRuntime</code> caches snapshot S0 on its first command and reuses it, so the second <code>SELECT</code> filters out V1 even though T2 committed.</li>
<li>Row-level shared locks acquired during the read are released at the end of the command, while the MVCC snapshot keeps the view consistent.</li>
<li>When T1 commits, locks are dropped, snapshot cache is cleared, and WAL commit record becomes durable. Vacuum eventually removes T1’s deleted predecessor when all transactions with <code>txn_id &lt; safe_xmin</code> have finished.</li>
</ul>
<hr />
<h2 id="7-observability--configuration"><a class="header" href="#7-observability--configuration">7. Observability &amp; Configuration</a></h2>
<ul>
<li>Enable tracing via <code>RUST_LOG=trace</code> to inspect lock grant/queue events and MVCC vacuum activity.</li>
<li>Key knobs exposed through CLI/environment: WAL segment size, background intervals, default isolation level, MVCC vacuum batch size.</li>
<li><code>background::BackgroundWorkers::snapshot()</code> reports active worker metadata; you can surface it for debugging endpoints.</li>
</ul>
<hr />
<h2 id="8-roadmap"><a class="header" href="#8-roadmap">8. Roadmap</a></h2>
<ul>
<li>Predicate locking / SSI to upgrade Serializable beyond strict 2PL.</li>
<li>Cost-based optimization with catalog statistics.</li>
<li>Smarter vacuum pacing tied to storage pressure and tuple churn.</li>
<li>Parallel execution and adaptive readahead hints based on operator feedback.</li>
</ul>
<p>Even with these future items, the current layering mirrors production databases (e.g., PostgreSQL): MVCC + 2PL, ARIES-style WAL, asynchronous maintenance, and a modular Volcano executor—all while keeping the codebase approachable for teaching and experimentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors-guide"><a class="header" href="#contributors-guide">Contributor's Guide</a></h1>
<p>Welcome, and thank you for your interest in contributing to QuillSQL! Whether you're fixing a bug, adding a new feature, or improving the documentation, this guide will help you get started.</p>
<h2 id="1-getting-started-your-development-environment"><a class="header" href="#1-getting-started-your-development-environment">1. Getting Started: Your Development Environment</a></h2>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<ul>
<li><strong>Rust</strong>: QuillSQL is written in Rust. If you don't have it yet, install it via <a href="https://rustup.rs/">rustup</a>. This will provide you with <code>rustc</code> (the compiler) and <code>cargo</code> (the package manager and build tool).
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
</li>
<li><strong>Build Essentials</strong>: Ensure you have a C++ compiler like <code>gcc</code> or <code>clang</code> installed, which is a common dependency for some Rust crates.</li>
</ul>
<h3 id="setup"><a class="header" href="#setup">Setup</a></h3>
<ol>
<li>
<p><strong>Fork the Repository</strong>: Start by forking the main QuillSQL repository to your own GitHub account.</p>
</li>
<li>
<p><strong>Clone Your Fork</strong>: Clone your forked repository to your local machine.</p>
<pre><code class="language-bash">git clone https://github.com/YOUR_USERNAME/QuillSQL.git
cd QuillSQL
</code></pre>
</li>
<li>
<p><strong>Build the Project</strong>: Compile the entire project to ensure everything is set up correctly.</p>
<pre><code class="language-bash">cargo build
</code></pre>
</li>
</ol>
<h2 id="2-development-workflow"><a class="header" href="#2-development-workflow">2. Development Workflow</a></h2>
<h3 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h3>
<p>Before and after making any changes, it's crucial to run the test suite to ensure you haven't broken anything.</p>
<ul>
<li>
<p><strong>Run all unit and integration tests</strong>:</p>
<pre><code class="language-bash">cargo test
</code></pre>
</li>
<li>
<p><strong>Run the benchmark suite</strong>:</p>
<pre><code class="language-bash">cargo bench
</code></pre>
</li>
</ul>
<h3 id="code-style-and-quality"><a class="header" href="#code-style-and-quality">Code Style and Quality</a></h3>
<p>We adhere to the standard Rust coding style and use tools to enforce it.</p>
<ul>
<li>
<p><strong>Formatting</strong>: Before committing, please format your code with <code>rustfmt</code>.</p>
<pre><code class="language-bash">cargo fmt --all
</code></pre>
</li>
<li>
<p><strong>Linting</strong>: We use <code>clippy</code> to catch common mistakes and improve code quality. Please ensure <code>clippy</code> passes without warnings.</p>
<pre><code class="language-bash">cargo clippy --all-targets -- -D warnings
</code></pre>
</li>
</ul>
<h3 id="submitting-your-contribution"><a class="header" href="#submitting-your-contribution">Submitting Your Contribution</a></h3>
<ol>
<li>
<p><strong>Create a New Branch</strong>: Create a descriptive branch name for your feature or bugfix.</p>
<pre><code class="language-bash">git checkout -b my-awesome-feature
</code></pre>
</li>
<li>
<p><strong>Make Your Changes</strong>: Write your code. Add new tests to cover your changes. Ensure all existing tests still pass.</p>
</li>
<li>
<p><strong>Format and Lint</strong>: Run <code>cargo fmt</code> and <code>cargo clippy</code> as described above.</p>
</li>
<li>
<p><strong>Commit Your Work</strong>: Write a clear and concise commit message.</p>
<pre><code class="language-bash">git add .
git commit -m "feat: Add support for window functions"
</code></pre>
</li>
<li>
<p><strong>Push to Your Fork</strong>: Push your branch to your fork on GitHub.</p>
<pre><code class="language-bash">git push -u origin my-awesome-feature
</code></pre>
</li>
<li>
<p><strong>Open a Pull Request</strong>: Go to the original QuillSQL repository on GitHub. You should see a prompt to open a Pull Request from your new branch. Fill out the PR template with a description of your changes.</p>
</li>
</ol>
<h2 id="3-working-on-the-documentation"><a class="header" href="#3-working-on-the-documentation">3. Working on the Documentation</a></h2>
<p>The documentation is built using <code>mdbook</code>. To preview your changes locally, you'll need to install it and the <code>mermaid</code> plugin.</p>
<ol>
<li>
<p><strong>Install <code>mdbook</code> and <code>mdbook-mermaid</code></strong>:</p>
<pre><code class="language-bash">cargo install mdbook
cargo install mdbook-mermaid
</code></pre>
</li>
<li>
<p><strong>Serve the Book Locally</strong>: Run the following command from the root of the project.</p>
<pre><code class="language-bash">mdbook serve docs
</code></pre>
<p>This will build the book and start a local web server. You can open your browser to <code>http://localhost:3000</code> to see the live-previewed documentation.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="buffer-manager"><a class="header" href="#buffer-manager">Buffer Manager</a></h1>
<p>In any disk-based database, the speed difference between main memory (RAM) and persistent storage (SSD/HDD) is enormous. The <strong>Buffer Manager</strong> is the component designed to solve this problem. It acts as a cache, managing a region of main memory called the <strong>Buffer Pool</strong> and moving data pages between disk and memory as needed.</p>
<p>Its primary goal is to minimize disk I/O by keeping frequently accessed pages in memory.</p>
<p>This section is divided into the following parts:</p>
<ul>
<li><strong><a href="modules/../buffer/page.html">Page &amp; Page Guards</a></strong>: Explains the core concepts of pinning and the RAII guards used to safely access pages.</li>
<li><strong><a href="modules/../buffer/buffer_pool.html">The Buffer Pool</a></strong>: A deep dive into the architecture and lifecycle of a page request, including the page table, replacer, and concurrency.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="page--page-guards"><a class="header" href="#page--page-guards">Page &amp; Page Guards</a></h1>
<p>Before the Buffer Manager can hand out a reference to a page in memory, it must ensure that the page won't be evicted while it's being used by another thread. This is accomplished by <strong>pinning</strong>.</p>
<h2 id="pinning"><a class="header" href="#pinning">Pinning</a></h2>
<p>Pinning simply means incrementing a "pin count" associated with the page's frame in the buffer pool. A frame with a pin count greater than zero is forbidden from being chosen as a victim by the page replacer.</p>
<ul>
<li>When a thread wants to use a page, it must first pin it.</li>
<li>When the thread is finished with the page, it must <strong>unpin</strong> it (decrementing the count).</li>
</ul>
<p>Manually managing pin counts is tedious and error-prone. Forgetting to unpin a page leads to a memory leak, as the frame can never be evicted. To solve this, QuillSQL uses a common and powerful C++ and Rust pattern: <strong>Resource Acquisition Is Initialization (RAII)</strong>.</p>
<h2 id="readpageguard-and-writepageguard"><a class="header" href="#readpageguard-and-writepageguard"><code>ReadPageGuard</code> and <code>WritePageGuard</code></a></h2>
<p>Instead of returning a raw pointer to the page memory, the <code>BufferManager</code>'s <code>fetch_page_*</code> methods return a <strong>guard</strong> object: <code>ReadPageGuard</code> or <code>WritePageGuard</code>.</p>
<p>These guards are responsible for the lifetime of the pin and the lock on the page:</p>
<ol>
<li>
<p><strong>Acquisition</strong>: When a <code>PageGuard</code> is created, its constructor acquires the appropriate lock (<code>RwLock</code>) on the page's frame and increments the frame's pin count.</p>
<ul>
<li><code>ReadPageGuard</code> takes a read lock, allowing multiple concurrent readers.</li>
<li><code>WritePageGuard</code> takes an exclusive write lock.</li>
</ul>
</li>
<li>
<p><strong>Usage</strong>: The calling code uses the guard object to access the page's data. The guard provides safe, locked access to the underlying byte array.</p>
</li>
<li>
<p><strong>Release</strong>: When the guard variable goes out of scope (e.g., at the end of a function), its <code>drop()</code> method is automatically called by the Rust compiler. This <code>drop()</code> implementation handles all the cleanup:</p>
<ul>
<li>It decrements the pin count.</li>
<li>It releases the lock on the frame.</li>
<li>If it's a <code>WritePageGuard</code> and the data was modified, it informs the <code>BufferManager</code> that the page is now <strong>dirty</strong>.</li>
</ul>
</li>
</ol>
<p>This RAII pattern makes using the buffer pool much safer and more ergonomic, as it makes it impossible to forget to unpin a page or release a lock.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-buffer-pool-architecture-and-lifecycle"><a class="header" href="#the-buffer-pool-architecture-and-lifecycle">The Buffer Pool: Architecture and Lifecycle</a></h1>
<h2 id="1-core-components--architecture"><a class="header" href="#1-core-components--architecture">1. Core Components &amp; Architecture</a></h2>
<p>QuillSQL's buffer management is split into two main structs, reflecting a separation of concerns:</p>
<ul>
<li><strong><code>BufferPool</code> (<code>buffer/buffer_pool.rs</code>)</strong>: A low-level, "dumb" container. It owns the actual memory arena for pages and provides basic mapping from a <code>PageId</code> to a memory location (<code>FrameId</code>).</li>
<li><strong><code>BufferManager</code> (<code>buffer/buffer_manager.rs</code>)</strong>: The high-level, "smart" coordinator. It contains the <code>BufferPool</code> and implements all the logic for fetching pages, choosing which pages to evict, and interacting with other database components like the transaction and recovery managers.</li>
</ul>
<p>This architecture is centered around three key data structures:</p>
<ol>
<li>
<p><strong>Frames (The Arena)</strong>: The <code>BufferPool</code> pre-allocates a large, contiguous block of memory on the heap. This block is divided into a fixed number of smaller chunks called <strong>frames</strong>. Each frame is exactly <code>PAGE_SIZE</code> (4KB) and can hold the contents of one disk page.</p>
</li>
<li>
<p><strong>Page Table (<code>page_table</code>)</strong>: A hash map (specifically, a concurrent <code>DashMap</code>) that maps a logical <code>PageId</code> to the <code>FrameId</code> where it currently resides in memory. This provides fast O(1) lookups to check if a page is already in the buffer pool.</p>
</li>
<li>
<p><strong>Replacer (<code>LRUKReplacer</code>)</strong>: When a requested page is not in memory and the buffer pool is full, one of the existing pages must be <strong>evicted</strong> to make room. The <code>Replacer</code> is the component that implements the page replacement policy and decides which page is the best candidate for eviction. QuillSQL uses an <strong>LRU-K</strong> replacement policy, a sophisticated variant of the classic Least Recently Used (LRU) algorithm.</p>
</li>
</ol>
<h2 id="2-the-lifecycle-of-a-page-request"><a class="header" href="#2-the-lifecycle-of-a-page-request">2. The Lifecycle of a Page Request</a></h2>
<p>When another part of the database (e.g., the execution engine) needs to access a page, it calls <code>buffer_manager.fetch_page_read(page_id)</code> or <code>fetch_page_write(page_id)</code>. This initiates a critical sequence of events.</p>
<p>The flow is as follows:</p>
<ol>
<li>
<p><strong>Request</strong>: An executor requests Page <code>P</code>.</p>
</li>
<li>
<p><strong>Lookup</strong>: The <code>BufferManager</code> consults the <code>PageTable</code>.</p>
</li>
<li>
<p><strong>Case 1: Cache Hit</strong></p>
<ul>
<li>The <code>PageTable</code> contains an entry for <code>P</code>, mapping it to <code>FrameId</code> <code>F</code>.</li>
<li>The <code>BufferManager</code> increments the pin count for frame <code>F</code>.</li>
<li>It informs the <code>LRUKReplacer</code> that the page has been accessed (updating its priority).</li>
<li>It returns a <code>PageGuard</code> wrapping a reference to the memory in frame <code>F</code>.</li>
</ul>
</li>
<li>
<p><strong>Case 2: Cache Miss</strong></p>
<ul>
<li>The <code>PageTable</code> has no entry for <code>P</code>.</li>
<li>The <code>BufferManager</code> must bring the page from disk. It asks the <code>Replacer</code> to choose a <strong>victim frame</strong> <code>F_v</code> to evict.</li>
<li><strong>If the victim frame <code>F_v</code> is dirty</strong>: The <code>BufferManager</code> first writes the contents of <code>F_v</code> back to disk via the <code>DiskScheduler</code>. This is essential for data durability.</li>
<li>The <code>PageTable</code> entry for the old page residing in <code>F_v</code> is removed.</li>
<li>The <code>BufferManager</code> issues a read request to the <code>DiskScheduler</code> to load page <code>P</code>'s data from disk into frame <code>F_v</code>.</li>
<li>The <code>PageTable</code> is updated with the new mapping: <code>P -&gt; F_v</code>.</li>
<li>The process then continues like a cache hit: frame <code>F_v</code> is pinned and a <code>PageGuard</code> is returned.</li>
</ul>
</li>
</ol>
<h2 id="3-concurrency"><a class="header" href="#3-concurrency">3. Concurrency</a></h2>
<p>The buffer pool is a shared resource accessed by many concurrent threads. QuillSQL uses a combination of locking strategies:</p>
<ul>
<li><strong>Page Table</strong>: A <code>DashMap</code> is used for the page table, which is highly optimized for concurrent reads and writes.</li>
<li><strong>Frame-Level Locks</strong>: Each frame in the pool has its own <code>RwLock</code>. A <code>ReadPageGuard</code> acquires a read lock on the frame, allowing multiple threads to read the same page concurrently. A <code>WritePageGuard</code> acquires an exclusive write lock, ensuring that only one thread can modify a page at a time.</li>
<li><strong>Replacer/Free List</strong>: These shared structures are protected by a <code>Mutex</code>.</li>
</ul>
<h2 id="4-integration-with-wal-and-recovery"><a class="header" href="#4-integration-with-wal-and-recovery">4. Integration with WAL and Recovery</a></h2>
<p>The Buffer Manager is a key player in the ARIES recovery protocol.</p>
<ul>
<li><strong>Dirty Pages</strong>: When a <code>WritePageGuard</code> is dropped, if it has modified the page, it marks the page as <strong>dirty</strong>. The <code>BufferManager</code> maintains a <code>dirty_page_table</code> that tracks all dirty pages and the Log Sequence Number (LSN) of the first WAL record that caused the page to become dirty.</li>
<li><strong>Forced WAL (Write-Ahead Logging)</strong>: Before a dirty page can be written back to disk (either during eviction or a checkpoint), the <code>BufferManager</code> must ensure that all WAL records up to that page's current LSN have been flushed to durable storage. This is the fundamental <strong>WAL rule</strong> and is enforced by the <code>flush_page</code> method, which calls <code>wal_manager.flush(lsn)</code> before writing the page to disk.</li>
</ul>
<hr />
<h2 id="for-study--discussion"><a class="header" href="#for-study--discussion">For Study &amp; Discussion</a></h2>
<ol>
<li>
<p><strong>Replacement Policies</strong>: QuillSQL uses LRU-K. What are the potential advantages of LRU-K over a simple LRU policy? What kind of workload would benefit most? Conversely, what are the trade-offs of using Clock/Second-Chance instead?</p>
</li>
<li>
<p><strong>The "Double Caching" Problem</strong>: We mentioned that using Direct I/O helps avoid double caching. If Direct I/O is disabled, how does the database's buffer pool interact with the operating system's file system cache? Why can this lead to suboptimal performance?</p>
</li>
<li>
<p><strong>Programming Exercise</strong>: Implement a <code>ClockReplacer</code> that adheres to the <code>Replacer</code> trait. Modify the <code>BufferManager</code> to use your new replacer instead of <code>LRUKReplacer</code>. Run the benchmark suite and compare the performance. Does it change?</p>
</li>
<li>
<p><strong>Programming Exercise</strong>: Add metrics to the <code>BufferManager</code> to track the buffer pool hit rate (i.e., <code>num_hits / (num_hits + num_misses)</code>). You could expose this via a new <code>SHOW BUFFER_STATS;</code> SQL command.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-engine"><a class="header" href="#storage-engine">Storage Engine</a></h1>
<p>The storage engine is where the logical world of SQL tables and rows meets the physical world of disk blocks and bytes. Understanding how data is laid out on disk is fundamental to understanding database performance, concurrency control, and recovery.</p>
<p>This section is divided into the following parts:</p>
<ul>
<li><strong><a href="modules/../storage/disk_io.html">Disk I/O</a></strong>: A look at the asynchronous I/O layer using <code>io_uring</code>.</li>
<li><strong><a href="modules/../storage/page_layouts.html">Page &amp; Tuple Layout</a></strong>: A deep dive into how pages and tuples are physically structured on disk, including the slotted page layout.</li>
<li><strong><a href="modules/../storage/table_heap.html">Table Heap</a></strong>: Explains how tuple versions are managed for MVCC.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="disk-io--scheduler-io_uring-data-pages--wal-runtime"><a class="header" href="#disk-io--scheduler-io_uring-data-pages--wal-runtime">Disk I/O — Scheduler, io_uring Data Pages &amp; WAL Runtime</a></h1>
<h2 id="1-architecture"><a class="header" href="#1-architecture">1. Architecture</a></h2>
<ul>
<li><strong>Request Path</strong>: foreground components enqueue <code>DiskRequest</code> objects via <code>DiskScheduler::{schedule_read, schedule_write, …}</code>. A dispatcher thread drains the global channel and distributes work round-robin to N io_uring workers. Each worker owns its own ring and file-descriptor cache, so once a request is forwarded, execution proceeds entirely off the foreground thread.</li>
<li><strong>Stable APIs</strong>: <code>schedule_read(page_id)</code>, <code>schedule_write(page_id, Bytes)</code>, <code>schedule_read_pages(Vec&lt;PageId&gt;)</code>, <code>schedule_allocate()</code>, <code>schedule_deallocate(page_id)</code> — every call returns a channel the caller can block on or poll.</li>
<li><strong>Batch Reads</strong>: <code>ReadPages</code> fans out per-page SQEs while a shared <code>BatchState</code> tracks completions. Even if the kernel completes I/O out of order, the caller receives a <code>Vec&lt;BytesMut&gt;</code> that preserves the original page order.</li>
</ul>
<h2 id="2-wal-runtime-buffered-io"><a class="header" href="#2-wal-runtime-buffered-io">2. WAL Runtime (buffered I/O)</a></h2>
<ul>
<li>Dedicated WAL runtime threads handle sequential WAL appends/reads using buffered I/O. They now keep a per-thread cache of open segment files, eliminating repeated <code>open()</code>/<code>close()</code> on every log record.</li>
<li>Worker count defaults to <code>max(1, available_parallelism / 2)</code> but is tunable through <code>IOSchedulerConfig</code>.</li>
<li>Optional <code>sync</code> on a request triggers <code>sync_data</code> / <code>fdatasync</code> so <code>WalManager</code> can honour synchronous commit or checkpoint barriers. Data pages stay on the io_uring dataplane; WAL always uses buffered writes.</li>
</ul>
<h2 id="3-io_uring-backend-linux"><a class="header" href="#3-io_uring-backend-linux">3. io_uring Backend (Linux)</a></h2>
<ul>
<li>Each worker owns an <code>IoUring</code> with configurable <code>queue_depth</code>, optional SQPOLL idle timeout, and a pool of registered fixed buffers sized to <code>PAGE_SIZE</code>. Workers submit SQEs asynchronously and drain CQEs in small batches to keep the ring warm.</li>
<li>Read batching relies on shared <code>BatchState</code> instances (<code>Rc&lt;RefCell&lt;_&gt;&gt;</code>) so multi-page callers see ordered results without blocking the kernel on serialization.</li>
<li>Writes keep their payload alive until completion; if a fixed buffer slot is available we reuse it, otherwise we fall back to heap buffers. A companion <code>WriteState</code> tracks an optional <code>fdatasync</code> so the caller still observes exactly one <code>Result&lt;()&gt;</code> once all CQEs land.</li>
<li>Errors (short read/write, errno) are normalised into <code>QuillSQLError</code> values that flow back on the original channel.</li>
</ul>
<h2 id="4-configuration"><a class="header" href="#4-configuration">4. Configuration</a></h2>
<ul>
<li><code>config::IOSchedulerConfig</code> controls:
<ul>
<li><code>workers</code>: number of io_uring workers (default = available parallelism).</li>
<li><code>wal_workers</code>: WAL runtime threads (default workers / 2).</li>
<li><code>iouring_queue_depth</code>, <code>iouring_fixed_buffers</code>, <code>iouring_sqpoll_idle_ms</code>.</li>
<li><code>fsync_on_write</code>: whether data-page writes also issue <code>fdatasync</code> (WAL sync is managed separately by <code>WalManager</code>).</li>
</ul>
</li>
</ul>
<h2 id="5-concurrency--safety"><a class="header" href="#5-concurrency--safety">5. Concurrency &amp; Safety</a></h2>
<ul>
<li>Worker-local file descriptors plus positional I/O remove shared mutable state on the hot path. The new per-worker handle cache further reduces syscall overhead.</li>
<li>Shutdown sequence: enqueue <code>Shutdown</code>, dispatcher forwards it to every worker, each worker drains outstanding SQEs/CQEs, and finally dispatcher + workers are joined.</li>
<li>BufferPool, TableHeap, and the streaming scan ring buffer still integrate via channels; inflight guards prevent duplicate page fetches.</li>
</ul>
<h2 id="6-performance-notes"><a class="header" href="#6-performance-notes">6. Performance Notes</a></h2>
<ul>
<li>Random page access benefits from fewer syscalls and deeper outstanding queue depth than the blocking fallback.</li>
<li>Only the io_uring backend currently ships (Linux x86_64). A portable fallback remains future work.</li>
<li>For large sequential scans, combine <code>ReadPages</code> with the ring-buffer iterator to minimise buffer-pool churn.</li>
</ul>
<h2 id="7-future-work"><a class="header" href="#7-future-work">7. Future Work</a></h2>
<ul>
<li>Queue-depth aware scheduling and CQE bulk harvesting.</li>
<li>Optional group commit (aggregate writes, single fsync) behind configuration.</li>
<li>Metrics hooks (queue depth, submit/complete throughput, latency percentiles, error codes).</li>
<li>Cross-platform fallback backend and richer prioritisation/throttling policies.</li>
<li>Control-plane knobs for throttling individual background workers.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="page-and-tuple-layout"><a class="header" href="#page-and-tuple-layout">Page and Tuple Layout</a></h1>
<h2 id="1-the-page-the-atomic-unit-of-io"><a class="header" href="#1-the-page-the-atomic-unit-of-io">1. The Page: The Atomic Unit of I/O</a></h2>
<p>A database file is not treated as one continuous stream of data. Instead, it is broken down into fixed-size blocks called <strong>pages</strong>. A page is the atomic unit of transfer between the disk and the in-memory <a href="storage/../modules/buffer.html">Buffer Pool</a>. Whenever the database needs to read a piece of data (like a single row), it must load the <em>entire page</em> containing that data into memory.</p>
<p>In QuillSQL, the page size is a constant defined at <code>quill-sql/src/buffer/mod.rs</code>:</p>
<ul>
<li><strong><code>PAGE_SIZE</code></strong>: 4096 bytes (4 KB)</li>
</ul>
<p>This fixed-size approach simplifies buffer management and allows for efficient, aligned I/O operations, especially when using Direct I/O to bypass the OS cache.</p>
<h2 id="2-tablepage-the-slotted-page-layout"><a class="header" href="#2-tablepage-the-slotted-page-layout">2. <code>TablePage</code>: The Slotted Page Layout</a></h2>
<p>While a page is a generic 4KB block of bytes, pages that store actual table data are structured in a specific way. QuillSQL uses a classic <strong>Slotted Page</strong> layout, which is a core concept in database implementation (as taught in CMU 15-445).</p>
<p>A <code>TablePage</code> is organized into three main parts:</p>
<pre><code>&lt;------------------------------ 4KB ------------------------------&gt;
+----------------+-----------------+-----------------+--------------+
|  Page Header   |   Slot Array    |      Free       |   Tuple      |
| (grows -&gt;)     |   (grows -&gt;)    |      Space      |     Data     |
|                |                 |                 | (&lt;- grows)   |
+----------------+-----------------+-----------------+--------------+
</code></pre>
<ol>
<li><strong>Page Header (<code>TablePageHeader</code>)</strong>: Located at the beginning of the page. It contains metadata about the page itself.</li>
<li><strong>Slot Array (<code>tuple_infos</code>)</strong>: An array of <code>TupleInfo</code> structs that grows from after the header. Each entry in this array acts as a "pointer" or "directory entry" for a tuple on the page.</li>
<li><strong>Tuple Data</strong>: The actual raw data of the tuples is stored starting from the <strong>end</strong> of the page, growing backwards towards the middle.</li>
</ol>
<p>This design has a key advantage: <strong>it decouples a tuple's logical identifier from its physical location on the page.</strong></p>
<h3 id="the-recordid-rid"><a class="header" href="#the-recordid-rid">The <code>RecordId</code> (RID)</a></h3>
<p>A specific tuple is uniquely identified by a <code>RecordId</code> (RID). The RID is a stable pointer composed of two parts:</p>
<ul>
<li><strong><code>page_id</code></strong>: The ID of the page where the tuple resides.</li>
<li><strong><code>slot_num</code></strong>: The <strong>index</strong> into the Slot Array on that page.</li>
</ul>
<p>So, <code>RID = (page_id, slot_num)</code>.</p>
<p>When the database needs to delete a tuple or if a variable-length tuple is updated and grows in size, the tuple's data might need to be moved within the page (for compaction). In a slotted page design, we only need to update the <code>offset</code> in the corresponding slot array entry. The tuple's RID (<code>page_id</code>, <code>slot_num</code>) <strong>remains unchanged</strong>. This prevents a cascade of updates to all secondary indexes that might be pointing to that tuple.</p>
<h3 id="tablepageheader-and-slot-tupleinfo"><a class="header" href="#tablepageheader-and-slot-tupleinfo"><code>TablePageHeader</code> and Slot (<code>TupleInfo</code>)</a></h3>
<p>Let's look at the physical layout, as defined in <code>storage/codec/table_page.rs</code>:</p>
<ul>
<li>
<p><strong><code>TablePageHeader</code></strong>:</p>
<ul>
<li><code>lsn</code>: The Log Sequence Number of the last change made to this page, crucial for WAL recovery.</li>
<li><code>next_page_id</code>: The ID of the next page in this table, forming a linked list of pages.</li>
<li><code>num_tuples</code>: The number of active tuples on the page.</li>
<li><code>num_deleted_tuples</code>: The number of "dead" or deleted tuples.</li>
<li><code>tuple_infos</code>: The slot array itself.</li>
</ul>
</li>
<li>
<p><strong><code>TupleInfo</code></strong> (A single slot in the array):</p>
<ul>
<li><code>offset</code>: The byte offset from the beginning of the page where the tuple's data begins.</li>
<li><code>size</code>: The size of the tuple's data in bytes.</li>
<li><code>meta</code>: A nested <code>TupleMeta</code> struct containing critical information for concurrency control.</li>
</ul>
</li>
</ul>
<hr />
<h2 id="for-study--discussion-1"><a class="header" href="#for-study--discussion-1">For Study &amp; Discussion</a></h2>
<ol>
<li>
<p><strong>Layout Trade-offs</strong>: What is the main benefit of having the tuple data grow from the end of the page backwards, while the header and slot array grow from the beginning forwards? What happens when they meet?</p>
</li>
<li>
<p><strong>Record ID Stability</strong>: Why is it so important that a tuple's <code>RecordId</code> does not change even if the tuple's physical data is moved within the page? What would break if the RID was just a direct byte offset?</p>
</li>
<li>
<p><strong>Large Objects</strong>: The current design assumes a tuple fits entirely on one page. How would you modify this page layout to support tuples that are larger than 4KB (e.g., a long blog post stored in a <code>VARCHAR</code> column)? Research how systems like PostgreSQL handle this with their "TOAST" (The Oversized-Attribute Storage Technique) mechanism.</p>
</li>
<li>
<p><strong>Programming Exercise</strong>: Implement a <code>defragment()</code> method for the <code>TablePage</code>. After several insertions and deletions, the free space on a page can become fragmented into small, unusable chunks. This method should reorganize the page by moving the existing tuples to be contiguous, creating a single, large block of free space. Remember to update the <code>offset</code> in each <code>TupleInfo</code> slot after moving its corresponding tuple data!</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table-heap-and-mvcc"><a class="header" href="#table-heap-and-mvcc">Table Heap and MVCC</a></h1>
<p>The <code>TableHeap</code> (<code>storage/table_heap.rs</code>) is the component responsible for managing the collection of pages that belong to a single table. While the <code>TablePage</code> defines the <em>layout</em> within a single page, the <code>TableHeap</code> provides the high-level API for inserting, updating, and deleting tuples, making it central to the implementation of MVCC.</p>
<h2 id="tuple-serialization"><a class="header" href="#tuple-serialization"><code>Tuple</code> Serialization</a></h2>
<p>A logical <code>Tuple</code> struct in memory must be converted into a byte array to be stored on a page. This process is handled by <code>storage/codec/tuple.rs</code>.</p>
<p>The serialized format of a tuple consists of two parts:</p>
<ol>
<li><strong>Null Bitmap</strong>: A compact bitmap at the beginning of the tuple data. Each bit corresponds to a column in the schema; if the bit is <code>1</code>, the column's value is <code>NULL</code>. This avoids storing any data for null fields.</li>
<li><strong>Attribute Data</strong>: The actual data for all non-null columns, serialized one after another.</li>
</ol>
<h2 id="tuplemeta-the-heart-of-mvcc"><a class="header" href="#tuplemeta-the-heart-of-mvcc"><code>TupleMeta</code>: The Heart of MVCC</a></h2>
<p>The most important part of a tuple's on-disk metadata is the <code>TupleMeta</code> struct, which is stored directly within the <code>TupleInfo</code> slot in the page header. This is the heart of QuillSQL's <strong>Multi-Version Concurrency Control (MVCC)</strong> implementation.</p>
<ul>
<li><strong><code>insert_txn_id</code></strong>: The ID of the transaction that created this version of the tuple.</li>
<li><strong><code>delete_txn_id</code></strong>: The ID of the transaction that "deleted" this version. (A value of <code>0</code> or <code>INVALID</code> means it's not deleted).</li>
<li><strong><code>is_deleted</code></strong>: A boolean flag indicating the tuple version is considered deleted.</li>
<li><strong><code>prev_version: Option&lt;RecordId&gt;</code></strong>: A link (RID) to the <em>previous</em> version of this logical row.</li>
<li><strong><code>next_version: Option&lt;RecordId&gt;</code></strong>: A link (RID) to the <em>next</em> version of this logical row.</li>
</ul>
<p>These fields allow QuillSQL to maintain a <strong>version chain</strong> for each logical row. When a row is updated, the <code>TableHeap</code>'s <code>mvcc_update</code> method is called, which, instead of overwriting the data, performs the following steps:</p>
<ol>
<li>Creates a new tuple version with the new data by calling <code>insert_tuple</code>.</li>
<li>Sets the <code>prev_version</code> pointer of this new version to the RID of the old version.</li>
<li>Updates the <code>next_version</code> pointer of the old version to point to the new version.</li>
<li>Sets the <code>delete_txn_id</code> on the old version to mark it as "dead".</li>
</ol>
<p>A transaction can then traverse this chain and use the transaction IDs in the <code>TupleMeta</code> to determine which version of a row is visible to it based on its own transaction ID and isolation level, thus achieving transaction isolation without long-held read locks.</p>
<hr />
<h2 id="for-study--discussion-2"><a class="header" href="#for-study--discussion-2">For Study &amp; Discussion</a></h2>
<ol>
<li>
<p><strong>Version Chain Traversal</strong>: Imagine a transaction with ID <code>T10</code> needs to read a row. It finds a version of the row that was inserted by <code>T5</code> (committed) but deleted by <code>T12</code> (in-progress). Should <code>T10</code> see this version? What if the deleter was <code>T8</code> (committed)? What if the deleter was <code>T10</code> itself? Walk through the visibility check logic.</p>
</li>
<li>
<p><strong>Garbage Collection</strong>: The MVCC model creates many "dead" tuple versions that are no longer visible to any active or future transaction. What is the long-term problem with leaving these dead versions in the database? This problem is typically solved by a process called <strong>vacuuming</strong> or garbage collection. When is it safe to physically remove a dead tuple version?</p>
</li>
<li>
<p><strong>Programming Exercise (Advanced)</strong>: Implement a basic <code>VACUUM</code> function for a <code>TableHeap</code>. This function should scan the table and identify dead tuple versions that are no longer visible to <em>any</em> currently active transaction. Once identified, it should physically remove them from their pages. This is a challenging exercise that touches transaction management, storage, and concurrency.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indexes"><a class="header" href="#indexes">Indexes</a></h1>
<p>Indexes are crucial for database performance. They are redundant data structures that allow the system to find rows matching specific criteria quickly, without having to scan the entire table. While indexes speed up queries (reads), they incur a cost during data modification (writes), as both the table and its indexes must be updated.</p>
<p>QuillSQL currently provides a <code>BPlusTreeIndex</code>.</p>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h2>
<ul>
<li>
<p><strong>Data Structure</strong>: The index is built using a B+Tree, a self-balancing tree data structure that maintains sorted data and allows for efficient insertion, deletion, and search operations (typically in O(log n) time).</p>
</li>
<li>
<p><strong>Index Keys</strong>: The B+Tree stores key-value pairs. The "key" is the value from the indexed column(s) (e.g., a user's ID), and the "value" is the <code>RecordId</code> (RID) of the row containing that key. This allows the database to first find the key in the B+Tree and then use the RID to immediately locate the full row data on its data page.</p>
</li>
<li>
<p><strong>Concurrency Control</strong>: The B+Tree implementation must be highly concurrent. QuillSQL's implementation uses advanced techniques like <strong>B-link (or B-link tree)</strong> page connections and <strong>latch-crabbing</strong> to allow multiple readers and writers to access the tree simultaneously with minimal contention.</p>
</li>
</ul>
<p>This section contains:</p>
<ul>
<li><strong><a href="modules/../index/btree_index.html">B+Tree</a></strong>: A look at the classic B+Tree data structure.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="b-tree-index--architecture-and-concurrency"><a class="header" href="#b-tree-index--architecture-and-concurrency">B+ Tree Index — Architecture and Concurrency</a></h1>
<h2 id="1-architecture-overview"><a class="header" href="#1-architecture-overview">1. Architecture Overview</a></h2>
<h3 id="11-node-and-page-structure"><a class="header" href="#11-node-and-page-structure">1.1 Node and Page Structure</a></h3>
<ul>
<li><strong>Node Types</strong>: <code>Internal</code> and <code>Leaf</code>.
<ul>
<li><strong>Internal Nodes</strong>: Store separator keys and pointers to child pages. The first pointer is a "sentinel" that points to the subtree for all keys less than the first key in the node.</li>
<li><strong>Leaf Nodes</strong>: Store <code>(key, RecordId)</code> pairs in sorted order. Leaves are linked together in a singly linked list (<code>next_page_id</code>) to allow for efficient range scans.</li>
</ul>
</li>
<li><strong>Header Page</strong>: A fixed page (<code>header_page_id</code>) that acts as the entry point to the tree. It stores the <code>root_page_id</code>, allowing for atomic updates to the tree root when it splits or shrinks.</li>
<li><strong>Page Layout</strong>:
<ul>
<li><strong>Internal Page</strong>: <code>{Header, High Key, Array&lt;(Key, ChildPageId)&gt;}</code>. The <code>High Key</code> is part of the B-link optimization.</li>
<li><strong>Leaf Page</strong>: <code>{Header, Array&lt;(Key, RID)&gt;}</code>.</li>
</ul>
</li>
</ul>
<h3 id="12-b-link-structure"><a class="header" href="#12-b-link-structure">1.2 B-link Structure</a></h3>
<p>The tree uses B-link pointers (<code>next_page_id</code>) on all levels (both internal and leaf nodes). This creates a "side-link" to the right sibling. This is crucial for concurrency, as it allows readers to recover from transient inconsistent states caused by concurrent page splits by "chasing" the link to the right sibling.</p>
<pre><code>              +------------------+
              |   Root (Int)     |
              +------------------+
             /         |         \
   +--------+      +--------+      +--------+
   | Int P1 |-----&gt;| Int P2 |-----&gt;| Int P3 |  (Internal B-link pointers)
   +--------+      +--------+      +--------+
   /   |   \      /   |   \      /   |   \
+----+ +----+  +----+ +----+  +----+ +----+
| L1 |-| L2 |-&gt;| L3 |-| L4 |-&gt;| L5 |-| L6 | (Leaf chain / B-links)
+----+ +----+  +----+ +----+  +----+ +----+
</code></pre>
<h2 id="2-concurrency-control"><a class="header" href="#2-concurrency-control">2. Concurrency Control</a></h2>
<p>The B+Tree employs a sophisticated, lock-free read path and a high-concurrency write path using latch crabbing.</p>
<h3 id="21-read-path-optimistic-lock-coupling-olc-with-b-links"><a class="header" href="#21-read-path-optimistic-lock-coupling-olc-with-b-links">2.1 Read Path: Optimistic Lock Coupling (OLC) with B-links</a></h3>
<ul>
<li>Readers traverse the tree from the root without taking any locks.</li>
<li>On each page, a <code>version</code> number is read before and after processing the page's contents. If the version changes, it indicates a concurrent modification, and the read operation restarts from the root.</li>
<li>If a reader is traversing an internal node and the search key is greater than or equal to the node's <code>high_key</code>, it knows a split has occurred. Instead of restarting, it can use the <code>next_page_id</code> B-link to "chase" to the right sibling and continue the search, minimizing restarts.</li>
</ul>
<h3 id="22-write-path-latch-crabbing"><a class="header" href="#22-write-path-latch-crabbing">2.2 Write Path: Latch Crabbing</a></h3>
<p>Writers (insert/delete) use a technique called <strong>latch crabbing</strong> (or lock coupling) to ensure safe concurrent modifications.</p>
<ul>
<li><strong>Process</strong>: A writer acquires a write latch on a parent node before fetching and latching a child node. Once the child is latched, the writer checks if the child is "safe" for the operation (i.e., not full for an insert, not at minimum size for a delete).
<ul>
<li>If the child is <strong>safe</strong>, the latch on the parent (and all other ancestors) is released.</li>
<li>If the child is <strong>unsafe</strong>, the parent latch is held, as the child might need to split or merge, which would require modifying the parent.</li>
</ul>
</li>
<li><strong><code>Context</code> Struct</strong>: This process is managed by a <code>Context</code> struct that holds the stack of write guards (<code>write_set</code>) for the current traversal path. Releasing ancestor latches is as simple as clearing this stack.</li>
</ul>
<pre><code>Latch Crabbing on Insert:
1. Latch(Root)
2. Descend to Child C1. Latch(C1).
3. Check if C1 is safe (not full).
   IF SAFE:
     ReleaseLatch(Root). Path is now just {C1}.
   IF UNSAFE (full):
     Keep Latch(Root). Path is {Root, C1}.
4. Descend from C1 to C2. Latch(C2).
5. Check if C2 is safe... and so on.
</code></pre>
<h3 id="23-deadlock-avoidance"><a class="header" href="#23-deadlock-avoidance">2.3 Deadlock Avoidance</a></h3>
<p>When modifying siblings (during merge or redistribution), deadlocks are possible if two threads try to acquire latches on the same two pages in opposite orders. This is prevented by enforcing a strict <strong>PageId-ordered locking</strong> protocol. When two sibling pages must be latched, the page with the lower <code>PageId</code> is always latched first.</p>
<h2 id="3-key-algorithms--features"><a class="header" href="#3-key-algorithms--features">3. Key Algorithms &amp; Features</a></h2>
<ul>
<li><strong>Parent-Guided Redirection</strong>: During an insert or delete, after a writer has descended to a leaf, it re-validates its position using the parent (if a latch is still held). If a concurrent split has moved the target key range to a different sibling, the writer can jump directly to the correct page instead of traversing the leaf chain, preventing race conditions.</li>
<li><strong>Iterator</strong>: The iterator performs a forward scan by following the leaf chain (<code>next_page_id</code>). It uses a lightweight form of OLC, checking the leaf page version to detect concurrent modifications and restart if necessary to ensure it doesn't miss keys.
<ul>
<li>Sequential Scan Optimization (RingBuffer): For large range scans, the iterator switches to a "synchronous batch fetch + local ring buffer" mode. It fills a small <code>RingBuffer&lt;BytesMut&gt;</code> with consecutive leaf pages (by following <code>next_page_id</code>) and then decodes KVs locally without holding page guards for long. This reduces buffer pool pollution and syscall/lock overhead.</li>
<li>Two Iteration Modes:
<ul>
<li>Guard Mode: Keep a <code>ReadPageGuard</code> and decode per step; prefetch next leaf best-effort.</li>
<li>Bytes Mode: After switching, decode from <code>BytesMut</code> buffers in the local ring; when a leaf is exhausted, pop next bytes from the ring or refill by following the chain.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Prefix Compression</strong>: Keys in internal nodes are prefix-compressed to save space. Each key is stored as <code>(lcp, suffix_len, suffix)</code>. This reduces the size of internal pages, increasing the tree's fanout and reducing its height, which improves cache performance and reduces I/O.</li>
<li><strong>Split/Merge Safety</strong>:
<ul>
<li><strong>Split</strong>: When a node splits, the new right sibling is written first. Then, the B-link pointer and separator key are published atomically by updating the left sibling and parent. This ensures readers can always navigate the structure correctly.</li>
<li><strong>Merge/Redistribute</strong>: When a node is underfull, the implementation first tries to borrow an entry from a sibling (redistribute). If both siblings are at minimum size, it merges with a sibling. All these operations carefully maintain the B-link chain and parent pointers.</li>
</ul>
</li>
</ul>
<h2 id="4-benchmarks--performance"><a class="header" href="#4-benchmarks--performance">4. Benchmarks &amp; Performance</a></h2>
<h3 id="41-example-range-scan-benchmark"><a class="header" href="#41-example-range-scan-benchmark">4.1 Example: Range Scan Benchmark</a></h3>
<p>This benchmark measures the efficiency of the leaf-chain traversal, which is critical for <code>SELECT</code> queries with <code>WHERE</code> clauses on indexed columns. It benefits from iterator prefetching and prefix compression.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pseudo-code for a range scan benchmark
use std::time::Instant;

fn benchmark_range_scan(index: Arc&lt;BPlusTreeIndex&gt;, num_keys: i64, num_passes: usize) {
    // 1. Populate the index with sequential keys
    for key in 1..=num_keys {
        let tuple = create_tuple_from_key(key, index.key_schema.clone());
        index.insert(&amp;tuple, create_rid_from_key(key)).unwrap();
    }

    // 2. Run the benchmark
    let start = Instant::now();
    let mut count = 0;
    for _ in 0..num_passes {
        // Create an iterator over the full key range
        let mut iter = TreeIndexIterator::new(index.clone(), ..);
        while let Some(_) = iter.next().unwrap() {
            count += 1;
        }
    }
    let elapsed = start.elapsed();
    let total_items_scanned = num_keys as usize * num_passes;
    let items_per_sec = total_items_scanned as f64 / elapsed.as_secs_f64();

    println!(
        "Range Scan: Scanned {} items in {:?}. Throughput: {:.2} items/sec",
        total_items_scanned, elapsed, items_per_sec
    );
}
<span class="boring">}</span></code></pre></pre>
<h3 id="42-performance-notes"><a class="header" href="#42-performance-notes">4.2 Performance Notes</a></h3>
<ul>
<li><strong>Hot Reads</strong>: Performance on hot-spot reads depends on keeping upper levels and hot leaves resident in the buffer pool. Warm up the cache for read-heavy benchmarks. Protect hot pages from pollution by enabling TinyLFU admission.</li>
<li><strong>Large Range Scans</strong>: Prefer table SeqScan with ring buffer (bypass) when scanning most of the table. For index scans over very large ranges, consider future Bitmap Heap Scan rather than bypassing the pool for leaves.</li>
</ul>
<h3 id="43-configuration"><a class="header" href="#43-configuration">4.3 Configuration</a></h3>
<ul>
<li><code>config::BTreeConfig</code> controls iterator behavior:
<ul>
<li><code>seq_batch_enable</code> (bool): enable batch mode with local ring buffer.</li>
<li><code>seq_window</code> (usize): number of leaf pages to prefill into the ring per refill.</li>
<li><code>prefetch_enable</code>/<code>prefetch_window</code>: guard-mode prefetch hints to buffer pool.
Defaults are conservative; increase <code>seq_window</code> for long scans to reduce I/O hop.</li>
</ul>
</li>
</ul>
<h2 id="5-future-work"><a class="header" href="#5-future-work">5. Future Work</a></h2>
<ul>
<li>Stronger OLC with bounded retries and telemetry.</li>
<li>CSB+-like internal layout and columnar key prefixing.</li>
<li>NUMA-aware partitioning and router.</li>
<li>WAL/MVCC for crash recovery and snapshot isolation.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recovery-manager-wal"><a class="header" href="#recovery-manager-wal">Recovery Manager (WAL)</a></h1>
<p>The Recovery Manager is the component that ensures the <strong>Durability</strong> aspect of ACID. It guarantees that once a transaction is committed, its effects are permanent, even in the face of system crashes or power failures.</p>
<p>This is achieved through a <strong>Write-Ahead Log (WAL)</strong> and a recovery protocol inspired by <strong>ARIES</strong>.</p>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<ul>
<li>
<p><strong>Write-Ahead Logging</strong>: The fundamental principle is that any change to a data page must be recorded in a log file on durable storage <em>before</em> the data page itself is written back to disk.</p>
</li>
<li>
<p><strong>Log Records</strong>: The WAL is a sequence of records, each with a unique Log Sequence Number (LSN). Records describe changes (<code>PageDelta</code>, <code>HeapInsert</code>), transaction outcomes (<code>Commit</code>, <code>Abort</code>), or internal state (<code>Checkpoint</code>).</p>
</li>
<li>
<p><strong>ARIES Protocol</strong>: On startup, the database replays the log to restore a consistent state. This involves three phases: <strong>Analysis</strong> (to figure out what was happening during the crash), <strong>Redo</strong> (to re-apply all changes since the last checkpoint), and <strong>Undo</strong> (to roll back any transactions that did not commit).</p>
</li>
</ul>
<p>This section contains:</p>
<ul>
<li><strong><a href="modules/./../recovery/aries.html">The ARIES Protocol in QuillSQL</a></strong>: A deep dive into the three phases of recovery and how they are implemented.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-aries-recovery-protocol"><a class="header" href="#the-aries-recovery-protocol">The ARIES Recovery Protocol</a></h1>
<p>Of the four ACID properties, <strong>Durability</strong> is the one that guarantees that once a transaction is committed, its changes will survive any subsequent system failure. In a disk-based database, this is achieved through a careful and robust recovery protocol. QuillSQL implements a recovery strategy inspired by the well-known <strong>ARIES</strong> (Algorithm for Recovery and Isolation Exploiting Semantics) protocol, centered around a <strong>Write-Ahead Log (WAL)</strong>.</p>
<h2 id="1-the-write-ahead-logging-wal-principle"><a class="header" href="#1-the-write-ahead-logging-wal-principle">1. The Write-Ahead Logging (WAL) Principle</a></h2>
<p>The fundamental rule of WAL is simple but powerful:</p>
<blockquote>
<p><strong>Before a modified data page is ever written from memory back to disk, the log record describing that modification must first be written to durable storage (the log file).</strong></p>
</blockquote>
<p>This allows the database to perform most of its data modifications in memory on the <a href="recovery/../modules/buffer.html">Buffer Pool</a> without needing to synchronously write every changed page to disk, which would be extremely slow. In case of a crash, the database can use the log to reconstruct the state of the system and ensure all committed changes are present and all uncommitted changes are undone.</p>
<h3 id="log-records-walrecord"><a class="header" href="#log-records-walrecord">Log Records (<code>WalRecord</code>)</a></h3>
<p>The WAL is a sequential, append-only file composed of <strong>log records</strong>. Each record is assigned a unique, monotonically increasing <strong>Log Sequence Number (LSN)</strong>. A log record in QuillSQL (<code>src/recovery/wal_record.rs</code>) generally contains:</p>
<ul>
<li><strong>LSN</strong>: The address of the log record.</li>
<li><strong>Transaction ID</strong>: The ID of the transaction that generated this record.</li>
<li><strong>Payload</strong>: The actual content of the log record, which varies by type.</li>
</ul>
<p>QuillSQL uses several types of log records:</p>
<ul>
<li><strong><code>Transaction</code></strong>: Marks the <code>BEGIN</code>, <code>COMMIT</code>, or <code>ABORT</code> of a transaction.</li>
<li><strong><code>PageWrite</code> / <code>PageDelta</code></strong>: Physical/Physiological records describing a change to a page. <code>PageWrite</code> contains a full image of the page (used for the first write after a checkpoint, a technique called First-Page-Write or FPW), while <code>PageDelta</code> contains only the changed bytes.</li>
<li><strong><code>HeapInsert</code> / <code>HeapUpdate</code> / <code>HeapDelete</code></strong>: Logical records describing a high-level heap operation. These are primarily used for generating precise undo operations.</li>
<li><strong><code>Checkpoint</code></strong>: A special record that marks a point of partial durability, allowing the log to be truncated.</li>
<li><strong><code>CLR</code> (Compensation Log Record)</strong>: A special record written during recovery to describe an <strong>undo</strong> action. CLRs are redo-only and are never undone themselves.</li>
</ul>
<h2 id="2-the-aries-recovery-protocol"><a class="header" href="#2-the-aries-recovery-protocol">2. The ARIES Recovery Protocol</a></h2>
<p>On database startup, the <code>RecoveryManager</code> (<code>recovery/recovery_manager.rs</code>) is invoked to <code>replay()</code> the WAL. This process follows the three phases of ARIES.</p>
<h3 id="phase-1-analysis"><a class="header" href="#phase-1-analysis">Phase 1: Analysis</a></h3>
<p>The goal of the Analysis phase (<code>recovery/analysis.rs</code>) is to figure out the state of the database at the exact moment of the crash.</p>
<ol>
<li>It starts by finding the last successful <code>Checkpoint</code> record in the WAL.</li>
<li>It then scans the log <strong>forward</strong> from that checkpoint to the end of the log.</li>
<li>During this scan, it builds two critical data structures:
<ul>
<li><strong>Active Transaction Table (ATT)</strong>: A list of all transactions that have a <code>BEGIN</code> record but no corresponding <code>COMMIT</code> or <code>ABORT</code> record. These are the potential "loser" transactions that will need to be undone.</li>
<li><strong>Dirty Page Table (DPT)</strong>: A list of all pages that were modified in the buffer pool but might not have been written to disk before the crash. For each dirty page, it records the LSN of the <em>first</em> log record that made it dirty (this is called the <code>recLSN</code>).</li>
</ul>
</li>
</ol>
<p>At the end of this phase, the <code>RecoveryManager</code> knows exactly which transactions to roll back and the earliest point in the log from which it needs to start re-applying changes.</p>
<h3 id="phase-2-redo-repeating-history"><a class="header" href="#phase-2-redo-repeating-history">Phase 2: Redo (Repeating History)</a></h3>
<p>The goal of the Redo phase (<code>recovery/redo.rs</code>) is to restore the database to its exact state at the moment of the crash, including all changes from both committed and uncommitted (loser) transactions.</p>
<ol>
<li>The Redo phase finds the smallest <code>recLSN</code> from the Dirty Page Table built during Analysis. This LSN is the starting point for the redo scan.</li>
<li>It scans the log <strong>forward</strong> from this starting point.</li>
<li>For every log record it encounters that describes a physical change to a page (e.g., <code>PageWrite</code>, <code>PageDelta</code>, <code>Heap*</code>), it re-applies the change. This is idempotent: if the change is already present on the page (because it was successfully flushed to disk before the crash), re-applying it does no harm.</li>
</ol>
<p>At the end of this phase, the database state on disk is identical to how it was in memory right before the crash.</p>
<h3 id="phase-3-undo-rolling-back-losers"><a class="header" href="#phase-3-undo-rolling-back-losers">Phase 3: Undo (Rolling Back Losers)</a></h3>
<p>The final phase (<code>recovery/undo.rs</code>) is responsible for rolling back all the "loser" transactions identified during Analysis.</p>
<ol>
<li>The <code>UndoExecutor</code> takes the list of loser transactions.</li>
<li>For each loser transaction, it scans the WAL <strong>backwards</strong>, following the chain of log records for that transaction.</li>
<li>For each operation record (like <code>HeapInsert</code>, <code>HeapUpdate</code>), it performs the logical inverse operation:
<ul>
<li>To undo an <code>Insert</code>, it performs a <code>Delete</code>.</li>
<li>To undo a <code>Delete</code>, it restores the deleted data.</li>
<li>To undo an <code>Update</code>, it restores the data from before the update.</li>
</ul>
</li>
<li><strong>Crucially</strong>, for every undo action it performs, it writes a <strong>Compensation Log Record (CLR)</strong> to the WAL. The CLR contains information about the undo action and, importantly, a pointer to the <em>next</em> log record that needs to be undone for that transaction.</li>
</ol>
<p>This use of CLRs makes the recovery process itself crash-proof. If the system crashes <em>during the undo phase</em>, the next time recovery runs, it will see the CLRs. It will simply continue the undo process from where it left off by following the pointers in the CLRs, without ever having to undo an undo action.</p>
<h2 id="3-checkpoints"><a class="header" href="#3-checkpoints">3. Checkpoints</a></h2>
<p>If the log were allowed to grow forever, recovery would become slower and slower. <strong>Checkpoints</strong> are a background process that periodically creates a point of partial durability.</p>
<p>A checkpoint does the following:</p>
<ol>
<li>Temporarily stops new transactions from starting.</li>
<li>Writes a <code>BEGIN_CHECKPOINT</code> record to the WAL, containing the current ATT and DPT.</li>
<li>Flushes all dirty pages from the buffer pool to disk.</li>
<li>Writes an <code>END_CHECKPOINT</code> record to the WAL.</li>
</ol>
<p>Once a checkpoint is complete, the <code>RecoveryManager</code> knows that all changes described in log records before the <code>BEGIN_CHECKPOINT</code> record are safely on disk. Therefore, those older parts of the WAL file are no longer needed for recovery and can be truncated or recycled, keeping the recovery process efficient.</p>
<hr />
<h2 id="for-study--discussion-3"><a class="header" href="#for-study--discussion-3">For Study &amp; Discussion</a></h2>
<ol>
<li>
<p><strong>Repeating History</strong>: The Redo phase re-applies changes from <em>all</em> transactions, including those that will be undone later (the "losers"). This seems wasteful. Why is this "repeating history" approach a core principle of ARIES? What would go wrong if we tried to only redo changes from committed transactions?</p>
</li>
<li>
<p><strong>Compensation Log Records (CLRs)</strong>: What specific problem would occur if the system crashed during the Undo phase and we <em>didn't</em> write CLRs? How does a CLR's "redo-only" nature make the recovery process idempotent and robust against repeated crashes?</p>
</li>
<li>
<p><strong>Checkpointing Frequency</strong>: What are the performance trade-offs between checkpointing very frequently versus very infrequently? Consider both normal runtime performance and the time it takes to recover after a crash.</p>
</li>
<li>
<p><strong>Programming Exercise</strong>: Add a new WAL record type. For example, a <code>HeapReclaim</code> record that logs the physical removal of a dead tuple by a vacuum process. To do this, you would need to:
a.  Add a variant to the <code>HeapRecordPayload</code> enum in <code>wal_record.rs</code>.
b.  Update the <code>codec</code> functions to handle its serialization.
c.  Decide what information the <code>HeapReclaim</code> record needs to contain.
d.  Implement the <code>redo</code> logic for this new record in the appropriate <code>ResourceManager</code>. What should happen when you redo a <code>HeapReclaim</code> record?</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-manager"><a class="header" href="#transaction-manager">Transaction Manager</a></h1>
<p>The Transaction Manager is responsible for one of the most critical aspects of a database: guaranteeing the <strong>ACID</strong> properties, specifically <strong>Isolation</strong> and <strong>Atomicity</strong>.</p>
<p>It allows multiple clients to access the database concurrently without interfering with each other, and it ensures that transactions are treated as single, indivisible operations (all or nothing).</p>
<h2 id="core-concepts-1"><a class="header" href="#core-concepts-1">Core Concepts</a></h2>
<ul>
<li>
<p><strong>Concurrency Control</strong>: To handle simultaneous operations, QuillSQL uses a hybrid approach that combines two powerful techniques:</p>
<ol>
<li><strong>Multi-Version Concurrency Control (MVCC)</strong>: Instead of overwriting data, writers create new <em>versions</em> of rows. Readers are given a consistent <em>snapshot</em> of the database, which allows them to proceed without being blocked by writers.</li>
<li><strong>Two-Phase Locking (2PL)</strong>: To prevent two writers from modifying the same row at the same time, a strict two-phase locking protocol is used. Transactions must acquire locks on data before modifying it and hold those locks until the transaction ends.</li>
</ol>
</li>
<li>
<p><strong>Atomicity</strong>: The transaction manager records all actions performed by a transaction. If the transaction needs to be aborted, it can use this record to perform the necessary undo operations, rolling the database back to its state before the transaction began.</p>
</li>
</ul>
<p>This section contains:</p>
<ul>
<li><strong><a href="modules/./../transaction/mvcc_and_2pl.html">MVCC and 2PL</a></strong>: A deep dive into QuillSQL's hybrid concurrency control model.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mvcc-and-2pl"><a class="header" href="#mvcc-and-2pl">MVCC and 2PL</a></h1>
<p>Of the four ACID properties, <strong>Isolation</strong> is often the most complex to implement. It ensures that concurrent transactions do not interfere with each other, making it appear as if each transaction is executing sequentially, one after another. Without proper isolation, a database would suffer from concurrency-related anomalies like dirty reads, non-repeatable reads, and phantom reads.</p>
<p>Databases typically use two main strategies for concurrency control:</p>
<ol>
<li><strong>Pessimistic Concurrency Control</strong>: Assumes conflicts are likely and prevents them from happening by using locks. The most common protocol is <strong>Two-Phase Locking (2PL)</strong>.</li>
<li><strong>Optimistic Concurrency Control</strong>: Assumes conflicts are rare. Transactions proceed without locking, and the database validates at commit time that no conflicts occurred. A popular variant is <strong>Multi-Version Concurrency Control (MVCC)</strong>.</li>
</ol>
<p>QuillSQL, like many modern relational databases (e.g., PostgreSQL, Oracle), implements a powerful <strong>hybrid model that combines MVCC with 2PL</strong>.</p>
<h2 id="1-mvcc-reading-without-blocking"><a class="header" href="#1-mvcc-reading-without-blocking">1. MVCC: Reading without Blocking</a></h2>
<p>The core idea of MVCC is <strong>"writers don't block readers, and readers don't block writers."</strong> This is achieved by never overwriting data in-place. When a row is updated, the database creates a <em>new version</em> of that row, preserving the old one.</p>
<h3 id="version-chains-and-tuplemeta"><a class="header" href="#version-chains-and-tuplemeta">Version Chains and <code>TupleMeta</code></a></h3>
<p>As discussed in the <a href="transaction/../storage/table_heap.html">Storage Engine</a> chapter, every tuple on disk has associated metadata (<code>TupleMeta</code>) that includes:</p>
<ul>
<li><code>insert_txn_id</code>: The ID of the transaction that created this version.</li>
<li><code>delete_txn_id</code>: The ID of the transaction that marked this version as deleted.</li>
<li><code>prev_version</code> / <code>next_version</code>: Pointers (RIDs) that form a linked list of versions for a single logical row, called the <strong>version chain</strong>.</li>
</ul>
<h3 id="transaction-snapshots"><a class="header" href="#transaction-snapshots">Transaction Snapshots</a></h3>
<p>When a transaction begins, it asks the <code>TransactionManager</code> for a <strong>snapshot</strong> of the database state. This snapshot, defined in <code>transaction/mvcc.rs</code>, contains three key pieces of information:</p>
<ul>
<li><code>xmin</code>: The oldest active transaction ID at the time of the snapshot. Any transaction with an ID less than <code>xmin</code> is guaranteed to be either committed or aborted.</li>
<li><code>xmax</code>: The next transaction ID to be assigned. Any transaction with an ID greater than or equal to <code>xmax</code> was not yet started when the snapshot was taken.</li>
<li><code>active_txns</code>: A list of all other transaction IDs that were active when the snapshot was taken.</li>
</ul>
<h3 id="the-visibility-check"><a class="header" href="#the-visibility-check">The Visibility Check</a></h3>
<p>When a transaction scans the database, for every tuple version it encounters, it performs a <strong>visibility check</strong> using its snapshot. The logic in <code>MvccSnapshot::is_visible</code> determines if the version should be "seen" by the current transaction. In simplified terms, a tuple version is visible if:</p>
<ol>
<li>Its <code>insert_txn_id</code> belongs to a transaction that was already committed before our snapshot was taken.</li>
<li><strong>AND</strong> its <code>delete_txn_id</code> is either not set, OR it belongs to a transaction that was not yet committed when our snapshot was taken.</li>
</ol>
<p>This mechanism elegantly solves several concurrency problems. Since a reader transaction only ever sees a consistent snapshot of the database, it is completely immune to changes being made by other concurrent writer transactions. This prevents dirty reads and non-repeatable reads.</p>
<h2 id="2-two-phase-locking-2pl-preventing-write-write-conflicts"><a class="header" href="#2-two-phase-locking-2pl-preventing-write-write-conflicts">2. Two-Phase Locking (2PL): Preventing Write-Write Conflicts</a></h2>
<p>While MVCC is excellent for read-write conflicts, it does not, by itself, prevent two transactions from trying to modify the same logical row at the same time (a write-write conflict). This is where locking comes in.</p>
<p>QuillSQL implements a strict <strong>Two-Phase Locking</strong> protocol via the <code>LockManager</code> (<code>transaction/lock_manager.rs</code>).</p>
<h3 id="the-two-phases"><a class="header" href="#the-two-phases">The Two Phases</a></h3>
<ol>
<li><strong>Growing Phase</strong>: The transaction can acquire new locks as it executes.</li>
<li><strong>Shrinking Phase</strong>: Once the transaction releases its first lock, it cannot acquire any new locks.</li>
</ol>
<p>In practice, QuillSQL uses <strong>Strict 2PL</strong>, where the shrinking phase is delayed until the transaction commits or aborts. All locks are held until the very end.</p>
<h3 id="hierarchical-locking-intention-locks"><a class="header" href="#hierarchical-locking-intention-locks">Hierarchical Locking (Intention Locks)</a></h3>
<p>To be efficient, the <code>LockManager</code> uses a multi-granularity, hierarchical locking scheme. Before a transaction can take a fine-grained lock on a row (a <code>Shared</code> or <code>Exclusive</code> lock), it must first acquire a coarser-grained <strong>intention lock</strong> on the table.</p>
<ul>
<li><strong><code>IntentionShared (IS)</code></strong>: Signals the intent to read rows from the table.</li>
<li><strong><code>IntentionExclusive (IX)</code></strong>: Signals the intent to modify rows in the table.</li>
</ul>
<p>This prevents a transaction wanting to lock the entire table from conflicting with another transaction that is already modifying a single row. For example, a <code>SELECT * FROM users FOR UPDATE</code> (which needs an <code>X</code> lock on the table) will be blocked if another transaction already holds an <code>IX</code> lock on <code>users</code>.</p>
<h3 id="deadlock-detection"><a class="header" href="#deadlock-detection">Deadlock Detection</a></h3>
<p>When two or more transactions are waiting for each other to release locks in a circular chain, a <strong>deadlock</strong> occurs. The <code>LockManager</code> detects this by building a <strong>waits-for graph</strong>. When a transaction <code>T1</code> has to wait for a lock held by <code>T2</code>, an edge <code>T1 -&gt; T2</code> is added to the graph. If adding an edge creates a cycle, a deadlock is detected, and one of the transactions (the victim) is immediately aborted to break the cycle.</p>
<h2 id="3-the-hybrid-model-mvcc--2pl-in-action"><a class="header" href="#3-the-hybrid-model-mvcc--2pl-in-action">3. The Hybrid Model: MVCC + 2PL in Action</a></h2>
<p>In QuillSQL, these two mechanisms work in concert:</p>
<ul>
<li>
<p>A <strong>reader</strong> (<code>SELECT</code>) transaction acquires an MVCC snapshot. It uses this snapshot to determine visibility. It only needs to acquire <code>Shared</code> (S) locks on the rows it reads to prevent other transactions from modifying them, thus ensuring repeatable reads in higher isolation levels.</p>
</li>
<li>
<p>A <strong>writer</strong> (<code>UPDATE</code>, <code>DELETE</code>) transaction must acquire an <code>Exclusive</code> (X) lock on the specific row it intends to modify. Once the lock is granted, it knows no other writer can interfere. It can then safely create a new tuple version as part of the MVCC protocol.</p>
</li>
</ul>
<p>This hybrid approach provides the best of both worlds: reads are fast and non-blocking, while write-write conflicts are safely prevented by the locking protocol.</p>
<hr />
<h2 id="for-study--discussion-4"><a class="header" href="#for-study--discussion-4">For Study &amp; Discussion</a></h2>
<ol>
<li>
<p><strong>Isolation Levels</strong>: QuillSQL supports multiple SQL isolation levels. How does the behavior of MVCC snapshots and 2PL change between <code>ReadCommitted</code> and <code>RepeatableRead</code>? In <code>ReadCommitted</code>, a transaction gets a new snapshot for every statement, whereas in <code>RepeatableRead</code>, it uses the same snapshot for the entire transaction. What concurrency anomalies does this difference prevent?</p>
</li>
<li>
<p><strong>Phantom Reads</strong>: Even with MVCC and row-level 2PL, a <code>RepeatableRead</code> transaction can suffer from <em>phantom reads</em>. Imagine <code>T1</code> runs <code>SELECT COUNT(*) FROM users WHERE age &gt; 30</code>. Then, <code>T2</code> inserts a new user with <code>age = 40</code> and commits. If <code>T1</code> runs its <code>SELECT</code> query again, it will see a new "phantom" row that wasn't there before. How can a database prevent this to achieve the <code>Serializable</code> isolation level? (Hint: research predicate locking and index-range locking).</p>
</li>
<li>
<p><strong>Deadlock Handling</strong>: QuillSQL detects deadlocks by building a waits-for graph and aborting a transaction. What is an alternative strategy for handling deadlocks? For example, what are the pros and cons of using lock timeouts instead of cycle detection?</p>
</li>
<li>
<p><strong>Programming Exercise (Advanced)</strong>: A full implementation of <code>Serializable</code> isolation often requires index-range locking to prevent phantoms. Extend the <code>LockManager</code> to support locking a <em>range</em> of keys within a B+Tree index. This would require a new lock type and a way to check for overlapping ranges. When a <code>SELECT ... WHERE age &gt; 30</code> query runs, it would place a shared lock on the <code>(30, +∞)</code> range in the index on the <code>age</code> column, preventing any other transaction from inserting a new user with an age in that range.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query-plan"><a class="header" href="#query-plan">Query Plan</a></h1>
<p>The Query Planner is the "brain" of the database. It is responsible for taking a declarative SQL query string (which describes <em>what</em> data to retrieve) and converting it into a highly optimized, imperative plan (which describes <em>how</em> to retrieve that data).</p>
<p>This process is one of the most complex and important aspects of a relational database system.</p>
<h2 id="core-concepts-2"><a class="header" href="#core-concepts-2">Core Concepts</a></h2>
<ul>
<li>
<p><strong>AST (Abstract Syntax Tree)</strong>: The raw SQL text is first parsed into a tree structure that represents the syntax of the query.</p>
</li>
<li>
<p><strong>Logical Plan</strong>: The AST is then converted into a logical plan. This is a tree of relational algebra operators (e.g., <code>Filter</code>, <code>Projection</code>, <code>Join</code>) that describes the logical steps required to fulfill the query, independent of any specific algorithm or data layout.</p>
</li>
<li>
<p><strong>Physical Plan</strong>: The logical plan is then converted into a physical plan. This plan consists of concrete operators (or "iterators") that implement specific algorithms (e.g., <code>NestedLoopJoin</code>, <code>SeqScan</code>). This is the plan that is actually executed.</p>
</li>
</ul>
<p>This section contains:</p>
<ul>
<li><strong><a href="modules/./../plan/lifecycle.html">The Lifecycle of a Query</a></strong>: A deep dive into the journey from SQL string to executable physical plan.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-lifecycle-of-a-query"><a class="header" href="#the-lifecycle-of-a-query">The Lifecycle of a Query</a></h1>
<p>When you submit a SQL query to a database, it doesn't just magically produce a result. The database undertakes a sophisticated, multi-stage process to translate the declarative SQL statement (which describes <em>what</em> data you want) into an imperative, efficient execution plan (which describes <em>how</em> to get that data). This entire process is the responsibility of the <strong>Query Planner</strong>.</p>
<p>In QuillSQL, this process follows a classic, compiler-like pipeline, which is a cornerstone of modern database architecture as taught in courses like CMU 15-445.</p>
<p>The journey from a SQL string to an executable plan involves several transformations:</p>
<p><strong>SQL String</strong> -&gt; <strong>AST (Abstract Syntax Tree)</strong> -&gt; <strong>Logical Plan</strong> -&gt; <strong>Optimized Logical Plan</strong> -&gt; <strong>Physical Plan</strong></p>
<p>Let's break down each stage.</p>
<h3 id="stage-1-parsing-sql---ast"><a class="header" href="#stage-1-parsing-sql---ast">Stage 1: Parsing (SQL -&gt; AST)</a></h3>
<p>The first step is purely syntactic. The raw SQL query string is fed into a parser. QuillSQL uses the excellent <code>sqlparser</code> crate for this. The parser checks if the SQL conforms to valid grammar and, if so, converts it into an <strong>Abstract Syntax Tree (AST)</strong>.</p>
<p>An AST is a direct tree representation of the SQL query's structure. For example, <code>SELECT id FROM users WHERE age &gt; 30</code> would be parsed into a tree structure with nodes representing the <code>SELECT</code> clause, the table <code>users</code>, the <code>WHERE</code> clause, and the predicate <code>age &gt; 30</code>.</p>
<h3 id="stage-2-logical-planning-ast---logical-plan"><a class="header" href="#stage-2-logical-planning-ast---logical-plan">Stage 2: Logical Planning (AST -&gt; Logical Plan)</a></h3>
<p>Next, the <code>LogicalPlanner</code> (<code>plan/logical_planner.rs</code>) walks the AST and converts it into a <strong>Logical Plan</strong>.</p>
<p>A Logical Plan is a tree of relational algebra operators. It describes the query in terms of high-level data operations, completely independent of how the data is stored or which algorithms will be used. It defines <em>what</em> to do, not <em>how</em> to do it.</p>
<p>Key logical operators in QuillSQL (<code>plan/logical_plan/mod.rs</code>) include:</p>
<ul>
<li><strong><code>TableScan(users)</code></strong>: Represents reading the entire <code>users</code> table.</li>
<li><strong><code>Filter(predicate: age &gt; 30)</code></strong>: Represents filtering rows based on a condition.</li>
<li><strong><code>Projection(columns: [id])</code></strong>: Represents selecting specific columns.</li>
<li><strong><code>Join</code></strong>: Represents joining two data sources.</li>
<li><strong><code>Aggregate</code></strong>: Represents a <code>GROUP BY</code> operation.</li>
<li><strong><code>Sort</code></strong>: Represents an <code>ORDER BY</code> operation.</li>
</ul>
<p>For our example query, the initial logical plan might look like this:</p>
<pre><code>Projection(columns=[id])
  └── Filter(predicate=age &gt; 30)
        └── TableScan(users)
</code></pre>
<h3 id="stage-3-logical-optimization"><a class="header" href="#stage-3-logical-optimization">Stage 3: Logical Optimization</a></h3>
<p>Before executing the plan, we have a crucial opportunity to make it more efficient. The <code>LogicalOptimizer</code> (<code>optimizer/logical_optimizer.rs</code>) takes the logical plan and applies a series of <strong>transformation rules</strong> to produce a new, equivalent logical plan that is expected to be faster.</p>
<p>QuillSQL uses a simple but effective rule-based optimizer. A classic example of such a rule is <strong>Predicate Pushdown</strong>. Consider this query:</p>
<p><code>SELECT name FROM (SELECT * FROM users JOIN cities ON users.city_id = cities.id) WHERE users.age &gt; 30;</code></p>
<p>A naive logical plan would first perform a full <code>JOIN</code> between <code>users</code> and <code>cities</code> and <em>then</em> filter the massive result. Predicate pushdown is a rule that would rewrite the plan to apply the <code>age &gt; 30</code> filter <em>before</em> the join:</p>
<p><strong>Before Optimization:</strong></p>
<pre><code>Filter(users.age &gt; 30)
  └── Join(users.city_id = cities.id)
        ├── TableScan(users)
        └── TableScan(cities)
</code></pre>
<p><strong>After Optimization (Predicate Pushdown):</strong></p>
<pre><code>Join(users.city_id = cities.id)
  ├── Filter(users.age &gt; 30)
  │     └── TableScan(users)
  └── TableScan(cities)
</code></pre>
<p>By filtering early, we dramatically reduce the number of rows that need to be processed by the expensive <code>Join</code> operator. QuillSQL implements similar rules, such as <code>PushDownLimit</code>, which pushes <code>LIMIT</code> clauses down the tree to reduce the amount of data processed.</p>
<h3 id="stage-4-physical-planning-logical-plan---physical-plan"><a class="header" href="#stage-4-physical-planning-logical-plan---physical-plan">Stage 4: Physical Planning (Logical Plan -&gt; Physical Plan)</a></h3>
<p>Finally, the <code>PhysicalPlanner</code> (<code>plan/physical_planner.rs</code>) converts the optimized logical plan into a <strong>Physical Plan</strong>.</p>
<p>A Physical Plan describes exactly <em>how</em> the query will be executed. It maps each logical operator to a concrete algorithm or implementation.</p>
<ul>
<li>A <code>LogicalPlan::TableScan</code> becomes a <code>PhysicalSeqScan</code> (a sequential scan of the table heap).</li>
<li>A <code>LogicalPlan::Filter</code> becomes a <code>PhysicalFilter</code>, which implements the filtering logic.</li>
<li>A <code>LogicalPlan::Join</code> becomes a <code>PhysicalNestedLoopJoin</code>. This is where the database commits to a specific join algorithm. A more advanced database might have multiple options (e.g., <code>PhysicalHashJoin</code>, <code>PhysicalSortMergeJoin</code>) and would use a cost model to choose the best one. QuillSQL currently implements Nested Loop Join.</li>
</ul>
<p>Each node in the physical plan tree is an executor that the <a href="plan/../modules/execution.html">Execution Engine</a> can run. This final plan is what gets executed to produce the query result.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This layered approach—from syntax to a logical representation, then to an optimized logical representation, and finally to a concrete physical execution plan—is fundamental to database design. It provides a clear separation of concerns and, most importantly, creates a dedicated <strong>optimization stage</strong>, which is the key to achieving high performance on a wide variety of SQL queries.</p>
<hr />
<h2 id="for-study--discussion-5"><a class="header" href="#for-study--discussion-5">For Study &amp; Discussion</a></h2>
<ol>
<li>
<p><strong>Logical vs. Physical</strong>: Why is the separation between logical and physical plans so important? What would be the disadvantages of a simpler system that converted the AST directly into a physical plan?</p>
</li>
<li>
<p><strong>Join Algorithms</strong>: QuillSQL currently only implements <code>NestedLoopJoin</code>. What are two other common join algorithms? Describe how they work and in what scenarios they would be more performant than a nested loop join.</p>
</li>
<li>
<p><strong>Programming Exercise (Advanced)</strong>: Implement a <code>PhysicalHashJoin</code> operator. This is a significant undertaking that involves:
a.  Creating a <code>PhysicalHashJoin</code> struct that implements the <code>VolcanoExecutor</code> trait.
b.  In the <code>init()</code> phase, it should consume the entire "build" side (typically the smaller, right-hand table) and build an in-memory hash table from its rows.
c.  In the <code>next()</code> phase, it should read from the "probe" side (the left-hand table) one row at a time, probe the hash table for matches, and emit the joined tuples.
d.  Modify the <code>PhysicalPlanner</code> to choose <code>PhysicalHashJoin</code> instead of <code>PhysicalNestedLoopJoin</code> for equi-joins.</p>
</li>
<li>
<p><strong>Programming Exercise</strong>: Add support for the <code>UNION ALL</code> operator. This would involve:
a.  Adding a <code>Union</code> variant to the <code>LogicalPlan</code> enum.
b.  Updating the <code>LogicalPlanner</code> to recognize the <code>UNION</code> syntax in the AST and create a <code>LogicalPlan::Union</code> node.
c.  Creating a <code>PhysicalUnion</code> executor that pulls tuples from its first child until it's exhausted, and then pulls tuples from its second child.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query-optimizer"><a class="header" href="#query-optimizer">Query Optimizer</a></h1>
<p>A naive, direct translation of a SQL query into an execution plan is often dramatically inefficient. The <strong>Query Optimizer</strong> is a critical stage in the query processing pipeline that rearranges and transforms the initial logical plan into an equivalent, but far cheaper, plan to execute.</p>
<h2 id="core-concepts-3"><a class="header" href="#core-concepts-3">Core Concepts</a></h2>
<ul>
<li>
<p><strong>Rule-Based Optimization</strong>: QuillSQL uses a rule-based optimizer. It applies a series of pre-defined, heuristic rules to the logical plan to improve it. This is in contrast to a cost-based optimizer, which would estimate the "cost" of many possible plans and choose the cheapest one.</p>
</li>
<li>
<p><strong>Logical Transformations</strong>: The key insight is that many different logical plans can produce the exact same result. For example, filtering data before a join is usually much faster than joining two large tables and filtering the result, but the final output is identical. The optimizer's job is to find and apply these beneficial transformations.</p>
</li>
</ul>
<p>This section contains:</p>
<ul>
<li><strong><a href="modules/./../optimizer/rules.html">Rule-Based Optimization</a></strong>: A deep dive into how the rule-based optimizer works, using the <code>PushDownLimit</code> rule as a concrete example.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rule-based-optimization"><a class="header" href="#rule-based-optimization">Rule-Based Optimization</a></h1>
<p>After the <code>LogicalPlanner</code> creates an initial <code>LogicalPlan</code>, it's passed to the <strong><code>LogicalOptimizer</code></strong>. The initial plan is a direct, syntactically correct translation of the SQL query, but it's often not the most efficient way to execute it. The optimizer's job is to transform this plan into an equivalent, but more performant, logical plan.</p>
<h2 id="the-optimizer-in-quillsql"><a class="header" href="#the-optimizer-in-quillsql">The Optimizer in QuillSQL</a></h2>
<p>QuillSQL implements a <strong>Rule-Based Optimizer</strong>. This is a common and powerful approach where the optimizer is equipped with a set of predefined transformation rules. It repeatedly applies these rules to the logical plan tree until no more rules can be applied, or a maximum number of passes is reached.</p>
<p>The main components are:</p>
<ul>
<li><strong><code>LogicalOptimizer</code> (<code>optimizer/logical_optimizer.rs</code>)</strong>: The main driver. It holds a list of rules and contains the logic to recursively walk the plan tree and apply them.</li>
<li><strong><code>LogicalOptimizerRule</code> Trait</strong>: An interface that every optimization rule must implement. Its core method is <code>try_optimize</code>, which takes a plan node and attempts to return a rewritten, optimized version of that node.</li>
</ul>
<h2 id="deep-dive-the-pushdownlimit-rule"><a class="header" href="#deep-dive-the-pushdownlimit-rule">Deep Dive: The <code>PushDownLimit</code> Rule</a></h2>
<p>One of the most classic and effective optimizations is "pushing down" operations as far as possible towards the data source. Let's examine the <code>PushDownLimit</code> rule (<code>optimizer/rule/push_down_limit.rs</code>) to see this in action.</p>
<p>Consider the following query:</p>
<pre><code class="language-sql">SELECT * FROM users ORDER BY signup_date LIMIT 10;
</code></pre>
<h4 id="the-naive-plan"><a class="header" href="#the-naive-plan">The Naive Plan</a></h4>
<p>A naive logical plan for this query would be:</p>
<pre><code>Limit(10)
  └── Sort(by: signup_date)
        └── TableScan(users)
</code></pre>
<p>If executed directly, this plan would:</p>
<ol>
<li>Scan the <em>entire</em> <code>users</code> table.</li>
<li>Sort the <em>entire</em> table by <code>signup_date</code>.</li>
<li>Finally, discard all but the first 10 rows.</li>
</ol>
<p>This is incredibly inefficient, especially for a large table, as it involves a massive, memory-intensive sort operation.</p>
<h4 id="the-optimization-rule"><a class="header" href="#the-optimization-rule">The Optimization Rule</a></h4>
<p>The <code>PushDownLimit</code> rule is designed to recognize this specific pattern: a <code>Limit</code> operator directly on top of a <code>Sort</code> operator.</p>
<p>When the optimizer applies this rule, the <code>try_optimize</code> method matches on the <code>Limit</code> node. It inspects its child and sees that it's a <code>Sort</code> node. The rule then knows it can apply its logic.</p>
<h4 id="the-rewritten-plan"><a class="header" href="#the-rewritten-plan">The Rewritten Plan</a></h4>
<p>The rule rewrites the plan tree by "pushing" the limit information <em>into</em> the <code>Sort</code> node itself:</p>
<pre><code>Limit(10)
  └── Sort(by: signup_date, limit: 10)
        └── TableScan(users)
</code></pre>
<p>Notice the new <code>limit: 10</code> property on the <code>Sort</code> node. This seemingly small change has a huge performance impact. When the <code>PhysicalSort</code> operator is created from this logical node, it now knows that it only needs to find the top 10 rows. Instead of performing a full sort, it can use a much more efficient algorithm, like a <strong>heap sort (using a min-heap of size 10)</strong>, to find the top 10 rows in a single pass over the data.</p>
<p>This optimization avoids sorting the entire table, dramatically reducing both CPU and memory consumption.</p>
<h2 id="other-rules"><a class="header" href="#other-rules">Other Rules</a></h2>
<p>QuillSQL implements other simple but effective rules:</p>
<ul>
<li><strong><code>EliminateLimit</code></strong>: Removes a <code>LIMIT</code> clause if it provides no value (e.g., <code>LIMIT NULL</code>).</li>
<li><strong><code>MergeLimit</code></strong>: If two <code>LIMIT</code> clauses are stacked on top of each other (which can happen after other rule transformations), this rule merges them into a single, more restrictive <code>LIMIT</code>.</li>
</ul>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>While QuillSQL's optimizer is currently rule-based and relatively simple, it demonstrates the fundamental principles of query optimization. By separating the logical representation of a query from its physical execution and applying equivalence-preserving transformations, a database can achieve massive performance gains. More advanced systems build on this with a <strong>Cost-Based Optimizer</strong>, which uses table statistics to estimate the "cost" of different physical plans (e.g., choosing between a <code>NestedLoopJoin</code> and a <code>HashJoin</code>) and pick the cheapest one.</p>
<hr />
<h2 id="for-study--discussion-6"><a class="header" href="#for-study--discussion-6">For Study &amp; Discussion</a></h2>
<ol>
<li>
<p><strong>Rule Ordering</strong>: The <code>LogicalOptimizer</code> applies its list of rules in a fixed order for a set number of passes. Can the order in which rules are applied affect the final, optimized plan? Can one rule's transformation enable another rule to be applied in a subsequent pass?</p>
</li>
<li>
<p><strong>Cost-Based vs. Rule-Based</strong>: What is the primary limitation of a purely rule-based optimizer? When would a rule-based optimizer make a poor decision that a cost-based optimizer (with accurate statistics) would get right? (Hint: consider join algorithm selection).</p>
</li>
<li>
<p><strong>Programming Exercise</strong>: Implement the classic <strong>Predicate Pushdown</strong> rule. Your rule should look for a <code>Filter</code> operator whose child is a <code>Join</code>. If the filter's predicate only uses columns from one side of the join, the rule should push the <code>Filter</code> node down to that side of the join, below the <code>Join</code> node. This is one of the most effective optimizations in any database.</p>
</li>
<li>
<p><strong>Programming Exercise</strong>: Implement a <strong>Constant Folding</strong> rule. This rule would traverse expression trees and pre-compute constant expressions. For example:</p>
<ul>
<li>An expression <code>WHERE age = 10 + 5</code> would be rewritten to <code>WHERE age = 15</code>.</li>
<li>An expression <code>WHERE 1 = 1</code> would be evaluated to <code>true</code>, and a smart optimizer could then potentially eliminate the <code>WHERE</code> clause entirely.</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="execution-engine"><a class="header" href="#execution-engine">Execution Engine</a></h1>
<p>Once a query has been parsed, planned, and optimized, the resulting <code>PhysicalPlan</code> is handed to the <strong>Execution Engine</strong>. This component is the workhorse of the database, responsible for actually running the plan and producing the final results.</p>
<h2 id="core-concepts-4"><a class="header" href="#core-concepts-4">Core Concepts</a></h2>
<ul>
<li>
<p><strong>Volcano (Iterator) Model</strong>: QuillSQL uses a pull-based execution model. Each operator in the physical plan tree is an "iterator" that provides a <code>next()</code> method. The parent operator calls <code>next()</code> on its children to pull rows upwards through the tree, from the storage layer to the client.</p>
</li>
<li>
<p><strong>Physical Operators</strong>: Each logical operation (like a filter or a join) is mapped to a concrete physical operator that implements a specific algorithm (e.g., <code>PhysicalFilter</code>, <code>PhysicalNestedLoopJoin</code>).</p>
</li>
<li>
<p><strong>Execution Context</strong>: As the plan is executed, a shared <code>ExecutionContext</code> is passed between operators. It contains vital information, such as the current transaction and its MVCC snapshot, allowing operators to perform visibility checks and locking.</p>
</li>
</ul>
<p>This section contains:</p>
<ul>
<li><strong><a href="modules/./../execution/volcano.html">The Volcano Execution Model</a></strong>: A deep dive into the pull-based execution model and the lifecycle of a query.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-volcano-execution-model"><a class="header" href="#the-volcano-execution-model">The Volcano Execution Model</a></h1>
<p>Once the <a href="execution/../modules/plan.html">Query Planner</a> has produced an optimized <code>PhysicalPlan</code>, it's the job of the <strong>Execution Engine</strong> to run it and produce results. The execution engine is the component that brings the plan to life, interacting with the transaction manager and storage layer to process data.</p>
<p>QuillSQL uses the classic <strong>Volcano Model</strong>, also known as the <strong>Iterator Model</strong>. This is a pull-based execution model where each physical operator in the plan tree acts as an iterator that the parent operator can "pull" rows from.</p>
<h2 id="1-the-volcanoexecutor-trait"><a class="header" href="#1-the-volcanoexecutor-trait">1. The <code>VolcanoExecutor</code> Trait</a></h2>
<p>At the heart of the execution model is the <code>VolcanoExecutor</code> trait (<code>execution/mod.rs</code>). Every physical operator implements this simple trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait VolcanoExecutor {
    fn init(&amp;self, context: &amp;mut ExecutionContext) -&gt; QuillSQLResult&lt;()&gt;;
    fn next(&amp;self, context: &amp;mut ExecutionContext) -&gt; QuillSQLResult&lt;Option&lt;Tuple&gt;&gt;;
    fn output_schema(&amp;self) -&gt; SchemaRef;
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong><code>init()</code></strong>: This method is called once at the beginning of execution. It allows an operator to set up its initial state (e.g., a <code>SeqScan</code> operator would initialize its table iterator here).</li>
<li><strong><code>next()</code></strong>: This is the core method. When called, the operator produces its next output tuple. It returns <code>Some(tuple)</code> if it has a row, or <code>None</code> if it has exhausted its data source. The top-level <code>ExecutionEngine</code> simply calls <code>next()</code> on the root of the plan tree in a loop until it receives <code>None</code>.</li>
</ul>
<h2 id="2-the-executioncontext"><a class="header" href="#2-the-executioncontext">2. The <code>ExecutionContext</code></a></h2>
<p>Notice that both <code>init()</code> and <code>next()</code> take a mutable <code>ExecutionContext</code>. This object is the "context" or "world" in which the query runs. It is passed down the entire operator tree and gives each operator access to crucial services:</p>
<ul>
<li><strong><code>Catalog</code></strong>: To look up tables and indexes.</li>
<li><strong><code>TransactionManager</code> and <code>Transaction</code></strong>: To interact with the current transaction. This is how operators perform locking and visibility checks.</li>
<li><strong><code>MvccSnapshot</code></strong>: The specific MVCC snapshot for the current transaction, used to determine which tuple versions are visible.</li>
</ul>
<p>This design cleanly separates the operator's logic from the transactional context it runs in.</p>
<h2 id="3-anatomy-of-physical-operators"><a class="header" href="#3-anatomy-of-physical-operators">3. Anatomy of Physical Operators</a></h2>
<p>Data flows <em>up</em> the tree from the leaves (scans) to the root. Let's see how it works by examining a few key operators.</p>
<h3 id="leaf-operator-physicalseqscan"><a class="header" href="#leaf-operator-physicalseqscan">Leaf Operator: <code>PhysicalSeqScan</code></a></h3>
<p>A sequential scan is at the leaf of a plan tree. It's responsible for reading tuples from a table on disk.</p>
<ul>
<li><strong><code>init()</code></strong>: It acquires an <code>IntentionShared</code> lock on the table and creates a <code>TableIterator</code> for the table heap.</li>
<li><strong><code>next()</code></strong>: In a loop, it does the following:
<ol>
<li>Pulls the next raw tuple <code>(rid, meta, tuple)</code> from the <code>TableIterator</code>.</li>
<li>Calls <code>context.is_visible(&amp;meta)</code> to perform an <strong>MVCC visibility check</strong> using the transaction's snapshot.</li>
<li>If the tuple version is visible, it acquires the necessary row lock (e.g., <code>Shared</code> lock) and returns the tuple.</li>
<li>If the tuple is not visible, it ignores it and loops to get the next one.</li>
</ol>
</li>
</ul>
<h3 id="unary-operator-physicalfilter"><a class="header" href="#unary-operator-physicalfilter">Unary Operator: <code>PhysicalFilter</code></a></h3>
<p>A filter has one child operator (its <code>input</code>). It implements a <code>WHERE</code> clause.</p>
<ul>
<li><strong><code>next()</code></strong>: Its logic is a simple, tight loop:
<ol>
<li>It calls <code>self.input.next()</code> to get a tuple from its child.</li>
<li>If the child returns <code>None</code>, the filter is also exhausted and returns <code>None</code>.</li>
<li>If it receives a tuple, it evaluates its predicate expression (e.g., <code>age &gt; 30</code>) against the tuple.</li>
<li>If the predicate evaluates to <code>true</code>, it returns the tuple. Otherwise, it loops back to step 1.</li>
</ol>
</li>
</ul>
<h3 id="binary-operator-physicalnestedloopjoin"><a class="header" href="#binary-operator-physicalnestedloopjoin">Binary Operator: <code>PhysicalNestedLoopJoin</code></a></h3>
<p>A join has two children: a left (outer) and a right (inner).</p>
<ul>
<li><strong><code>next()</code></strong>: It implements the classic nested loop join algorithm:
<ol>
<li>Fetch one tuple from the <strong>outer</strong> (left) child and hold onto it.</li>
<li>Enter a loop: fetch tuples one by one from the <strong>inner</strong> (right) child.</li>
<li>For each inner tuple, combine it with the held outer tuple and evaluate the join condition. If it matches, return the combined tuple.</li>
<li>When the inner child is exhausted, <strong>rewind it</strong> by calling <code>self.right_input.init()</code> again.</li>
<li>Go back to step 1 to fetch the <em>next</em> tuple from the outer child.</li>
<li>Repeat until the outer child is also exhausted.</li>
</ol>
</li>
</ul>
<h2 id="4-putting-it-all-together"><a class="header" href="#4-putting-it-all-together">4. Putting It All Together</a></h2>
<p>Consider the query <code>SELECT name FROM users WHERE age &gt; 30</code>. The physical plan is <code>Projection -&gt; Filter -&gt; SeqScan</code>.</p>
<ol>
<li>The <code>ExecutionEngine</code> calls <code>next()</code> on the <code>Projection</code> operator.</li>
<li>The <code>Projection</code> operator needs a tuple, so it calls <code>next()</code> on its child, <code>Filter</code>.</li>
<li>The <code>Filter</code> operator needs a tuple, so it calls <code>next()</code> on its child, <code>SeqScan</code>.</li>
<li>The <code>SeqScan</code> operator fetches a raw tuple from the <code>TableHeap</code>, checks its MVCC visibility, and finds a visible tuple for a user with <code>age = 25</code>.</li>
<li><code>SeqScan</code> returns this tuple up to <code>Filter</code>.</li>
<li><code>Filter</code> evaluates <code>age &gt; 30</code> on the tuple. It's false, so it loops, calling <code>SeqScan.next()</code> again.</li>
<li><code>SeqScan</code> finds another visible tuple, this time for a user with <code>age = 40</code> and <code>name = 'Alice'</code>.</li>
<li><code>SeqScan</code> returns this tuple up to <code>Filter</code>.</li>
<li><code>Filter</code> evaluates <code>age &gt; 30</code>. It's true! It returns the tuple for Alice up to <code>Projection</code>.</li>
<li><code>Projection</code> takes the full tuple for Alice, creates a new tuple containing only the <code>name</code> column (<code>'Alice'</code>), and returns this new tuple as the result.</li>
</ol>
<p>This process repeats, with tuples flowing up the tree one at a time, until the <code>SeqScan</code> operator runs out of pages and returns <code>None</code>, which then propagates up the tree, signaling the end of execution.</p>
<hr />
<h2 id="for-study--discussion-7"><a class="header" href="#for-study--discussion-7">For Study &amp; Discussion</a></h2>
<ol>
<li>
<p><strong>Push vs. Pull Models</strong>: The Volcano model is a "pull-based" model. An alternative is a "push-based" model, where operators push their results to their parents as soon as they are ready. What are the potential advantages and disadvantages of each model, particularly concerning cache efficiency and control flow?</p>
</li>
<li>
<p><strong>Blocking vs. Non-Blocking Operators</strong>: Some operators, like <code>PhysicalFilter</code>, can produce their first output row as soon as they receive their first input row. These are <strong>non-blocking</strong>. Other operators, like <code>PhysicalSort</code>, must consume their <em>entire</em> input before they can produce even a single row of output. These are <strong>blocking</strong>. What is the impact of blocking operators on query latency and memory usage?</p>
</li>
<li>
<p><strong>Programming Exercise</strong>: The current <code>PhysicalNestedLoopJoin</code> is simple but can be inefficient as it re-scans the entire inner table for every outer row. Implement a <code>PhysicalBlockNestedLoopJoin</code> operator. This version would read a <em>block</em> (a small batch) of tuples from the outer table into an in-memory buffer, and then iterate through the inner table once for that entire block. This can significantly reduce the number of times the inner table needs to be scanned.</p>
</li>
<li>
<p><strong>Programming Exercise</strong>: Implement the <code>PhysicalLimit</code> operator. Its <code>next()</code> method should:
a.  Keep an internal counter.
b.  If the counter is less than the <code>offset</code>, pull and discard tuples from its child.
c.  If the counter is between <code>offset</code> and <code>offset + limit</code>, pull a tuple from its child and return it.
d.  Once the limit is reached, it should stop pulling from its child and return <code>None</code> for all subsequent calls. This is important for efficiency, as it stops the execution of the entire sub-tree below it.</p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
