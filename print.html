<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>QuillSQL Internals</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-3cb649c7.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">QuillSQL Internals</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <div align="center">
  <img src="assets/rust-db.png" alt="QuillSQL Logo" width="500" />
</div>

<h1 id="quillsql-internals"><a class="header" href="#quillsql-internals">QuillSQL Internals</a></h1>
<p>Welcome to the technical documentation for QuillSQL.</p>
<p>This book provides a deep dive into the internal architecture and implementation details of the database. It is intended for developers, contributors, and anyone interested in understanding how a relational database is built from the ground up, referencing concepts from classic database courses like CMU 15-445.</p>
<hr>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li>
<p><a href="#quillsql-architecture"><strong>Overall Architecture</strong></a>: A high-level overview of the entire system.</p>
</li>
<li>
<p><strong>Core Modules</strong></p>
<ul>
<li><a href="#buffer-manager"><strong>Buffer Manager</strong></a>: The in-memory page cache.
<ul>
<li><a href="#page--page-guards">Page &amp; Page Guards</a></li>
<li><a href="#the-buffer-pool-architecture-and-lifecycle">The Buffer Pool</a></li>
</ul>
</li>
<li><a href="#storage-engine"><strong>Storage Engine</strong></a>: How data is physically stored.
<ul>
<li><a href="#disk-io--scheduler-io_uring-data-pages--wal-runtime">Disk I/O</a></li>
<li><a href="#page-and-tuple-layout">Page &amp; Tuple Layout</a></li>
<li><a href="#table-heap-and-mvcc">Table Heap &amp; MVCC</a></li>
</ul>
</li>
<li><a href="#index-module"><strong>Indexes</strong></a>: The B+Tree implementation.
<ul>
<li><a href="#b-tree-index--architecture-and-concurrency">B+Tree Details</a></li>
</ul>
</li>
<li><a href="#recovery--wal-module"><strong>Recovery Manager (WAL)</strong></a>: Crash recovery and the ARIES protocol.</li>
<li><a href="#transaction-module"><strong>Transaction Manager</strong></a>: Concurrency control with MVCC and 2PL.</li>
<li><a href="#query-planner-module"><strong>Query Plan</strong></a>: The journey from SQL to an executable plan.</li>
<li><a href="#optimizer-module"><strong>Query Optimizer</strong></a>: Rule-based plan transformations.</li>
<li><a href="#execution-engine"><strong>Execution Engine</strong></a>: The Volcano (iterator) execution model.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="quillsql-architecture"><a class="header" href="#quillsql-architecture">QuillSQL Architecture</a></h1>
<p>This chapter gives a tour of the major subsystems, the flow of a SQL statement, and the contract between execution, transactions, and storage. It uses Mermaid diagrams so you can render the visuals directly inside mdBook or any compatible viewer.</p>
<hr>
<h2 id="1-end-to-end-pipeline"><a class="header" href="#1-end-to-end-pipeline">1. End-to-End Pipeline</a></h2>
<pre class="mermaid">flowchart LR
    subgraph Frontend
        CLI["bin/client"] --&gt; Parser["sql::parser"]
        HTTP["bin/server"] --&gt; Parser
    end
    Parser --&gt; LPlan["plan::LogicalPlanner"]
    LPlan --&gt; Optimizer["optimizer::LogicalOptimizer"]
    Optimizer --&gt; PPlan["plan::PhysicalPlanner"]
    PPlan --&gt; Exec["execution::ExecutionEngine (Volcano)"]

    subgraph Txn["transaction::*"]
        Session["session::SessionContext"]
        TM["TransactionManager"]
        LM["LockManager"]
        Session --&gt; TM --&gt; LM
    end

    Exec &lt;--&gt;|snapshot, locks| Txn
    Exec --&gt; Binding

    subgraph Storage["storage::* &amp; buffer::*"]
        Binding["storage::engine::TableBinding"]
        Heap["storage::table_heap::TableHeap"]
        MVCC["storage::heap::MvccHeap"]
        Index["storage::index::BPlusTree"]
        Buffer["buffer::BufferManager"]
        Disk["storage::disk_scheduler (io_uring)"]
        WAL["recovery::WalManager"]
        Binding --&gt; Heap
        Binding --&gt; Index
        Heap &lt;--&gt; Buffer
        Index &lt;--&gt; Buffer
        Buffer &lt;--&gt; Disk
        WAL --&gt; Disk
    end

    Background["background::workers\n(checkpoint, WAL writer, MVCC vacuum)"] --&gt; {Buffer, WAL, TM}
</pre>

<p><strong>Key takeaways</strong></p>
<ul>
<li>The frontend (CLI/HTTP) only knows how to parse SQL and drive the planning stages; all shared state lives below.</li>
<li>The <code>ExecutionEngine</code> drives a Volcano iterator. Each physical operator calls into the transaction runtime for visibility checks and locking, but touches storage exclusively through a <code>TableBinding</code>. This makes the executor easy to reason about in a classroom setting.</li>
<li>Buffering, WAL, and disk I/O are centralized so that durability/ordering guarantees stay in one module.</li>
</ul>
<hr>
<h2 id="2-transactions-mvcc-and-the-executor"><a class="header" href="#2-transactions-mvcc-and-the-executor">2. Transactions, MVCC, and the Executor</a></h2>
<pre class="mermaid">sequenceDiagram
    autonumber
    participant Session
    participant TM as TransactionManager
    participant Runtime as TxnRuntime
    participant Exec
    participant Binding
    participant Heap as TableHeap

    Session-&gt;&gt;TM: begin_txn(isolation, access_mode)
    TM--&gt;&gt;Session: Transaction handle
    Exec-&gt;&gt;Runtime: TxnRuntime::new(&amp;TM, &amp;mut txn)
    Runtime--&gt;&gt;Exec: {snapshot, command_id}

    loop per tuple
        Exec-&gt;&gt;Binding: scan.next()
        Binding-&gt;&gt;Heap: TableIterator::next()
        Heap--&gt;&gt;Binding: (rid, meta, tuple)
        Binding--&gt;&gt;Exec: (rid, meta, tuple)
        Exec-&gt;&gt;Runtime: is_visible(meta)?
        Runtime--&gt;&gt;Exec: yes/no
        alt visible &amp; needs lock
            Exec-&gt;&gt;Runtime: lock_row(table, rid, mode)
            Runtime--&gt;&gt;Exec: guard
        end
        alt mutation
            Exec-&gt;&gt;Binding: prepare_row_for_write(...)
            Binding-&gt;&gt;Heap: mvcc.full_tuple(...)
            Heap--&gt;&gt;Binding: (current_meta, tuple)
            Binding-&gt;&gt;TM: push_undo + append WAL(HeapRecord)
        end
    end

    Session-&gt;&gt;TM: commit(txn)
    TM-&gt;&gt;WAL: Transaction{Commit}
    TM-&gt;&gt;TM: flush_until(lsn) if synchronous
    TM--&gt;&gt;Session: release locks, clear snapshot
</pre>

<p><strong>Snapshot policy</strong></p>
<ul>
<li><code>Read Uncommitted / Read Committed</code>: every command obtains a fresh snapshot, so repeated statements can see committed updates.</li>
<li><code>Repeatable Read / Serializable</code>: cache the first snapshot on the <code>Transaction</code> handle; subsequent commands reuse it for consistent reads. The lock manager releases S-locks at the end of each command for RR, but Serializable keeps them until commit.</li>
</ul>
<p><strong>Undo &amp; WAL</strong></p>
<ul>
<li>Each mutation produces a logical <code>HeapRecordPayload</code> or <code>IndexRecordPayload</code>. The heap payload already carries redo (new bytes) and undo (old bytes), so recovery can replay forward or backward without re-reading heap pages.</li>
<li>On abort, the manager walks the undo stack, emits CLRs, and re-applies the inverse heap/index operations.</li>
</ul>
<hr>
<h2 id="3-storage-layering"><a class="header" href="#3-storage-layering">3. Storage Layering</a></h2>
<pre class="mermaid">graph TD
    subgraph Planner View
        Catalog
    end
    Catalog --&gt;|Arc&lt;TableHeap&gt;| TableBinding
    TableBinding --&gt; Heap["TableHeap"]
    TableBinding --&gt; Mvcc["MvccHeap"]
    TableBinding --&gt; Index["BPlusTreeIndex"]
    Heap --&gt;|pages| BufferMgr
    Index --&gt;|pages| BufferMgr
    BufferMgr --&gt; DiskMgr
    BufferMgr --&gt; WalMgr
</pre>

<div class="table-wrapper">
<table>
<thead>
<tr><th>Layer</th><th>Responsibility</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td><code>TableHeap</code></td><td>Physical slotted pages, tuple encoding, WAL page image helpers</td><td>Exposes insert/update/delete that emit heap-specific WAL payloads before dirtying frames.</td></tr>
<tr><td><code>MvccHeap</code></td><td>Version chain management, delete-marking, undo metadata</td><td>Creates new versions, rewires forward/back pointers, and delegates actual I/O to <code>TableHeap</code>.</td></tr>
<tr><td><code>TableBinding</code></td><td>Safe façade for the executor</td><td>Provides <code>scan</code>, <code>index_scan</code>, <code>insert</code>, <code>delete</code>, <code>update</code>, and <code>prepare_row_for_write</code>, always pairing heap/index changes so operators stay small.</td></tr>
<tr><td><code>BufferManager</code> + <code>DiskScheduler</code></td><td>Unified cache + async I/O</td><td>Uses LRU-K (+ optional TinyLFU admission) and io_uring to keep the hot set resident.</td></tr>
<tr><td><code>WalManager</code></td><td>ARIES-compatible log</td><td>Supports logical heap/index records, page write/delta fallback, CLRs, checkpoints, and background flush threads.</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="4-tablebinding-contract"><a class="header" href="#4-tablebinding-contract">4. <code>TableBinding</code> Contract</a></h2>
<pre class="mermaid">classDiagram
    class TableBinding {
        +scan() -&gt; TupleStream
        +index_scan(name, IndexScanRequest) -&gt; TupleStream
        +insert(&amp;mut TxnContext, &amp;Tuple)
        +delete(&amp;mut TxnContext, RecordId, TupleMeta, Tuple)
        +update(&amp;mut TxnContext, RecordId, Tuple, TupleMeta, Tuple) -&gt; RecordId
        +prepare_row_for_write(&amp;mut TxnContext, RecordId, &amp;TupleMeta)
        +table_heap() -&gt; Arc&lt;TableHeap&gt;
    }

    class PhysicalOperator {
        +init(&amp;mut ExecutionContext)
        +next(&amp;mut ExecutionContext) -&gt; Option&lt;Tuple&gt;
    }

    PhysicalOperator --&gt; TableBinding : uses
</pre>

<p>This binding hides every MVCC/WAL detail from the operators:</p>
<ul>
<li>No more ad-hoc <code>catalog.table_indexes()</code> calls.</li>
<li>No direct references to <code>MvccHeap</code> or <code>TableHeap</code>.</li>
<li>Executor code reads like pseudo SQL: “lock table”, “scan binding”, “update tuple”.</li>
</ul>
<hr>
<h2 id="5-wal--recovery-details"><a class="header" href="#5-wal--recovery-details">5. WAL &amp; Recovery Details</a></h2>
<pre class="mermaid">flowchart LR
    subgraph WAL Record Types
        HI["HeapInsert"] --&gt; redo
        HD["HeapDelete (with before-image)"] --&gt; redo &amp; undo
        LI["IndexLeaf{Insert,Delete}"]
        IS["IndexSplit/Merge/Redistribute/Parent*"]
        IR["IndexRoot Install/Adopt/Reset"]
        PI["PageWrite (FPW)"]
        CI["Checkpoint"]
        CL["CLR"]
    end
    Exec --&gt;|Heap/Index payloads| WalMgr
    BufferMgr --&gt;|first-touch FPW| WalMgr
    WalMgr --&gt; DiskScheduler --&gt; log files
    Recovery --&gt;|analysis/redo/undo| BufferMgr
</pre>

<ul>
<li><strong>Logical logging first</strong>: heap/index mutations emit redo + undo at the logical level. This keeps the WAL stream compact and human-readable for teaching.</li>
<li><strong>Physical fallbacks</strong>: metadata-heavy pages (meta, freelist, header) still leverage PageWrite FPWs to guarantee a consistent base image, especially on the first page flush after a crash.</li>
<li><strong>Restart</strong>: <code>RecoveryManager</code> performs the classical ARIES sequence. It uses the <code>dirty_page_table</code> and <code>active_txn_table</code> captured by checkpoints to limit redo and undo work.</li>
</ul>
<hr>
<h2 id="6-background-workers"><a class="header" href="#6-background-workers">6. Background Workers</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Worker</th><th>Purpose</th><th>Configuration</th></tr>
</thead>
<tbody>
<tr><td>WAL writer</td><td>Periodically flushes WAL buffers, coalesces adjacent writes</td><td><code>WalOptions::writer_interval_ms</code>, <code>buffer_capacity</code></td></tr>
<tr><td>Checkpoint</td><td>Records ATT + DPT, gently pushes dirty buffers</td><td><code>WalOptions::checkpoint_interval_ms</code></td></tr>
<tr><td>Buffer writer</td><td>Flushes frames when the dirty set grows too large</td><td><code>background::BufferWriterConfig</code></td></tr>
<tr><td>MVCC vacuum</td><td>Reclaims obsolete tuple versions based on <code>safe_xmin</code></td><td><code>MvccVacuumConfig</code></td></tr>
<tr><td>Index vacuum</td><td>Cleans up deleted index entries using B-link traversal</td><td><code>IndexVacuumConfig</code></td></tr>
</tbody>
</table>
</div>
<p>Workers register with <code>background::BackgroundWorkers</code>, so the database can stop and join them cleanly on shutdown. Each worker publishes metrics (intervals, batches processed) for observability.</p>
<hr>
<h2 id="7-example-repeatable-read-update"><a class="header" href="#7-example-repeatable-read-update">7. Example: Repeatable Read UPDATE</a></h2>
<pre class="mermaid">sequenceDiagram
    participant T1 as Txn 1 (RR)
    participant T2 as Txn 2 (RC)
    participant Heap as TableHeap

    T1-&gt;&gt;Heap: SELECT (snapshot S0)
    Heap--&gt;&gt;T1: version V0
    T2-&gt;&gt;Heap: UPDATE -&gt; insert V1, delete V0
    Heap--&gt;&gt;T2: ack
    T2-&gt;&gt;T2: COMMIT (WAL + locks release)
    T1-&gt;&gt;Heap: SELECT again
    Heap--&gt;&gt;T1: V0 still visible via snapshot S0
    T1-&gt;&gt;T1: COMMIT
    Note over T1,Heap: Vacuum later removes V0 when safe_xmin advances
</pre>

<p>This timeline demonstrates:</p>
<ul>
<li>Snapshots shield Repeatable Read statements from concurrent writers even if row-level locks are released early.</li>
<li>The MVCC chain (<code>V1.prev_version = V0</code>, <code>V0.next_version = V1</code>) lets future readers reach the newest committed version while the vacuum worker reclaims obsolete ones lazily.</li>
</ul>
<hr>
<h2 id="8-observability--configuration-cheat-sheet"><a class="header" href="#8-observability--configuration-cheat-sheet">8. Observability &amp; Configuration Cheat Sheet</a></h2>
<ul>
<li><strong>Logging</strong>: <code>RUST_LOG=trace</code> surfaces lock acquisitions, MVCC vacuums, and io_uring completions.</li>
<li><strong>Runtime knobs</strong>: <code>WalOptions</code> (segment size, sync policy), <code>BufferPoolConfig</code> (capacity, TinyLFU toggle), <code>MvccVacuumConfig</code>, and <code>IndexVacuumConfig</code> can all be adjusted via <code>DatabaseOptions</code>.</li>
<li><strong>Metrics</strong>: <code>background::BackgroundWorkers::snapshot()</code> reports worker health; WAL exposes current LSN and flush LSN; the buffer manager can dump the dirty page table for diagnostics.</li>
</ul>
<hr>
<p>With these layers in place, QuillSQL remains faithful to production-grade engines (MVCC + WAL + buffer pool) while keeping its code and documentation approachable for coursework and research prototypes.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="module-overview"><a class="header" href="#module-overview">Module Overview</a></h1>
<p>This page gives a teaching-friendly tour of every QuillSQL subsystem. Each section
explains where the code lives (<code>src/&lt;module&gt;</code>), the most important types, and the
design decisions that make the module fit into the whole system. Read it together
with <a href="#quillsql-architecture"><code>architecture.md</code></a> for the big-picture data flow.</p>
<hr>
<h2 id="1-sql-front-end-srcsql"><a class="header" href="#1-sql-front-end-srcsql">1. SQL Front-End (<code>src/sql</code>)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Submodule</th><th>Responsibilities</th><th>Key Types / Functions</th></tr>
</thead>
<tbody>
<tr><td><code>lexer.rs</code>, <code>parser.rs</code></td><td>Translate raw SQL into an AST using <code>sqlparser</code> plus Quill-specific extensions.</td><td><code>parse_sql(&amp;str) -&gt; Vec&lt;Statement&gt;</code></td></tr>
<tr><td><code>ast/mod.rs</code></td><td>Normalises identifiers, handles multi-part names, attaches spans for diagnostics.</td><td><code>NormalizedIdent</code>, <code>ObjectNameExt</code></td></tr>
<tr><td><code>plan/lowering.rs</code></td><td>Bridges AST → planner structs for DDL extras not in upstream <code>sqlparser</code>.</td><td><code>CreateIndexSpec</code>, <code>ColumnDefExt</code></td></tr>
</tbody>
</table>
</div>
<p>Implementation notes:</p>
<ul>
<li>We intentionally keep the AST “SQL-shaped”. No premature desugaring occurs in the
parser, which keeps the step-by-step teaching narrative simple: <strong>SQL text → AST →
logical plan</strong>.</li>
<li>Error messages bubble up with span information, so labs around parser extensions can
show students exactly which token misbehaved.</li>
<li>Suggested exercises: extend the parser with <code>ALTER TABLE</code> or window functions, then
observe how the new AST nodes flow into the planner layer.</li>
</ul>
<hr>
<h2 id="2-logical-planning-srcplan"><a class="header" href="#2-logical-planning-srcplan">2. Logical Planning (<code>src/plan</code>)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>LogicalPlanner</code></td><td>Converts AST nodes into strongly typed <code>LogicalPlan</code> variants. Responsible for type checking, alias resolution, and scope handling.</td></tr>
<tr><td><code>PlannerContext</code></td><td>Surface for catalog lookups while planning.</td></tr>
<tr><td><code>PhysicalPlanner</code></td><td>Lowers optimized logical plans into physical Volcano operators (<code>PhysicalPlan</code>).</td></tr>
</tbody>
</table>
</div>
<p>Highlights:</p>
<ul>
<li>Every <code>LogicalPlan</code> variant stores its child plans in <code>Arc</code>, so the tree is cheap to
clone for optimizer passes or debugging prints.</li>
<li>Planner enforces column binding rules: scope stacks keep track of aliases, CTEs, and
correlation so students can see how real compilers resolve identifiers.</li>
<li>DDL nodes capture <code>TableReference</code> + <code>Schema</code> objects. Later phases use them to skip
repeated catalog lookups (helpful for labs about metadata caching).</li>
</ul>
<hr>
<h2 id="3-optimizer-srcoptimizer"><a class="header" href="#3-optimizer-srcoptimizer">3. Optimizer (<code>src/optimizer</code>)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Piece</th><th>Responsibility</th></tr>
</thead>
<tbody>
<tr><td><code>LogicalOptimizer</code></td><td>Applies a pipeline of rule-based rewrites (predicate pushdown, projection pruning, constant folding).</td></tr>
<tr><td><code>rules</code></td><td>Individual <code>OptimizerRule</code> implementations.</td></tr>
</tbody>
</table>
</div>
<p>Teaching hooks:</p>
<ul>
<li>Each rule implements <code>OptimizerRule::rewrite(&amp;LogicalPlan) -&gt; Option&lt;LogicalPlan&gt;</code>. The
return type makes it obvious whether a rewrite fired, so labs can instrument hit counts
or add tracing.</li>
<li>Because rules are pure functions, students can safely reorder or A/B test heuristics in
isolation (e.g., “what if we only push predicates below joins when the selectivity
estimate exceeds X?”).</li>
<li>Example lab: add constant folding or join commutation, run the sqllogictest suite, and
compare plan dumps to see new shapes.</li>
</ul>
<hr>
<h2 id="4-execution-engine-srcexecution"><a class="header" href="#4-execution-engine-srcexecution">4. Execution Engine (<code>src/execution</code>)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Element</th><th>Details</th></tr>
</thead>
<tbody>
<tr><td><code>PhysicalPlan</code></td><td>Enum covering all Volcano operators. Each variant implements <code>VolcanoExecutor</code>.</td></tr>
<tr><td><code>VolcanoExecutor</code></td><td><code>init(&amp;mut ExecutionContext)</code> and <code>next(&amp;mut ExecutionContext)</code> pair define the iterator model.</td></tr>
<tr><td><code>ExecutionContext</code></td><td>Supplies catalog access, expression evaluation, and (most importantly) a pluggable <code>StorageEngine</code>.</td></tr>
</tbody>
</table>
</div>
<p>Design notes:</p>
<ul>
<li>Operators stay declarative. They describe <em>what</em> to scan or modify and delegate the
<em>how</em> to storage handles. For example, <code>PhysicalSeqScan</code> now requests a <code>TupleStream</code>
via <code>ExecutionContext::table_stream</code>, so it never touches <code>TableHeap</code> internals.</li>
<li>Helper methods such as <code>eval_predicate</code>, <code>insert_tuple_with_indexes</code>, or
<code>prepare_row_for_write</code> encapsulate MVCC/locking rules so physical plans remain short.</li>
<li>ExecutionContext caches <code>TxnContext</code>, making it straightforward to teach isolation
semantics: examine <code>TxnContext::lock_table</code> and <code>read_visible_tuple</code> to see when locks
are taken or released.</li>
<li>Suggested lab: implement a new physical operator (e.g., hash join) by wiring two child
<code>PhysicalPlan</code>s without ever touching storage-specific code. This highlights the payoff
of the handle abstraction.</li>
</ul>
<hr>
<h2 id="5-transaction-runtime-srctransaction"><a class="header" href="#5-transaction-runtime-srctransaction">5. Transaction Runtime (<code>src/transaction</code>)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>TransactionManager</code></td><td>Creates/commits/aborts transactions, manages undo chains, and coordinates WAL durability.</td></tr>
<tr><td><code>TxnContext</code></td><td>Per-command wrapper passed to execution. Provides MVCC snapshot (<code>TransactionSnapshot</code>), lock helpers, and command ids.</td></tr>
<tr><td><code>LockManager</code></td><td>Multi-granularity 2PL with deadlock detection.</td></tr>
</tbody>
</table>
</div>
<p>Deeper dive:</p>
<ul>
<li><code>Transaction</code> stores a cached <code>TransactionSnapshot</code> plus its undo records. Students can
inspect <code>Transaction::set_snapshot</code> to see how Repeatable Read/Serializable keep a
stable view.</li>
<li><code>TxnRuntime</code> pairs a transaction with a command id. Every SQL statement increments the
command id so MVCC can distinguish between tuples created earlier in the same
transaction vs. the current statement—great for explaining “recent writes are invisible
during UPDATE scanning”.</li>
<li><code>LockManager</code> exposes functions like <code>lock_table</code> / <code>lock_row</code>. Internally it keeps a
wait-for graph and victim selection policy, which makes deadlock detection tangible for
concurrency lectures.</li>
<li>Undo entries (<code>UndoRecord</code>) store heap + index data. When an abort occurs the engine
generates CLRs, demonstrating ARIES-style logical undo.</li>
</ul>
<hr>
<h2 id="6-storage-engine--handles-srcstorage"><a class="header" href="#6-storage-engine--handles-srcstorage">6. Storage Engine &amp; Handles (<code>src/storage</code>)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>Highlights</th></tr>
</thead>
<tbody>
<tr><td><code>engine.rs</code></td><td>Defines <code>StorageEngine</code>, <code>TableHandle</code>, <code>IndexHandle</code>, <code>TupleStream</code>, and <code>IndexScanRequest</code>.</td></tr>
<tr><td><code>table_heap</code></td><td>Slotted-page heap with MVCC metadata (<code>TupleMeta</code>, forward/back pointers).</td></tr>
<tr><td><code>index</code></td><td>B+Tree (B-link) implementation with iterators and codecs.</td></tr>
</tbody>
</table>
</div>
<p>Key ideas for teaching:
Topics to emphasise:</p>
<ul>
<li><strong>Handle abstraction</strong>: Execution asks the engine for a <code>TableHandle</code>, then calls
<code>full_scan()</code> to receive a <code>TupleStream</code>. The default engine simply wraps
<code>TableHeap</code>/<code>BPlusTreeIndex</code>, but students can plug in their own engines for research.</li>
<li><strong>TupleStream</strong>: Minimal interface returning <code>(RecordId, TupleMeta, Tuple)</code> triples.
Operators layer MVCC visibility on top, while the stream hides buffering details.</li>
<li><strong>Scan extensions</strong>: Consider extending <code>full_scan()</code> to accept projection/batch hints—
a natural exercise for showing how execution and storage negotiate capabilities.</li>
<li><code>table_heap</code> demonstrates MVCC version chains (forward/back pointers) and the slotted
page layout. Encourage students to trace <code>MvccHeap::update</code> alongside WAL entries to
see how new versions link together.</li>
<li><code>index/btree_index.rs</code> implements a B-link tree with separate codecs. Scanning via
<code>TreeIndexIterator</code> shows how to perform lock-free range scans using sibling pointers—
perfect for advanced systems lectures.</li>
</ul>
<hr>
<h2 id="7-buffer-manager--disk-io-srcbuffer-srcstoragedisk_"><a class="header" href="#7-buffer-manager--disk-io-srcbuffer-srcstoragedisk_">7. Buffer Manager &amp; Disk I/O (<code>src/buffer</code>, <code>src/storage/disk_*</code>)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Module</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>buffer::BufferManager</code></td><td>Page table + LRU-K/TinyLFU replacer, dirty tracking, guard types for safe borrowing.</td></tr>
<tr><td><code>storage::disk_scheduler</code></td><td><code>io_uring</code>-powered async I/O. Foreground threads enqueue read/write/fsync commands and await completions.</td></tr>
<tr><td><code>storage::disk_manager</code></td><td>Thin wrapper for file layout, page enlargement, and durability fences.</td></tr>
</tbody>
</table>
</div>
<p>Extra details:</p>
<ul>
<li>Page guards come in three flavours: read, write, and upgradeable. Each implements <code>Drop</code>
semantics that release latches automatically, reinforcing RAII patterns.</li>
<li>Replacement policy combines LRU-K history with TinyLFU admission. Labs can toggle the
feature flag to measure hit-rate differences under sqllogictest or custom workloads.</li>
<li>DiskScheduler uses lock-free queues plus dedicated worker tasks. A teaching exercise is
to run with <code>RUST_LOG=debug</code> and observe how read/write/fsync commands are batched.</li>
</ul>
<hr>
<h2 id="8-recovery--wal-srcrecovery"><a class="header" href="#8-recovery--wal-srcrecovery">8. Recovery &amp; WAL (<code>src/recovery</code>)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Item</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td><code>WalManager</code></td><td>Allocates LSNs, buffers log records, drives background WAL writer, and integrates with checkpoints.</td></tr>
<tr><td><code>RecoveryManager</code></td><td>Implements ARIES analysis/redo/undo. Uses <code>ControlFileManager</code> snapshots to seed restart.</td></tr>
<tr><td><code>wal_record.rs</code></td><td>Defines logical (<code>HeapInsert</code>, <code>IndexDelete</code>, index structure/root records) and physical (<code>PageWrite</code> FPWs) records.</td></tr>
</tbody>
</table>
</div>
<p>Teaching hook:</p>
<ul>
<li>WAL and data share the disk scheduler. Students can trace one UPDATE from log append,
to buffer dirtying, to redo/undo via the exact same <code>RecordId</code>.</li>
<li>Recovery exports statistics (redo count, loser transactions) so labs can check their
WAL experiments automatically.</li>
<li><code>recovery/analysis.rs</code> shows how Dirty Page Table and Active Transaction Table are
reconstructed—ideal for demystifying ARIES’ first phase.</li>
<li>Students can implement “logical replay only” or “page image replay” modes by toggling
the commit record types, then verify behaviour using the provided transaction tests.</li>
</ul>
<hr>
<h2 id="9-background-services-srcbackground"><a class="header" href="#9-background-services-srcbackground">9. Background Services (<code>src/background</code>)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Worker</th><th>What it does</th></tr>
</thead>
<tbody>
<tr><td>WAL writer</td><td>Flushes WAL buffer at configured cadence.</td></tr>
<tr><td>Checkpoint</td><td>Captures the Dirty Page Table + Active Transaction Table.</td></tr>
<tr><td>Buffer writer</td><td>Flushes dirty frames to keep checkpoints short.</td></tr>
<tr><td>MVCC vacuum</td><td>Reclaims tuple versions older than <code>safe_xmin</code>.</td></tr>
</tbody>
</table>
</div>
<p>More context:</p>
<ul>
<li>Workers share a <code>BackgroundWorkers</code> registry so the database can spawn/stop them as a
group (handy for tests). The registry exposes <code>shutdown_all()</code> which unit tests call to
ensure a clean exit.</li>
<li>Config structs (<code>IndexVacuumConfig</code>, <code>MvccVacuumConfig</code>, etc.) live in <code>src/config</code>
and are exposed through <code>DatabaseOptions</code> for easy fiddling in labs.</li>
<li>WAL writer and checkpoint worker simply wrap closures around <code>tokio::task::JoinHandle</code>.
This design keeps async runtime code out of the core engine, making it simpler for
students to trace background effects.</li>
<li>Exercise idea: tweak <code>MvccVacuumConfig::batch_limit</code> and observe how many tuple
versions stay behind by querying hidden statistics tables.</li>
</ul>
<hr>
<h2 id="10-configuration--session-layer-srcdatabase-srcsession-srcconfig"><a class="header" href="#10-configuration--session-layer-srcdatabase-srcsession-srcconfig">10. Configuration &amp; Session Layer (<code>src/database</code>, <code>src/session</code>, <code>src/config</code>)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Role</th></tr>
</thead>
<tbody>
<tr><td><code>Database</code></td><td>Boots disk/WAL/buffer components, runs recovery, wires background workers, and executes SQL strings.</td></tr>
<tr><td><code>SessionContext</code></td><td>Tracks per-connection defaults (autocommit, isolation) and holds the active transaction handle.</td></tr>
<tr><td><code>config::*</code></td><td>Central place for WAL, buffer pool, vacuum, and HTTP/CLI tuning knobs.</td></tr>
</tbody>
</table>
</div>
<p>Extra pointers:</p>
<ul>
<li>Front-ends (<code>bin/client</code>, <code>bin/server</code>) both embed a <code>Database</code>, proving that the core
library can serve multiple UIs without change.</li>
<li><code>DatabaseOptions</code> show how to construct dev/test setups (temporary files, alternate WAL
directories) in a few lines.</li>
<li><code>session::SessionContext</code> demonstrates auto-commit semantics: it lazily starts a
transaction and uses <code>TransactionScope</code> to interpret <code>SET TRANSACTION</code> statements.</li>
<li>Configuration structs derive <code>Clone + Debug</code>, making them easy to print in labs or
feed from environment variables (HTTP server uses <code>QUILL_DB_FILE</code>, <code>PORT</code>, etc.).</li>
</ul>
<hr>
<h2 id="11-testing--documentation-tests-docs"><a class="header" href="#11-testing--documentation-tests-docs">11. Testing &amp; Documentation (<code>tests/</code>, <code>docs/</code>)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Area</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>tests/sql_example/*.slt</code></td><td>sqllogictest suites for SQL coverage.</td></tr>
<tr><td><code>tests/transaction_tests.rs</code></td><td>Unit tests for MVCC invariants, locking, and visibility.</td></tr>
<tr><td><code>docs/</code></td><td>This mdBook. Every module adds its own deep-dive chapter, making it straightforward for students to jump from code to guided explanations.</td></tr>
</tbody>
</table>
</div>
<p>Testing strategy:</p>
<ul>
<li>Developers can run <code>cargo test -q</code> for fast feedback. Long-running suites can be wrapped
with <code>timeout</code> as suggested in <code>AGENTS.md</code>.</li>
<li>Example-driven docs (like this page) mirror the repository layout, so onboarding students
can find code and tests with minimal guesswork.</li>
<li>Encourage students to add sqllogictest cases alongside code changes. Because each case lives
in <code>tests/sql_example</code>, git diffs double as documentation.</li>
<li>For modules with heavy concurrency (lock manager, WAL), pair unit tests with tracing: the
CI logs become walkthroughs for tricky paths.</li>
</ul>
<hr>
<h2 id="12-suggested-reading-order-for-learners"><a class="header" href="#12-suggested-reading-order-for-learners">12. Suggested Reading Order for Learners</a></h2>
<ol>
<li><strong>Introduction ➜ Architecture</strong> – get the 10,000ft view.</li>
<li><strong>Module Overview (this page)</strong> – map names to directories.</li>
<li><strong>Execution + Storage chapters</strong> – understand TupleStreams, handles, and MVCC.</li>
<li><strong>Recovery + Transaction</strong> – see how WAL &amp;&amp; MVCC interlock.</li>
<li><strong>Buffer, Index, Background</strong> – dive into advanced systems topics once the basics stick.</li>
</ol>
<p>Treat this document as a living index: update it whenever a subsystem gains new entry
points (e.g., asynchronous scans, new index types) so future contributors always know
where to look next.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="contributors-guide"><a class="header" href="#contributors-guide">Contributor’s Guide</a></h1>
<p>Welcome, and thank you for your interest in contributing to QuillSQL! Whether you’re fixing a bug, adding a new feature, or improving the documentation, this guide will help you get started.</p>
<h2 id="1-getting-started-your-development-environment"><a class="header" href="#1-getting-started-your-development-environment">1. Getting Started: Your Development Environment</a></h2>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<ul>
<li><strong>Rust</strong>: QuillSQL is written in Rust. If you don’t have it yet, install it via <a href="https://rustup.rs/">rustup</a>. This will provide you with <code>rustc</code> (the compiler) and <code>cargo</code> (the package manager and build tool).
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
</li>
<li><strong>Build Essentials</strong>: Ensure you have a C++ compiler like <code>gcc</code> or <code>clang</code> installed, which is a common dependency for some Rust crates.</li>
</ul>
<h3 id="setup"><a class="header" href="#setup">Setup</a></h3>
<ol>
<li>
<p><strong>Fork the Repository</strong>: Start by forking the main QuillSQL repository to your own GitHub account.</p>
</li>
<li>
<p><strong>Clone Your Fork</strong>: Clone your forked repository to your local machine.</p>
<pre><code class="language-bash">git clone https://github.com/feichai0017/QuillSQL.git
cd QuillSQL
</code></pre>
</li>
<li>
<p><strong>Build the Project</strong>: Compile the entire project to ensure everything is set up correctly.</p>
<pre><code class="language-bash">cargo build
</code></pre>
</li>
</ol>
<h2 id="2-development-workflow"><a class="header" href="#2-development-workflow">2. Development Workflow</a></h2>
<h3 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h3>
<p>Before and after making any changes, it’s crucial to run the test suite to ensure you haven’t broken anything.</p>
<ul>
<li>
<p><strong>Run all unit and integration tests</strong>:</p>
<pre><code class="language-bash">cargo test
</code></pre>
</li>
<li>
<p><strong>Run the benchmark suite</strong>:</p>
<pre><code class="language-bash">cargo bench
</code></pre>
</li>
</ul>
<h3 id="code-style-and-quality"><a class="header" href="#code-style-and-quality">Code Style and Quality</a></h3>
<p>We adhere to the standard Rust coding style and use tools to enforce it.</p>
<ul>
<li>
<p><strong>Formatting</strong>: Before committing, please format your code with <code>rustfmt</code>.</p>
<pre><code class="language-bash">cargo fmt --all
</code></pre>
</li>
<li>
<p><strong>Linting</strong>: We use <code>clippy</code> to catch common mistakes and improve code quality. Please ensure <code>clippy</code> passes without warnings.</p>
<pre><code class="language-bash">cargo clippy --all-targets -- -D warnings
</code></pre>
</li>
</ul>
<h3 id="submitting-your-contribution"><a class="header" href="#submitting-your-contribution">Submitting Your Contribution</a></h3>
<ol>
<li>
<p><strong>Create a New Branch</strong>: Create a descriptive branch name for your feature or bugfix.</p>
<pre><code class="language-bash">git checkout -b my-awesome-feature
</code></pre>
</li>
<li>
<p><strong>Make Your Changes</strong>: Write your code. Add new tests to cover your changes. Ensure all existing tests still pass.</p>
</li>
<li>
<p><strong>Format and Lint</strong>: Run <code>cargo fmt</code> and <code>cargo clippy</code> as described above.</p>
</li>
<li>
<p><strong>Commit Your Work</strong>: Write a clear and concise commit message.</p>
<pre><code class="language-bash">git add .
git commit -m "feat: Add support for window functions"
</code></pre>
</li>
<li>
<p><strong>Push to Your Fork</strong>: Push your branch to your fork on GitHub.</p>
<pre><code class="language-bash">git push -u origin my-awesome-feature
</code></pre>
</li>
<li>
<p><strong>Open a Pull Request</strong>: Go to the original QuillSQL repository on GitHub. You should see a prompt to open a Pull Request from your new branch. Fill out the PR template with a description of your changes.</p>
</li>
</ol>
<h2 id="3-working-on-the-documentation"><a class="header" href="#3-working-on-the-documentation">3. Working on the Documentation</a></h2>
<p>The documentation is built using <code>mdbook</code>. To preview your changes locally, you’ll need to install it and the <code>mermaid</code> plugin.</p>
<ol>
<li>
<p><strong>Install <code>mdbook</code> and <code>mdbook-mermaid</code></strong>:</p>
<pre><code class="language-bash">cargo install mdbook
cargo install mdbook-mermaid
</code></pre>
</li>
<li>
<p><strong>Serve the Book Locally</strong>: Run the following command from the root of the project.</p>
<pre><code class="language-bash">mdbook serve docs
</code></pre>
<p>This will build the book and start a local web server. You can open your browser to <code>http://localhost:3000</code> to see the live-previewed documentation.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sql-front-end"><a class="header" href="#sql-front-end">SQL Front-End</a></h1>
<p>The SQL front-end lives in <code>src/sql/</code>. It turns raw UTF-8 query text into the abstract
syntax trees (ASTs) consumed by planning, while layering Quill-specific name handling
and diagnostics on top of <a href="https://docs.rs/sqlparser"><code>sqlparser</code></a>.</p>
<hr>
<h2 id="responsibilities"><a class="header" href="#responsibilities">Responsibilities</a></h2>
<ul>
<li>Parse SQL text into <code>sqlparser::ast::Statement</code> values.</li>
<li>Record precise spans so error messages can highlight the exact byte range.</li>
<li>Normalise identifiers (case folding, quoted names, multi-part paths).</li>
<li>Provide helper traits so the logical planner can lower AST nodes without duplicating
syntax checks.</li>
</ul>
<hr>
<h2 id="directory-layout"><a class="header" href="#directory-layout">Directory Layout</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Path</th><th>Purpose</th><th>Key Types</th></tr>
</thead>
<tbody>
<tr><td><code>lexer.rs</code></td><td>Token helpers that preserve offsets.</td><td><code>Token</code>, <code>TokenExt</code></td></tr>
<tr><td><code>parser.rs</code></td><td>Single entry point used across the codebase.</td><td><code>parse_sql</code>, <code>SqlInput</code></td></tr>
<tr><td><code>ast/mod.rs</code></td><td>Planner-facing helpers.</td><td><code>NormalizedIdent</code>, <code>ObjectNameExt</code></td></tr>
<tr><td><code>error.rs</code></td><td>Span-aware parser errors.</td><td><code>SqlError</code>, <code>SqlSpan</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="parsing-pipeline"><a class="header" href="#parsing-pipeline">Parsing Pipeline</a></h2>
<ol>
<li><strong>Lexing</strong> – wrap sqlparser’s lexer so every token keeps start/end offsets.</li>
<li><strong>AST generation</strong> – invoke sqlparser to produce standard <code>Statement</code> structs.</li>
<li><strong>Normalisation</strong> – convert identifiers into <code>NormalizedIdent</code>, deal with schema
qualifiers, and build pieces of <code>TableReference</code>.</li>
<li><strong>Planner bridge</strong> – traits like <code>ColumnRefExt</code> expose methods such as <code>relation()</code> or
<code>column()</code> so <code>LogicalPlanner</code> can treat different SQL syntaxes uniformly.</li>
</ol>
<hr>
<h2 id="interactions"><a class="header" href="#interactions">Interactions</a></h2>
<ul>
<li><strong>Logical planner</strong> consumes the AST directly and relies on helper traits from this
module to convert identifiers into catalog references.</li>
<li><strong>Database / Session</strong> catch <code>SqlError</code> values, so both CLI and HTTP front-ends show
consistent caret diagnostics.</li>
<li><strong>Tests</strong> (<code>tests/sql_example/*.slt</code>, <code>tests/sql_parser.rs</code>) assert on parser output and
error strings to keep teaching feedback stable.</li>
</ul>
<hr>
<h2 id="implementation-notes"><a class="header" href="#implementation-notes">Implementation Notes</a></h2>
<ul>
<li><code>SqlSpan</code> stores byte offsets, which makes it trivial to slice the original SQL and
render highlighted errors.</li>
<li>Extended statements (e.g., <code>EXPLAIN</code>, <code>BEGIN TRANSACTION</code>) show how to Layer
Quill-specific syntax without forking sqlparser entirely.</li>
<li>We avoid desugaring at this stage so students can trace SQL → AST → logical plan step
by step.</li>
</ul>
<hr>
<h2 id="teaching-ideas"><a class="header" href="#teaching-ideas">Teaching Ideas</a></h2>
<ul>
<li>Add a new statement (<code>CREATE VIEW</code>, <code>ALTER TABLE ...</code>) and follow the AST through the
pipeline.</li>
<li>Improve error hints (“Did you forget FROM?”) to see how better diagnostics aid users.</li>
<li>Write fuzz tests that round-trip SQL → AST → SQL to discuss parser determinism.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="catalog-module"><a class="header" href="#catalog-module">Catalog Module</a></h1>
<p><code>src/catalog/</code> acts as QuillSQL’s data dictionary. It tracks schema/table/index metadata,
statistics, and the mapping between logical names and physical storage objects such as
<code>TableHeap</code> and <code>BPlusTreeIndex</code>. Every layer—planner, execution, background workers—uses
the catalog to discover structure.</p>
<hr>
<h2 id="responsibilities-1"><a class="header" href="#responsibilities-1">Responsibilities</a></h2>
<ul>
<li>Persist definitions for schemas, tables, columns, indexes, and constraints.</li>
<li>Map logical <code>TableReference</code>s to physical handles (heap files, index roots, file ids).</li>
<li>Store table statistics (row counts, histograms) that drive ANALYZE and optimization.</li>
<li>Manage the DDL lifecycle: creation and deletion update the in-memory registry and the
on-disk metadata pages.</li>
</ul>
<hr>
<h2 id="directory-layout-1"><a class="header" href="#directory-layout-1">Directory Layout</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Path</th><th>Description</th><th>Key Types</th></tr>
</thead>
<tbody>
<tr><td><code>mod.rs</code></td><td>Public API surface.</td><td><code>Catalog</code>, <code>TableHandleRef</code></td></tr>
<tr><td><code>schema.rs</code></td><td>Schema objects and table references.</td><td><code>Schema</code>, <code>Column</code>, <code>TableReference</code></td></tr>
<tr><td><code>registry/</code></td><td>Thread-safe registry for heaps (MVCC vacuum).</td><td><code>TableRegistry</code></td></tr>
<tr><td><code>statistics.rs</code></td><td>ANALYZE output and helpers.</td><td><code>TableStatistics</code></td></tr>
<tr><td><code>loader.rs</code></td><td>Boot-time metadata loader.</td><td><code>load_catalog_data</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="tablereference"><a class="header" href="#tablereference">TableReference</a></h3>
<p>Unified identifier (database, schema, table). Logical planner, execution, and transaction
code all use it when requesting handles from the catalog.</p>
<h3 id="registries"><a class="header" href="#registries">Registries</a></h3>
<p><code>TableRegistry</code> maps internal IDs to <code>Arc&lt;TableHeap&gt;</code> plus logical names. It is used by
the MVCC vacuum worker to iterate user tables without poking directly into catalog data.</p>
<h3 id="schema--column"><a class="header" href="#schema--column">Schema &amp; Column</a></h3>
<p><code>Schema</code> stores column definitions (type, default, nullability). Execution uses it when
materialising tuples; the planner uses it to check expression types. <code>Schema::project</code>
helps physical operators build projected outputs.</p>
<h3 id="tablestatistics"><a class="header" href="#tablestatistics">TableStatistics</a></h3>
<p><code>ANALYZE</code> writes row counts and histograms into the catalog. Optimizer rules and planner
heuristics can consult these stats when deciding whether to push filters or pick indexes.
Each column tracks null/non-null counts, min/max values, and a sample-based distinct
estimate, enabling DuckDB-style selectivity heuristics (<code>1/distinct</code>, uniform ranges).</p>
<hr>
<h2 id="interactions-1"><a class="header" href="#interactions-1">Interactions</a></h2>
<ul>
<li><strong>SQL / Planner</strong> – DDL planning calls <code>Catalog::create_table</code> / <code>create_index</code>; name
binding relies on <code>Schema</code>.</li>
<li><strong>Execution</strong> – <code>ExecutionContext::table_handle</code> and <code>index_handle</code> fetch physical
handles through the catalog, so scans never hard-code heap locations.</li>
<li><strong>Background workers</strong> – MVCC and index vacuum iterate the registries via <code>Arc</code> clones.</li>
<li><strong>Recovery</strong> – <code>load_catalog_data</code> rebuilds the in-memory catalog from control files and
metadata pages during startup.</li>
</ul>
<hr>
<h2 id="teaching-ideas-1"><a class="header" href="#teaching-ideas-1">Teaching Ideas</a></h2>
<ul>
<li>Extend the schema system with hidden or computed columns and teach the catalog to store
the extra metadata.</li>
<li>Add histogram bins to <code>TableStatistics</code> and demonstrate how a simple cost heuristic can
choose better plans.</li>
<li>Turn on <code>RUST_LOG=catalog=debug</code> to observe how DDL mutates the registries.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="expression--scalar-evaluation"><a class="header" href="#expression--scalar-evaluation">Expression &amp; Scalar Evaluation</a></h1>
<p>The expression subsystem (<code>src/expression/</code>) powers column computations, predicates, and
UPDATE assignments. It keeps expression trees approachable while demonstrating how they
are evaluated during execution.</p>
<hr>
<h2 id="responsibilities-2"><a class="header" href="#responsibilities-2">Responsibilities</a></h2>
<ul>
<li>Store planner-produced expression trees (<code>Expr</code>) in a serializable, traversable enum.</li>
<li>Bind column references, constants, and built-in functions.</li>
<li>Evaluate expressions against <code>Tuple</code>s at runtime, yielding <code>ScalarValue</code>.</li>
<li>Provide type inference and casting so arithmetic/comparison operators remain well-typed.</li>
</ul>
<hr>
<h2 id="directory-layout-2"><a class="header" href="#directory-layout-2">Directory Layout</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Path</th><th>Description</th><th>Key Types</th></tr>
</thead>
<tbody>
<tr><td><code>mod.rs</code></td><td>Public API and core enum.</td><td><code>Expr</code>, <code>ExprTrait</code></td></tr>
<tr><td><code>scalar.rs</code></td><td>Runtime scalar representation + conversions.</td><td><code>ScalarValue</code>, <code>DataType</code></td></tr>
<tr><td><code>binder.rs</code></td><td>Helpers for the planner/SQL binder.</td><td><code>BoundExpr</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="concepts"><a class="header" href="#concepts">Concepts</a></h2>
<h3 id="expr-enum"><a class="header" href="#expr-enum">Expr Enum</a></h3>
<p>Expresses column refs, literals, comparisons, logical ops, arithmetic, and function
invocations. Each variant implements <code>ExprTrait::evaluate(&amp;self, tuple)</code> and returns a
<code>ScalarValue</code>.</p>
<h3 id="scalarvalue"><a class="header" href="#scalarvalue">ScalarValue</a></h3>
<p>Unified runtime value across types (int, bigint, bool, decimal, varchar, …). Includes
<code>cast_to(DataType)</code> so results can be coerced to the target column type before writes.</p>
<h3 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h3>
<p>Planner code invokes <code>Expr::data_type(schema)</code> to predict result types. Execution then
casts when needed—e.g., <code>UPDATE t SET a = b + 1</code> uses the column’s declared type for <code>a</code>.</p>
<hr>
<h2 id="interactions-2"><a class="header" href="#interactions-2">Interactions</a></h2>
<ul>
<li><strong>Planner</strong> – builds <code>Expr</code> trees with bound columns; execution reuses them verbatim.</li>
<li><strong>ExecutionContext</strong> – exposes <code>eval_expr</code> and <code>eval_predicate</code>, wrapping expression
evaluation plus boolean coercion (<code>NULL</code> becomes false for predicates).</li>
<li><strong>Optimizer</strong> – rules like constant folding traverse <code>Expr</code> trees and reuse
<code>ScalarValue</code> arithmetic helpers.</li>
</ul>
<hr>
<h2 id="teaching-ideas-2"><a class="header" href="#teaching-ideas-2">Teaching Ideas</a></h2>
<ul>
<li>Add a simple built-in function (<code>length(expr)</code>) to follow the pipeline from parsing to
evaluation.</li>
<li>Implement short-circuiting or full three-valued boolean logic and validate with
sqllogictest.</li>
<li>Instrument <code>Expr::evaluate</code> with tracing to visualise expression evaluation inside
physical operators.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="query-planner-module"><a class="header" href="#query-planner-module">Query Planner Module</a></h1>
<p><code>src/plan/</code> bridges parsed SQL and executable operators. It converts the AST into a
logical plan, applies rewrites (via the optimizer), and finally emits a physical plan
(<code>PhysicalPlan</code>) that the Volcano engine can run.</p>
<hr>
<h2 id="responsibilities-3"><a class="header" href="#responsibilities-3">Responsibilities</a></h2>
<ol>
<li><strong>LogicalPlanner</strong> – walks the AST, binds table/column names using <code>PlannerContext</code>,
performs type checking, and builds a <code>LogicalPlan</code> tree.</li>
<li><strong>PlannerContext</strong> – exposes catalog lookups plus scope information for CTEs, subqueries,
and aliases.</li>
<li><strong>PhysicalPlanner</strong> – lowers an optimized <code>LogicalPlan</code> into a tree of Volcano operators.</li>
</ol>
<hr>
<h2 id="directory-layout-3"><a class="header" href="#directory-layout-3">Directory Layout</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Path</th><th>Description</th><th>Key Types</th></tr>
</thead>
<tbody>
<tr><td><code>logical_plan.rs</code></td><td>Logical algebra nodes.</td><td><code>LogicalPlan</code>, <code>LogicalExpr</code>, <code>JoinType</code></td></tr>
<tr><td><code>logical_planner.rs</code></td><td>AST → logical transformation.</td><td><code>LogicalPlanner</code></td></tr>
<tr><td><code>physical_plan.rs</code></td><td><code>PhysicalPlan</code> enum definition.</td><td><code>PhysicalPlan</code>, <code>Physical*</code> structs</td></tr>
<tr><td><code>physical_planner.rs</code></td><td>Logical → physical lowering.</td><td><code>PhysicalPlanner</code></td></tr>
<tr><td><code>planner_context.rs</code></td><td>Catalog/scope abstraction.</td><td><code>PlannerContext</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="workflow"><a class="header" href="#workflow">Workflow</a></h2>
<ol>
<li><strong>Name binding</strong> – <code>LogicalPlanner</code> resolves table + column references, creates
<code>TableReference</code>s, and validates schemas via the catalog.</li>
<li><strong>Logical tree</strong> – each SQL clause becomes a logical node (FROM → <code>SeqScan</code>, WHERE →
<code>Filter</code>, GROUP BY → <code>Aggregate</code>, etc.).</li>
<li><strong>Physical selection</strong> – <code>PhysicalPlanner</code> picks concrete algorithms (sequential scan,
index scan, nested-loop join, sort, limit …). Because every physical node implements
<code>VolcanoExecutor</code>, the execution engine can pull tuples immediately.</li>
</ol>
<hr>
<h2 id="interactions-3"><a class="header" href="#interactions-3">Interactions</a></h2>
<ul>
<li><strong>SQL front-end</strong> – provides the AST; helper traits (<code>NormalizedIdent</code>, etc.) keep name
resolution consistent.</li>
<li><strong>Catalog</strong> – <code>PlannerContext</code> relies on it to confirm table/index existence and fetch
schemas.</li>
<li><strong>Optimizer</strong> – operates purely on <code>LogicalPlan</code>; the planner must emit clean,
traversable trees so rules can fire.</li>
<li><strong>Execution</strong> – physical nodes carry <code>TableReference</code>, <code>SchemaRef</code>, and hints that the
execution engine passes to the storage layer.</li>
</ul>
<hr>
<h2 id="teaching-ideas-3"><a class="header" href="#teaching-ideas-3">Teaching Ideas</a></h2>
<ul>
<li>Implement a new logical operator (e.g., <code>LogicalDistinct</code>) and add the corresponding
physical operator to trace the full lifecycle.</li>
<li>Experiment with early projection inside the logical plan and observe its impact on
downstream operators.</li>
<li>Use <code>pretty_format_logical_plan</code>/<code>physical_plan</code> dumps to visualise rewrites before and
after optimizer passes.</li>
</ul>
<hr>
<p>Further reading: <a href="#the-lifecycle-of-a-query">The Lifecycle of a Query</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-lifecycle-of-a-query"><a class="header" href="#the-lifecycle-of-a-query">The Lifecycle of a Query</a></h1>
<p>When you submit a SQL query to a database, it doesn’t just magically produce a result. The database undertakes a sophisticated, multi-stage process to translate the declarative SQL statement (which describes <em>what</em> data you want) into an imperative, efficient execution plan (which describes <em>how</em> to get that data). This entire process is the responsibility of the <strong>Query Planner</strong>.</p>
<p>In QuillSQL, this process follows a classic, compiler-like pipeline, which is a cornerstone of modern database architecture as taught in courses like CMU 15-445.</p>
<p>The journey from a SQL string to an executable plan involves several transformations:</p>
<p><strong>SQL String</strong> -&gt; <strong>AST (Abstract Syntax Tree)</strong> -&gt; <strong>Logical Plan</strong> -&gt; <strong>Optimized Logical Plan</strong> -&gt; <strong>Physical Plan</strong></p>
<p>Let’s break down each stage.</p>
<h3 id="stage-1-parsing-sql---ast"><a class="header" href="#stage-1-parsing-sql---ast">Stage 1: Parsing (SQL -&gt; AST)</a></h3>
<p>The first step is purely syntactic. The raw SQL query string is fed into a parser. QuillSQL uses the excellent <code>sqlparser</code> crate for this. The parser checks if the SQL conforms to valid grammar and, if so, converts it into an <strong>Abstract Syntax Tree (AST)</strong>.</p>
<p>An AST is a direct tree representation of the SQL query’s structure. For example, <code>SELECT id FROM users WHERE age &gt; 30</code> would be parsed into a tree structure with nodes representing the <code>SELECT</code> clause, the table <code>users</code>, the <code>WHERE</code> clause, and the predicate <code>age &gt; 30</code>.</p>
<h3 id="stage-2-logical-planning-ast---logical-plan"><a class="header" href="#stage-2-logical-planning-ast---logical-plan">Stage 2: Logical Planning (AST -&gt; Logical Plan)</a></h3>
<p>Next, the <code>LogicalPlanner</code> (<code>plan/logical_planner.rs</code>) walks the AST and converts it into a <strong>Logical Plan</strong>.</p>
<p>A Logical Plan is a tree of relational algebra operators. It describes the query in terms of high-level data operations, completely independent of how the data is stored or which algorithms will be used. It defines <em>what</em> to do, not <em>how</em> to do it.</p>
<p>Key logical operators in QuillSQL (<code>plan/logical_plan/mod.rs</code>) include:</p>
<ul>
<li><strong><code>TableScan(users)</code></strong>: Represents reading the entire <code>users</code> table.</li>
<li><strong><code>Filter(predicate: age &gt; 30)</code></strong>: Represents filtering rows based on a condition.</li>
<li><strong><code>Projection(columns: [id])</code></strong>: Represents selecting specific columns.</li>
<li><strong><code>Join</code></strong>: Represents joining two data sources.</li>
<li><strong><code>Aggregate</code></strong>: Represents a <code>GROUP BY</code> operation.</li>
<li><strong><code>Sort</code></strong>: Represents an <code>ORDER BY</code> operation.</li>
</ul>
<p>For our example query, the initial logical plan might look like this:</p>
<pre><code>Projection(columns=[id])
  └── Filter(predicate=age &gt; 30)
        └── TableScan(users)
</code></pre>
<h3 id="stage-3-logical-optimization"><a class="header" href="#stage-3-logical-optimization">Stage 3: Logical Optimization</a></h3>
<p>Before executing the plan, we have a crucial opportunity to make it more efficient. The <code>LogicalOptimizer</code> (<code>optimizer/logical_optimizer.rs</code>) takes the logical plan and applies a series of <strong>transformation rules</strong> to produce a new, equivalent logical plan that is expected to be faster.</p>
<p>QuillSQL uses a simple but effective rule-based optimizer. A classic example of such a rule is <strong>Predicate Pushdown</strong>. Consider this query:</p>
<p><code>SELECT name FROM (SELECT * FROM users JOIN cities ON users.city_id = cities.id) WHERE users.age &gt; 30;</code></p>
<p>A naive logical plan would first perform a full <code>JOIN</code> between <code>users</code> and <code>cities</code> and <em>then</em> filter the massive result. Predicate pushdown is a rule that would rewrite the plan to apply the <code>age &gt; 30</code> filter <em>before</em> the join:</p>
<p><strong>Before Optimization:</strong></p>
<pre><code>Filter(users.age &gt; 30)
  └── Join(users.city_id = cities.id)
        ├── TableScan(users)
        └── TableScan(cities)
</code></pre>
<p><strong>After Optimization (Predicate Pushdown):</strong></p>
<pre><code>Join(users.city_id = cities.id)
  ├── Filter(users.age &gt; 30)
  │     └── TableScan(users)
  └── TableScan(cities)
</code></pre>
<p>By filtering early, we dramatically reduce the number of rows that need to be processed by the expensive <code>Join</code> operator. QuillSQL implements similar rules, such as <code>PushDownLimit</code>, which pushes <code>LIMIT</code> clauses down the tree to reduce the amount of data processed.</p>
<h3 id="stage-4-physical-planning-logical-plan---physical-plan"><a class="header" href="#stage-4-physical-planning-logical-plan---physical-plan">Stage 4: Physical Planning (Logical Plan -&gt; Physical Plan)</a></h3>
<p>Finally, the <code>PhysicalPlanner</code> (<code>plan/physical_planner.rs</code>) converts the optimized logical plan into a <strong>Physical Plan</strong>.</p>
<p>A Physical Plan describes exactly <em>how</em> the query will be executed. It maps each logical operator to a concrete algorithm or implementation.</p>
<ul>
<li>A <code>LogicalPlan::TableScan</code> becomes a <code>PhysicalSeqScan</code> (a sequential scan of the table heap).</li>
<li>A <code>LogicalPlan::Filter</code> becomes a <code>PhysicalFilter</code>, which implements the filtering logic.</li>
<li>A <code>LogicalPlan::Join</code> becomes a <code>PhysicalNestedLoopJoin</code>. This is where the database commits to a specific join algorithm. A more advanced database might have multiple options (e.g., <code>PhysicalHashJoin</code>, <code>PhysicalSortMergeJoin</code>) and would use a cost model to choose the best one. QuillSQL currently implements Nested Loop Join.</li>
</ul>
<p>Each node in the physical plan tree is an executor that the <a href="#execution-engine">Execution Engine</a> can run. This final plan is what gets executed to produce the query result.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This layered approach—from syntax to a logical representation, then to an optimized logical representation, and finally to a concrete physical execution plan—is fundamental to database design. It provides a clear separation of concerns and, most importantly, creates a dedicated <strong>optimization stage</strong>, which is the key to achieving high performance on a wide variety of SQL queries.</p>
<hr>
<h2 id="for-study--discussion"><a class="header" href="#for-study--discussion">For Study &amp; Discussion</a></h2>
<ol>
<li>
<p><strong>Logical vs. Physical</strong>: Why is the separation between logical and physical plans so important? What would be the disadvantages of a simpler system that converted the AST directly into a physical plan?</p>
</li>
<li>
<p><strong>Join Algorithms</strong>: QuillSQL currently only implements <code>NestedLoopJoin</code>. What are two other common join algorithms? Describe how they work and in what scenarios they would be more performant than a nested loop join.</p>
</li>
<li>
<p><strong>Programming Exercise (Advanced)</strong>: Implement a <code>PhysicalHashJoin</code> operator. This is a significant undertaking that involves:
a.  Creating a <code>PhysicalHashJoin</code> struct that implements the <code>VolcanoExecutor</code> trait.
b.  In the <code>init()</code> phase, it should consume the entire “build” side (typically the smaller, right-hand table) and build an in-memory hash table from its rows.
c.  In the <code>next()</code> phase, it should read from the “probe” side (the left-hand table) one row at a time, probe the hash table for matches, and emit the joined tuples.
d.  Modify the <code>PhysicalPlanner</code> to choose <code>PhysicalHashJoin</code> instead of <code>PhysicalNestedLoopJoin</code> for equi-joins.</p>
</li>
<li>
<p><strong>Programming Exercise</strong>: Add support for the <code>UNION ALL</code> operator. This would involve:
a.  Adding a <code>Union</code> variant to the <code>LogicalPlan</code> enum.
b.  Updating the <code>LogicalPlanner</code> to recognize the <code>UNION</code> syntax in the AST and create a <code>LogicalPlan::Union</code> node.
c.  Creating a <code>PhysicalUnion</code> executor that pulls tuples from its first child until it’s exhausted, and then pulls tuples from its second child.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="optimizer-module"><a class="header" href="#optimizer-module">Optimizer Module</a></h1>
<p><code>src/optimizer/</code> contains a lightweight, teaching-friendly rule engine. It rewrites
<code>LogicalPlan</code> trees into cheaper equivalents without requiring a full cost-based
framework.</p>
<hr>
<h2 id="responsibilities-4"><a class="header" href="#responsibilities-4">Responsibilities</a></h2>
<ul>
<li>Define the <code>OptimizerRule</code> trait (“match → rewrite”).</li>
<li>Ship built-in rules such as predicate pushdown, projection pruning, and limit pushdown.</li>
<li>Provide a pipeline (<code>LogicalOptimizer</code>) that repeatedly applies rules until reaching a
fixpoint, while remaining extensible for future cost models.</li>
</ul>
<hr>
<h2 id="directory-layout-4"><a class="header" href="#directory-layout-4">Directory Layout</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Path</th><th>Description</th><th>Key Types</th></tr>
</thead>
<tbody>
<tr><td><code>mod.rs</code></td><td>Optimizer entry point.</td><td><code>LogicalOptimizer</code></td></tr>
<tr><td><code>rule.rs</code></td><td>Trait + shared helpers.</td><td><code>OptimizerRule</code></td></tr>
<tr><td><code>rules/*</code></td><td>Concrete rewrites.</td><td><code>PushDownFilter</code>, <code>PushDownLimit</code>, …</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<ol>
<li><code>LogicalOptimizer::optimize(plan)</code> iterates through the registered rule list.</li>
<li>Each rule implements <code>fn apply(&amp;LogicalPlan) -&gt; Option&lt;LogicalPlan&gt;</code>. Returning <code>Some</code>
means the rule fired; the pipeline restarts to reach a fixpoint.</li>
<li>Rules are pure functions, which keeps them easy to unit test and reason about.</li>
</ol>
<p>Examples:</p>
<ul>
<li><strong>PushDownFilter</strong> moves filters below scans/joins to reduce input size sooner.</li>
<li><strong>PushDownLimit</strong> applies LIMIT before expensive joins/sorts when safe.</li>
<li><strong>PruneProjection</strong> removes unused columns so execution/storage decode less data.</li>
</ul>
<h3 id="extending-with-statistics"><a class="header" href="#extending-with-statistics">Extending With Statistics</a></h3>
<p>The optimizer intentionally remains heuristics-only, and the physical planner sticks to
simple sequential scans. For coursework, students can still read <code>TableStatistics</code> from
the catalog to prototype their own cardinality estimates or cost heuristics (e.g., to
experiment with when to prefer an index scan), but no estimator ships in-tree.</p>
<hr>
<h2 id="interactions-4"><a class="header" href="#interactions-4">Interactions</a></h2>
<ul>
<li><strong>LogicalPlan</strong> – the optimizer only sees logical nodes; physical/storage layers remain
untouched.</li>
<li><strong>Catalog / Statistics</strong> – current rules are heuristic, but <code>TableStatistics</code> remains
available for students who want to prototype their own cost-based decisions.</li>
<li><strong>Execution</strong> – leaner logical plans translate into simpler physical plans (e.g.,
predicate pushdown allows <code>PhysicalSeqScan</code> to discard rows earlier).</li>
</ul>
<hr>
<h2 id="teaching-ideas-4"><a class="header" href="#teaching-ideas-4">Teaching Ideas</a></h2>
<ul>
<li>Implement a new rule (join reordering, constant folding) and use <code>RUST_LOG=trace</code> to
compare plan dumps before/after.</li>
<li>Discuss pipeline ordering—swap rule order and observe different outcomes.</li>
<li>Prototype a tiny cost estimator using row counts from <code>TableStatistics</code> to decide on
index scans vs sequential scans.</li>
</ul>
<hr>
<p>Further reading: <a href="#rule-based-optimization">Rule-Based Optimization</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rule-based-optimization"><a class="header" href="#rule-based-optimization">Rule-Based Optimization</a></h1>
<p>After the <code>LogicalPlanner</code> creates an initial <code>LogicalPlan</code>, it’s passed to the <strong><code>LogicalOptimizer</code></strong>. The initial plan is a direct, syntactically correct translation of the SQL query, but it’s often not the most efficient way to execute it. The optimizer’s job is to transform this plan into an equivalent, but more performant, logical plan.</p>
<h2 id="the-optimizer-in-quillsql"><a class="header" href="#the-optimizer-in-quillsql">The Optimizer in QuillSQL</a></h2>
<p>QuillSQL implements a <strong>Rule-Based Optimizer</strong>. This is a common and powerful approach where the optimizer is equipped with a set of predefined transformation rules. It repeatedly applies these rules to the logical plan tree until no more rules can be applied, or a maximum number of passes is reached.</p>
<p>The main components are:</p>
<ul>
<li><strong><code>LogicalOptimizer</code> (<code>optimizer/logical_optimizer.rs</code>)</strong>: The main driver. It holds a list of rules and contains the logic to recursively walk the plan tree and apply them.</li>
<li><strong><code>LogicalOptimizerRule</code> Trait</strong>: An interface that every optimization rule must implement. Its core method is <code>try_optimize</code>, which takes a plan node and attempts to return a rewritten, optimized version of that node.</li>
</ul>
<h2 id="deep-dive-the-pushdownlimit-rule"><a class="header" href="#deep-dive-the-pushdownlimit-rule">Deep Dive: The <code>PushDownLimit</code> Rule</a></h2>
<p>One of the most classic and effective optimizations is “pushing down” operations as far as possible towards the data source. Let’s examine the <code>PushDownLimit</code> rule (<code>optimizer/rule/push_down_limit.rs</code>) to see this in action.</p>
<p>Consider the following query:</p>
<pre><code class="language-sql">SELECT * FROM users ORDER BY signup_date LIMIT 10;
</code></pre>
<h4 id="the-naive-plan"><a class="header" href="#the-naive-plan">The Naive Plan</a></h4>
<p>A naive logical plan for this query would be:</p>
<pre><code>Limit(10)
  └── Sort(by: signup_date)
        └── TableScan(users)
</code></pre>
<p>If executed directly, this plan would:</p>
<ol>
<li>Scan the <em>entire</em> <code>users</code> table.</li>
<li>Sort the <em>entire</em> table by <code>signup_date</code>.</li>
<li>Finally, discard all but the first 10 rows.</li>
</ol>
<p>This is incredibly inefficient, especially for a large table, as it involves a massive, memory-intensive sort operation.</p>
<h4 id="the-optimization-rule"><a class="header" href="#the-optimization-rule">The Optimization Rule</a></h4>
<p>The <code>PushDownLimit</code> rule is designed to recognize this specific pattern: a <code>Limit</code> operator directly on top of a <code>Sort</code> operator.</p>
<p>When the optimizer applies this rule, the <code>try_optimize</code> method matches on the <code>Limit</code> node. It inspects its child and sees that it’s a <code>Sort</code> node. The rule then knows it can apply its logic.</p>
<h4 id="the-rewritten-plan"><a class="header" href="#the-rewritten-plan">The Rewritten Plan</a></h4>
<p>The rule rewrites the plan tree by “pushing” the limit information <em>into</em> the <code>Sort</code> node itself:</p>
<pre><code>Limit(10)
  └── Sort(by: signup_date, limit: 10)
        └── TableScan(users)
</code></pre>
<p>Notice the new <code>limit: 10</code> property on the <code>Sort</code> node. This seemingly small change has a huge performance impact. When the <code>PhysicalSort</code> operator is created from this logical node, it now knows that it only needs to find the top 10 rows. Instead of performing a full sort, it can use a much more efficient algorithm, like a <strong>heap sort (using a min-heap of size 10)</strong>, to find the top 10 rows in a single pass over the data.</p>
<p>This optimization avoids sorting the entire table, dramatically reducing both CPU and memory consumption.</p>
<h2 id="other-rules"><a class="header" href="#other-rules">Other Rules</a></h2>
<p>QuillSQL implements other simple but effective rules:</p>
<ul>
<li><strong><code>EliminateLimit</code></strong>: Removes a <code>LIMIT</code> clause if it provides no value (e.g., <code>LIMIT NULL</code>).</li>
<li><strong><code>MergeLimit</code></strong>: If two <code>LIMIT</code> clauses are stacked on top of each other (which can happen after other rule transformations), this rule merges them into a single, more restrictive <code>LIMIT</code>.</li>
</ul>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>While QuillSQL’s optimizer is currently rule-based and relatively simple, it demonstrates the fundamental principles of query optimization. By separating the logical representation of a query from its physical execution and applying equivalence-preserving transformations, a database can achieve massive performance gains. More advanced systems build on this with a <strong>Cost-Based Optimizer</strong>, which uses table statistics to estimate the “cost” of different physical plans (e.g., choosing between a <code>NestedLoopJoin</code> and a <code>HashJoin</code>) and pick the cheapest one.</p>
<hr>
<h2 id="for-study--discussion-1"><a class="header" href="#for-study--discussion-1">For Study &amp; Discussion</a></h2>
<ol>
<li>
<p><strong>Rule Ordering</strong>: The <code>LogicalOptimizer</code> applies its list of rules in a fixed order for a set number of passes. Can the order in which rules are applied affect the final, optimized plan? Can one rule’s transformation enable another rule to be applied in a subsequent pass?</p>
</li>
<li>
<p><strong>Cost-Based vs. Rule-Based</strong>: What is the primary limitation of a purely rule-based optimizer? When would a rule-based optimizer make a poor decision that a cost-based optimizer (with accurate statistics) would get right? (Hint: consider join algorithm selection).</p>
</li>
<li>
<p><strong>Programming Exercise</strong>: Implement the classic <strong>Predicate Pushdown</strong> rule. Your rule should look for a <code>Filter</code> operator whose child is a <code>Join</code>. If the filter’s predicate only uses columns from one side of the join, the rule should push the <code>Filter</code> node down to that side of the join, below the <code>Join</code> node. This is one of the most effective optimizations in any database.</p>
</li>
<li>
<p><strong>Programming Exercise</strong>: Implement a <strong>Constant Folding</strong> rule. This rule would traverse expression trees and pre-compute constant expressions. For example:</p>
<ul>
<li>An expression <code>WHERE age = 10 + 5</code> would be rewritten to <code>WHERE age = 15</code>.</li>
<li>An expression <code>WHERE 1 = 1</code> would be evaluated to <code>true</code>, and a smart optimizer could then potentially eliminate the <code>WHERE</code> clause entirely.</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="execution-engine"><a class="header" href="#execution-engine">Execution Engine</a></h1>
<p><code>src/execution/</code> drives <code>PhysicalPlan</code> trees using the Volcano (iterator) model. Every
operator pulls tuples from its children, coordinating closely with transactions,
storage, and expression evaluation.</p>
<hr>
<h2 id="core-components"><a class="header" href="#core-components">Core Components</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>Role</th></tr>
</thead>
<tbody>
<tr><td><code>PhysicalPlan</code></td><td>Enum covering all physical operators; each implements <code>VolcanoExecutor</code>.</td></tr>
<tr><td><code>ExecutionContext</code></td><td>Shared context carrying the catalog, <code>TxnContext</code>, storage engine, and expression helpers.</td></tr>
<tr><td><code>TupleStream</code></td><td>Unified scan interface returned by table/index handles.</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="execution-flow"><a class="header" href="#execution-flow">Execution Flow</a></h2>
<ol>
<li><code>ExecutionEngine::execute</code> calls <code>init</code> on the root plan (and recursively on children).</li>
<li>The engine loops calling <code>next</code>, with parents pulling tuples from children.</li>
<li><code>ExecutionContext</code> supplies transaction snapshots, lock helpers, and expression
evaluation per call.</li>
<li>Once <code>next</code> returns <code>None</code>, the accumulated results are returned to the caller (CLI,
HTTP API, or tests).</li>
</ol>
<hr>
<h2 id="operator-examples"><a class="header" href="#operator-examples">Operator Examples</a></h2>
<ul>
<li><strong>PhysicalSeqScan</strong> – acquires a <code>table_stream</code> from the storage engine, uses
<code>ScanPrefetch</code> for batching, and relies on <code>TxnContext::read_visible_tuple</code> for MVCC.</li>
<li><strong>PhysicalIndexScan</strong> – uses <code>index_stream</code>, tracks <code>invisible_hits</code>, and notifies the
catalog when garbage accumulates.</li>
<li><strong>PhysicalUpdate/PhysicalDelete</strong> – call <code>prepare_row_for_write</code> to re-validate locks
and the latest tuple before invoking <code>apply_update/delete</code>.</li>
<li><strong>PhysicalNestedLoopJoin</strong> – showcases the parent/child pull loop and acts as a baseline
for more advanced joins.</li>
</ul>
<hr>
<h2 id="interactions-5"><a class="header" href="#interactions-5">Interactions</a></h2>
<ul>
<li><strong>StorageEngine</strong> – all data access goes through handles/streams, keeping execution
storage-agnostic.</li>
<li><strong>Transaction</strong> – <code>TxnContext</code> enforces locking, snapshots, and undo logging; operators
never talk to <code>LockManager</code> directly.</li>
<li><strong>Expression</strong> – <code>ExecutionContext::eval_expr</code> / <code>eval_predicate</code> evaluate expressions
built by the planner.</li>
<li><strong>Optimizer/Planner</strong> – execution honours the plan as-is; all structural choices happen
upstream.</li>
</ul>
<hr>
<h2 id="teaching-ideas-5"><a class="header" href="#teaching-ideas-5">Teaching Ideas</a></h2>
<ul>
<li>Implement a new operator (e.g., <code>PhysicalMergeJoin</code>) to see how <code>ExecutionContext</code>
support generalises.</li>
<li>Add adaptive prefetching inside <code>PhysicalSeqScan</code> to explore iterator hints.</li>
<li>Enable <code>RUST_LOG=execution=trace</code> to watch the <code>init</code>/<code>next</code> call sequence during a
query.</li>
</ul>
<hr>
<p>Further reading: <a href="#the-volcano-execution-model">The Volcano Execution Model</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-volcano-execution-model"><a class="header" href="#the-volcano-execution-model">The Volcano Execution Model</a></h1>
<p>Once the <a href="#query-planner-module">Query Planner</a> has produced an optimized <code>PhysicalPlan</code>, it’s the job of the <strong>Execution Engine</strong> to run it and produce results. The execution engine is the component that brings the plan to life, interacting with the transaction manager and storage layer to process data.</p>
<p>QuillSQL uses the classic <strong>Volcano Model</strong>, also known as the <strong>Iterator Model</strong>. This is a pull-based execution model where each physical operator in the plan tree acts as an iterator that the parent operator can “pull” rows from.</p>
<h2 id="1-the-volcanoexecutor-trait"><a class="header" href="#1-the-volcanoexecutor-trait">1. The <code>VolcanoExecutor</code> Trait</a></h2>
<p>At the heart of the execution model is the <code>VolcanoExecutor</code> trait (<code>execution/mod.rs</code>). Every physical operator implements this simple trait:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait VolcanoExecutor {
    fn init(&amp;self, context: &amp;mut ExecutionContext) -&gt; QuillSQLResult&lt;()&gt;;
    fn next(&amp;self, context: &amp;mut ExecutionContext) -&gt; QuillSQLResult&lt;Option&lt;Tuple&gt;&gt;;
    fn output_schema(&amp;self) -&gt; SchemaRef;
}
<span class="boring">}</span></code></pre>
<ul>
<li><strong><code>init()</code></strong>: This method is called once at the beginning of execution. It allows an operator to set up its initial state (e.g., a <code>SeqScan</code> operator would initialize its table iterator here).</li>
<li><strong><code>next()</code></strong>: This is the core method. When called, the operator produces its next output tuple. It returns <code>Some(tuple)</code> if it has a row, or <code>None</code> if it has exhausted its data source. The top-level <code>ExecutionEngine</code> simply calls <code>next()</code> on the root of the plan tree in a loop until it receives <code>None</code>.</li>
</ul>
<h2 id="2-the-executioncontext"><a class="header" href="#2-the-executioncontext">2. The <code>ExecutionContext</code></a></h2>
<p>Notice that both <code>init()</code> and <code>next()</code> take a mutable <code>ExecutionContext</code>. This object is the “world” in which the query runs. It is passed down the operator tree and exposes:</p>
<ul>
<li><strong><code>Catalog</code> + <code>StorageEngine</code></strong>: Operators call <code>context.table(&amp;table_ref)</code> to obtain a <code>TableBinding</code>. The binding encapsulates heap/index access (scan, insert, delete, update, prepare-row-for-write) so operators never touch <code>TableHeap</code> or <code>MvccHeap</code> directly.</li>
<li><strong><code>TxnContext</code></strong>: Provides the current transaction, MVCC snapshot, and helper methods for row/table locks and visibility checks.</li>
<li><strong>Expression helpers</strong>: <code>eval_expr</code> / <code>eval_predicate</code> evaluate AST expressions against a tuple without leaking <code>ScalarValue</code> plumbing into operators.</li>
</ul>
<p>Thanks to the binding abstraction, the operator code only expresses “what” should happen (scan/update/delete) while the binding implements “how” (MVCC chain navigation, undo logging, index maintenance).</p>
<h2 id="3-anatomy-of-physical-operators"><a class="header" href="#3-anatomy-of-physical-operators">3. Anatomy of Physical Operators</a></h2>
<p>Data flows <em>up</em> the tree from the leaves (scans) to the root. Let’s see how it works by examining a few key operators.</p>
<h3 id="leaf-operator-physicalseqscan"><a class="header" href="#leaf-operator-physicalseqscan">Leaf Operator: <code>PhysicalSeqScan</code></a></h3>
<p>A sequential scan sits at the leaf of a plan tree and streams tuples from a table binding.</p>
<ul>
<li><strong><code>init()</code></strong>:
<ol>
<li>Acquires an <code>IntentionShared</code> lock on the table via <code>TxnContext</code>.</li>
<li>Requests a <code>TableBinding</code> (<code>context.table(&amp;table_ref)</code>) and calls <code>binding.scan(...)</code> to obtain a <code>TupleStream</code>. The binding hides the actual <code>TableIterator</code> implementation and any MVCC plumbing.</li>
</ol>
</li>
<li><strong><code>next()</code></strong>:
<ol>
<li>Pops the next <code>(rid, meta, tuple)</code> from its prefetch buffer (which in turn pulls from the binding’s stream).</li>
<li>Calls <code>TxnContext::read_visible_tuple</code> to perform the MVCC visibility check and acquire the required shared row lock.</li>
<li>Returns the tuple if visible; otherwise, keep looping.</li>
</ol>
</li>
</ul>
<h3 id="unary-operator-physicalfilter"><a class="header" href="#unary-operator-physicalfilter">Unary Operator: <code>PhysicalFilter</code></a></h3>
<p>A filter has one child operator (its <code>input</code>). It implements a <code>WHERE</code> clause.</p>
<ul>
<li><strong><code>next()</code></strong>: Its logic is a simple, tight loop:
<ol>
<li>It calls <code>self.input.next()</code> to get a tuple from its child.</li>
<li>If the child returns <code>None</code>, the filter is also exhausted and returns <code>None</code>.</li>
<li>If it receives a tuple, it evaluates its predicate expression (e.g., <code>age &gt; 30</code>) against the tuple.</li>
<li>If the predicate evaluates to <code>true</code>, it returns the tuple. Otherwise, it loops back to step 1.</li>
</ol>
</li>
</ul>
<h3 id="binary-operator-physicalnestedloopjoin"><a class="header" href="#binary-operator-physicalnestedloopjoin">Binary Operator: <code>PhysicalNestedLoopJoin</code></a></h3>
<p>A join has two children: a left (outer) and a right (inner).</p>
<ul>
<li><strong><code>next()</code></strong>: It implements the classic nested loop join algorithm:
<ol>
<li>Fetch one tuple from the <strong>outer</strong> (left) child and hold onto it.</li>
<li>Enter a loop: fetch tuples one by one from the <strong>inner</strong> (right) child.</li>
<li>For each inner tuple, combine it with the held outer tuple and evaluate the join condition. If it matches, return the combined tuple.</li>
<li>When the inner child is exhausted, <strong>rewind it</strong> by calling <code>self.right_input.init()</code> again.</li>
<li>Go back to step 1 to fetch the <em>next</em> tuple from the outer child.</li>
<li>Repeat until the outer child is also exhausted.</li>
</ol>
</li>
</ul>
<h2 id="4-putting-it-all-together"><a class="header" href="#4-putting-it-all-together">4. Putting It All Together</a></h2>
<p>Consider the query <code>SELECT name FROM users WHERE age &gt; 30</code>. The physical plan is <code>Projection -&gt; Filter -&gt; SeqScan</code>.</p>
<ol>
<li>The <code>ExecutionEngine</code> calls <code>next()</code> on the <code>Projection</code> operator.</li>
<li>The <code>Projection</code> operator needs a tuple, so it calls <code>next()</code> on its child, <code>Filter</code>.</li>
<li>The <code>Filter</code> operator needs a tuple, so it calls <code>next()</code> on its child, <code>SeqScan</code>.</li>
<li>The <code>SeqScan</code> operator asks its <code>TableBinding</code> for the next tuple, and after the MVCC check finds a visible tuple for a user with <code>age = 25</code>.</li>
<li><code>SeqScan</code> returns this tuple up to <code>Filter</code>.</li>
<li><code>Filter</code> evaluates <code>age &gt; 30</code> on the tuple. It’s false, so it loops, calling <code>SeqScan.next()</code> again.</li>
<li><code>SeqScan</code> pulls another visible tuple (this time <code>age = 40</code>, <code>name = 'Alice'</code>) through the binding.</li>
<li><code>SeqScan</code> returns this tuple up to <code>Filter</code>.</li>
<li><code>Filter</code> evaluates <code>age &gt; 30</code>. It’s true! It returns the tuple for Alice up to <code>Projection</code>.</li>
<li><code>Projection</code> takes the full tuple for Alice, creates a new tuple containing only the <code>name</code> column (<code>'Alice'</code>), and returns this new tuple as the result.</li>
</ol>
<p>This process repeats, with tuples flowing up the tree one at a time, until the <code>SeqScan</code> operator runs out of pages and returns <code>None</code>, which then propagates up the tree, signaling the end of execution.</p>
<hr>
<h2 id="for-study--discussion-2"><a class="header" href="#for-study--discussion-2">For Study &amp; Discussion</a></h2>
<ol>
<li>
<p><strong>Push vs. Pull Models</strong>: The Volcano model is a “pull-based” model. An alternative is a “push-based” model, where operators push their results to their parents as soon as they are ready. What are the potential advantages and disadvantages of each model, particularly concerning cache efficiency and control flow?</p>
</li>
<li>
<p><strong>Blocking vs. Non-Blocking Operators</strong>: Some operators, like <code>PhysicalFilter</code>, can produce their first output row as soon as they receive their first input row. These are <strong>non-blocking</strong>. Other operators, like <code>PhysicalSort</code>, must consume their <em>entire</em> input before they can produce even a single row of output. These are <strong>blocking</strong>. What is the impact of blocking operators on query latency and memory usage?</p>
</li>
<li>
<p><strong>Programming Exercise</strong>: The current <code>PhysicalNestedLoopJoin</code> is simple but can be inefficient as it re-scans the entire inner table for every outer row. Implement a <code>PhysicalBlockNestedLoopJoin</code> operator. This version would read a <em>block</em> (a small batch) of tuples from the outer table into an in-memory buffer, and then iterate through the inner table once for that entire block. This can significantly reduce the number of times the inner table needs to be scanned.</p>
</li>
<li>
<p><strong>Programming Exercise</strong>: Implement the <code>PhysicalLimit</code> operator. Its <code>next()</code> method should:
a.  Keep an internal counter.
b.  If the counter is less than the <code>offset</code>, pull and discard tuples from its child.
c.  If the counter is between <code>offset</code> and <code>offset + limit</code>, pull a tuple from its child and return it.
d.  Once the limit is reached, it should stop pulling from its child and return <code>None</code> for all subsequent calls. This is important for efficiency, as it stops the execution of the entire sub-tree below it.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="transaction-module"><a class="header" href="#transaction-module">Transaction Module</a></h1>
<p><code>src/transaction/</code> enforces the Atomicity and Isolation parts of ACID. It combines MVCC
with strict two-phase locking so reads and writes can proceed concurrently without
violating correctness.</p>
<hr>
<h2 id="main-components"><a class="header" href="#main-components">Main Components</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Role</th></tr>
</thead>
<tbody>
<tr><td><code>TransactionManager</code></td><td>Creates/commits/aborts transactions, assigns txn &amp; command ids, coordinates WAL.</td></tr>
<tr><td><code>Transaction</code></td><td>Stores state, held locks, undo chain, and cached snapshot.</td></tr>
<tr><td><code>TxnContext</code> / <code>TxnRuntime</code></td><td>Execution-time wrapper exposing MVCC + locking helpers.</td></tr>
<tr><td><code>LockManager</code></td><td>Multi-granularity locking (IS/IX/S/SIX/X) with deadlock detection.</td></tr>
<tr><td><code>TransactionSnapshot</code></td><td>Tracks <code>xmin/xmax/active_txns</code> for visibility checks.</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="workflow-1"><a class="header" href="#workflow-1">Workflow</a></h2>
<ol>
<li><code>SessionContext</code> calls <code>TransactionManager::begin</code> to create a transaction.</li>
<li>Each SQL statement builds a <code>TxnRuntime</code>, yielding a fresh command id and snapshot.</li>
<li>Operators call <code>TxnContext::lock_table/lock_row</code> to obey strict 2PL.</li>
<li><code>TableHandle::insert/delete/update</code> records undo, acquires locks, and emits WAL via
<code>TxnContext</code>.</li>
<li>Commit: write a <code>Commit</code> record → flush depending on <code>synchronous_commit</code> → release
locks.</li>
<li>Abort: walk the undo list, write CLRs, restore heap/index state, release locks.</li>
</ol>
<hr>
<h2 id="mvcc-details"><a class="header" href="#mvcc-details">MVCC Details</a></h2>
<ul>
<li><code>TupleMeta</code> stores inserting/deleting txn ids and command ids. <code>read_visible_tuple</code>
checks snapshots and, if needed, rewinds to the latest visible version.</li>
<li>Isolation levels:
<ul>
<li><strong>Read Uncommitted</strong> – minimal snapshot caching.</li>
<li><strong>Read Committed</strong> – refresh snapshot each command to avoid dirty reads.</li>
<li><strong>Repeatable Read / Serializable</strong> – capture the snapshot once; RR releases shared
locks at statement end, Serializable holds them to commit to avoid phantoms.</li>
</ul>
</li>
<li>UPDATE skips versions created by the same <code>(txn_id, command_id)</code> to avoid looping back
over freshly inserted tuples.</li>
</ul>
<hr>
<h2 id="locking"><a class="header" href="#locking">Locking</a></h2>
<ul>
<li>Multi-granularity hierarchy: table-level IS/IX/S/SIX/X plus row-level S/X.</li>
<li>Deadlock detection: <code>LockManager</code> maintains a wait-for graph and periodically chooses a
victim (usually the longest waiter).</li>
<li>Release policy: exclusive/intent locks stay until commit; RR drops shared row locks at
statement end, Serializable waits until commit.</li>
</ul>
<hr>
<h2 id="interactions-6"><a class="header" href="#interactions-6">Interactions</a></h2>
<ul>
<li><strong>ExecutionContext</strong> – all helpers (lock acquisition, visibility checks, undo logging)
are exposed here, so physical operators never touch <code>LockManager</code> directly.</li>
<li><strong>StorageEngine</strong> – handles call <code>TxnContext</code> before mutating heaps/indexes; MVCC metadata
lives in <code>TupleMeta</code>. Deletes and updates now push the affected index keys into the undo
chain so heap/index WAL stay in lockstep.</li>
<li><strong>Recovery</strong> – Begin/Commit/Abort records emitted here drive ARIES undo/redo.</li>
<li><strong>Background</strong> – MVCC vacuum reads <code>TransactionManager::oldest_active_txn()</code> to compute
<code>safe_xmin</code>.</li>
</ul>
<hr>
<h2 id="teaching-ideas-6"><a class="header" href="#teaching-ideas-6">Teaching Ideas</a></h2>
<ul>
<li>Change <code>DatabaseOptions::default_isolation_level</code> and compare SELECT behaviour under
RC vs RR.</li>
<li>Write a unit test that deadlocks two transactions and watch <code>LockManager</code> pick a victim.</li>
<li>Implement statement-level snapshot refresh or Serializable Snapshot Isolation (SSI) as
an advanced exercise.</li>
</ul>
<h2 id="lab-walkthrough-à-la-cmu-15-445"><a class="header" href="#lab-walkthrough-à-la-cmu-15-445">Lab Walkthrough (à la CMU 15-445)</a></h2>
<ol>
<li><strong>Warm-up</strong> – Start two sessions, run <code>BEGIN; SELECT ...;</code> under RC vs RR, and trace
which snapshot <code>TxnRuntime</code> installs by logging <code>txn.current_command_id()</code>.</li>
<li><strong>MVCC visibility</strong> – Extend the <code>transaction_tests.rs</code> suite with a scenario where
<code>txn1</code> updates a row while <code>txn2</code> reads it. Instrument <code>TupleMeta</code> printing so
students see how <code>(insert_txn_id, delete_txn_id)</code> change as versions are linked.</li>
<li><strong>Undo tracing</strong> – Force an abort after a multi-index UPDATE. Watch the undo stack
entries unfold: <code>Insert</code> removes the new version + index entries, <code>Delete</code> restores
the old version + keys. Map each step to the WAL records that are written.</li>
<li><strong>Crash drill</strong> – Add <code>panic!()</code> right after <code>TransactionManager::commit</code> is called
but before locks are released. Reboot, run recovery, and inspect the loser list;
students can connect the dots between undo actions, CLRs, and ARIES theory.</li>
</ol>
<hr>
<p>Further reading: <a href="#mvcc-and-2pl">MVCC and 2PL</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="mvcc-and-2pl"><a class="header" href="#mvcc-and-2pl">MVCC and 2PL</a></h1>
<p>Of the four ACID properties, <strong>Isolation</strong> is often the most complex to implement. It ensures that concurrent transactions do not interfere with each other, making it appear as if each transaction is executing sequentially, one after another. Without proper isolation, a database would suffer from concurrency-related anomalies like dirty reads, non-repeatable reads, and phantom reads.</p>
<p>Databases typically use two main strategies for concurrency control:</p>
<ol>
<li><strong>Pessimistic Concurrency Control</strong>: Assumes conflicts are likely and prevents them from happening by using locks. The most common protocol is <strong>Two-Phase Locking (2PL)</strong>.</li>
<li><strong>Optimistic Concurrency Control</strong>: Assumes conflicts are rare. Transactions proceed without locking, and the database validates at commit time that no conflicts occurred. A popular variant is <strong>Multi-Version Concurrency Control (MVCC)</strong>.</li>
</ol>
<p>QuillSQL, like many modern relational databases (e.g., PostgreSQL, Oracle), implements a powerful <strong>hybrid model that combines MVCC with 2PL</strong>.</p>
<h2 id="1-mvcc-reading-without-blocking"><a class="header" href="#1-mvcc-reading-without-blocking">1. MVCC: Reading without Blocking</a></h2>
<p>The core idea of MVCC is <strong>“writers don’t block readers, and readers don’t block writers.”</strong> This is achieved by never overwriting data in-place. When a row is updated, the database creates a <em>new version</em> of that row, preserving the old one.</p>
<h3 id="version-chains-and-tuplemeta"><a class="header" href="#version-chains-and-tuplemeta">Version Chains and <code>TupleMeta</code></a></h3>
<p>As discussed in the <a href="#table-heap-and-mvcc">Storage Engine</a> chapter, every tuple on disk has associated metadata (<code>TupleMeta</code>) that includes:</p>
<ul>
<li><code>insert_txn_id</code>: The ID of the transaction that created this version.</li>
<li><code>delete_txn_id</code>: The ID of the transaction that marked this version as deleted.</li>
<li><code>prev_version</code> / <code>next_version</code>: Pointers (RIDs) that form a linked list of versions for a single logical row, called the <strong>version chain</strong>.</li>
</ul>
<h3 id="transaction-snapshots"><a class="header" href="#transaction-snapshots">Transaction Snapshots</a></h3>
<p>When a transaction begins, it asks the <code>TransactionManager</code> for a <strong>snapshot</strong> of the database state. This snapshot, defined in <code>transaction/mvcc.rs</code>, contains three key pieces of information:</p>
<ul>
<li><code>xmin</code>: The oldest active transaction ID at the time of the snapshot. Any transaction with an ID less than <code>xmin</code> is guaranteed to be either committed or aborted.</li>
<li><code>xmax</code>: The next transaction ID to be assigned. Any transaction with an ID greater than or equal to <code>xmax</code> was not yet started when the snapshot was taken.</li>
<li><code>active_txns</code>: A list of all other transaction IDs that were active when the snapshot was taken.</li>
</ul>
<h3 id="the-visibility-check"><a class="header" href="#the-visibility-check">The Visibility Check</a></h3>
<p>When a transaction scans the database, for every tuple version it encounters, it performs a <strong>visibility check</strong> using its snapshot. The logic in <code>MvccSnapshot::is_visible</code> determines if the version should be “seen” by the current transaction. In simplified terms, a tuple version is visible if:</p>
<ol>
<li>Its <code>insert_txn_id</code> belongs to a transaction that was already committed before our snapshot was taken.</li>
<li><strong>AND</strong> its <code>delete_txn_id</code> is either not set, OR it belongs to a transaction that was not yet committed when our snapshot was taken.</li>
</ol>
<p>This mechanism elegantly solves several concurrency problems. Since a reader transaction only ever sees a consistent snapshot of the database, it is completely immune to changes being made by other concurrent writer transactions. This prevents dirty reads and non-repeatable reads.</p>
<h2 id="2-two-phase-locking-2pl-preventing-write-write-conflicts"><a class="header" href="#2-two-phase-locking-2pl-preventing-write-write-conflicts">2. Two-Phase Locking (2PL): Preventing Write-Write Conflicts</a></h2>
<p>While MVCC is excellent for read-write conflicts, it does not, by itself, prevent two transactions from trying to modify the same logical row at the same time (a write-write conflict). This is where locking comes in.</p>
<p>QuillSQL implements a strict <strong>Two-Phase Locking</strong> protocol via the <code>LockManager</code> (<code>transaction/lock_manager.rs</code>).</p>
<h3 id="the-two-phases"><a class="header" href="#the-two-phases">The Two Phases</a></h3>
<ol>
<li><strong>Growing Phase</strong>: The transaction can acquire new locks as it executes.</li>
<li><strong>Shrinking Phase</strong>: Once the transaction releases its first lock, it cannot acquire any new locks.</li>
</ol>
<p>In practice, QuillSQL uses <strong>Strict 2PL</strong>, where the shrinking phase is delayed until the transaction commits or aborts. All locks are held until the very end.</p>
<h3 id="hierarchical-locking-intention-locks"><a class="header" href="#hierarchical-locking-intention-locks">Hierarchical Locking (Intention Locks)</a></h3>
<p>To be efficient, the <code>LockManager</code> uses a multi-granularity, hierarchical locking scheme. Before a transaction can take a fine-grained lock on a row (a <code>Shared</code> or <code>Exclusive</code> lock), it must first acquire a coarser-grained <strong>intention lock</strong> on the table.</p>
<ul>
<li><strong><code>IntentionShared (IS)</code></strong>: Signals the intent to read rows from the table.</li>
<li><strong><code>IntentionExclusive (IX)</code></strong>: Signals the intent to modify rows in the table.</li>
</ul>
<p>This prevents a transaction wanting to lock the entire table from conflicting with another transaction that is already modifying a single row. For example, a <code>SELECT * FROM users FOR UPDATE</code> (which needs an <code>X</code> lock on the table) will be blocked if another transaction already holds an <code>IX</code> lock on <code>users</code>.</p>
<h3 id="deadlock-detection"><a class="header" href="#deadlock-detection">Deadlock Detection</a></h3>
<p>When two or more transactions are waiting for each other to release locks in a circular chain, a <strong>deadlock</strong> occurs. The <code>LockManager</code> detects this by building a <strong>waits-for graph</strong>. When a transaction <code>T1</code> has to wait for a lock held by <code>T2</code>, an edge <code>T1 -&gt; T2</code> is added to the graph. If adding an edge creates a cycle, a deadlock is detected, and one of the transactions (the victim) is immediately aborted to break the cycle.</p>
<h2 id="3-the-hybrid-model-mvcc--2pl-in-action"><a class="header" href="#3-the-hybrid-model-mvcc--2pl-in-action">3. The Hybrid Model: MVCC + 2PL in Action</a></h2>
<p>In QuillSQL, these two mechanisms work in concert:</p>
<ul>
<li>
<p>A <strong>reader</strong> (<code>SELECT</code>) transaction acquires an MVCC snapshot. It uses this snapshot to determine visibility. It only needs to acquire <code>Shared</code> (S) locks on the rows it reads to prevent other transactions from modifying them, thus ensuring repeatable reads in higher isolation levels.</p>
</li>
<li>
<p>A <strong>writer</strong> (<code>UPDATE</code>, <code>DELETE</code>) transaction must acquire an <code>Exclusive</code> (X) lock on the specific row it intends to modify. Once the lock is granted, it knows no other writer can interfere. It can then safely create a new tuple version as part of the MVCC protocol.</p>
</li>
</ul>
<p>This hybrid approach provides the best of both worlds: reads are fast and non-blocking, while write-write conflicts are safely prevented by the locking protocol.</p>
<hr>
<h2 id="for-study--discussion-3"><a class="header" href="#for-study--discussion-3">For Study &amp; Discussion</a></h2>
<ol>
<li>
<p><strong>Isolation Levels</strong>: QuillSQL supports multiple SQL isolation levels. How does the behavior of MVCC snapshots and 2PL change between <code>ReadCommitted</code> and <code>RepeatableRead</code>? In <code>ReadCommitted</code>, a transaction gets a new snapshot for every statement, whereas in <code>RepeatableRead</code>, it uses the same snapshot for the entire transaction. What concurrency anomalies does this difference prevent?</p>
</li>
<li>
<p><strong>Phantom Reads</strong>: Even with MVCC and row-level 2PL, a <code>RepeatableRead</code> transaction can suffer from <em>phantom reads</em>. Imagine <code>T1</code> runs <code>SELECT COUNT(*) FROM users WHERE age &gt; 30</code>. Then, <code>T2</code> inserts a new user with <code>age = 40</code> and commits. If <code>T1</code> runs its <code>SELECT</code> query again, it will see a new “phantom” row that wasn’t there before. How can a database prevent this to achieve the <code>Serializable</code> isolation level? (Hint: research predicate locking and index-range locking).</p>
</li>
<li>
<p><strong>Deadlock Handling</strong>: QuillSQL detects deadlocks by building a waits-for graph and aborting a transaction. What is an alternative strategy for handling deadlocks? For example, what are the pros and cons of using lock timeouts instead of cycle detection?</p>
</li>
<li>
<p><strong>Programming Exercise (Advanced)</strong>: A full implementation of <code>Serializable</code> isolation often requires index-range locking to prevent phantoms. Extend the <code>LockManager</code> to support locking a <em>range</em> of keys within a B+Tree index. This would require a new lock type and a way to check for overlapping ranges. When a <code>SELECT ... WHERE age &gt; 30</code> query runs, it would place a shared lock on the <code>(30, +∞)</code> range in the index on the <code>age</code> column, preventing any other transaction from inserting a new user with an age in that range.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="storage-engine"><a class="header" href="#storage-engine">Storage Engine</a></h1>
<p>The storage engine persists relational data, covering heap files, indexes, page formats,
and the handles exposed to execution. Understanding this layer is key to reasoning about
performance, MVCC, and recovery.</p>
<hr>
<h2 id="responsibilities-5"><a class="header" href="#responsibilities-5">Responsibilities</a></h2>
<ul>
<li>Manage <code>TableHeap</code> insert/delete/update paths and their MVCC metadata.</li>
<li>Maintain indexes (see the <a href="#index-module">Index module</a> for details).</li>
<li>Expose the <code>StorageEngine</code> trait so execution can fetch <code>TableHandle</code> / <code>IndexHandle</code>
instances per table.</li>
<li>Provide <code>TupleStream</code> so sequential and index scans share a unified interface.</li>
</ul>
<hr>
<h2 id="directory-layout-5"><a class="header" href="#directory-layout-5">Directory Layout</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Path</th><th>Purpose</th><th>Key Types</th></tr>
</thead>
<tbody>
<tr><td><code>engine.rs</code></td><td>Default engine plus handle definitions.</td><td><code>StorageEngine</code>, <code>TableHandle</code>, <code>TupleStream</code></td></tr>
<tr><td><code>table_heap/</code></td><td>Heap storage + MVCC logic.</td><td><code>TableHeap</code>, <code>MvccHeap</code></td></tr>
<tr><td><code>index/</code></td><td>B+Tree implementation.</td><td><code>BPlusTreeIndex</code></td></tr>
<tr><td><code>page/</code></td><td>Page, RID, tuple metadata.</td><td><code>Page</code>, <code>RecordId</code>, <code>TupleMeta</code></td></tr>
<tr><td><code>tuple/</code></td><td>Row encoding and projection helpers.</td><td><code>Tuple</code></td></tr>
<tr><td><code>disk_manager.rs</code></td><td>File layout and page I/O.</td><td><code>DiskManager</code></td></tr>
<tr><td><code>disk_scheduler.rs</code></td><td><code>io_uring</code>-backed async scheduler.</td><td><code>DiskScheduler</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="core-abstractions"><a class="header" href="#core-abstractions">Core Abstractions</a></h2>
<h3 id="storageengine-trait"><a class="header" href="#storageengine-trait">StorageEngine Trait</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait StorageEngine {
    fn table(&amp;self, catalog: &amp;Catalog, table: &amp;TableReference)
        -&gt; QuillSQLResult&lt;Arc&lt;dyn TableHandle&gt;&gt;;
    fn indexes(&amp;self, catalog: &amp;Catalog, table: &amp;TableReference)
        -&gt; QuillSQLResult&lt;Vec&lt;Arc&lt;dyn IndexHandle&gt;&gt;&gt;;
}
<span class="boring">}</span></code></pre>
<p>The default implementation wraps the row-oriented heap + B+Tree combo, but the trait is
ready for column stores, remote storage, or async engines.</p>
<h3 id="tablehandle"><a class="header" href="#tablehandle">TableHandle</a></h3>
<p>Offers <code>full_scan()</code>, <code>insert</code>, <code>delete</code>, <code>update</code>, and
<code>prepare_row_for_write</code>. MVCC, undo, and locking concerns live here so execution operators
only describe intent. Every delete/update now receives the table’s index handles so
<code>HeapTableHandle</code> can delete or re-insert keys in tandem with heap tuples—exactly the
behaviour CMU 15-445’s buffer/heap projects walk you through.</p>
<h3 id="tuplestream"><a class="header" href="#tuplestream">TupleStream</a></h3>
<p>Minimal iterator that returns <code>(RecordId, TupleMeta, Tuple)</code> triples. Index scans use
<code>IndexScanRequest</code> to describe ranges.</p>
<hr>
<h2 id="interactions-7"><a class="header" href="#interactions-7">Interactions</a></h2>
<ul>
<li><strong>Execution</strong> – <code>ExecutionContext::table_stream</code> / <code>index_stream</code> delegate to handles.</li>
<li><strong>Transaction</strong> – Handle methods call into <code>TxnContext</code> to acquire locks, record undo,
and emit WAL.</li>
<li><strong>Buffer Manager</strong> – <code>TableHeap</code>/<code>BPlusTreeIndex</code> access pages through the shared buffer
pool.</li>
<li><strong>Recovery</strong> – Heap/index mutations generate WAL records (<code>HeapInsert</code>, <code>HeapDelete</code>,
<code>IndexInsert</code>, …) that ARIES replays.</li>
<li><strong>Background</strong> – MVCC vacuum and index cleanup obtain handles and iterate tuples via
the same abstractions as foreground scans.</li>
</ul>
<hr>
<h2 id="teaching-ideas-7"><a class="header" href="#teaching-ideas-7">Teaching Ideas</a></h2>
<ul>
<li>Implement a toy columnar handle to show how the execution engine can stay agnostic to
storage layout.</li>
<li>Extend the <code>TableHandle::full_scan</code> / <code>TableIterator</code> plumbing to accept projection hints
so students can experiment with column pruning.</li>
<li>Enable <code>RUST_LOG=storage::table_heap=trace</code> and trace MVCC version chains as updates
occur.</li>
<li>Follow the CMU 15-445 Lab 2 flow: instrument <code>TableBinding::delete</code> to print every RID
<ul>
<li>key pair, run an UPDATE with multiple indexes, and confirm the WAL stream contains the
matching HeapInsert/HeapDelete + IndexLeafInsert/IndexLeafDelete entries.</li>
</ul>
</li>
</ul>
<hr>
<p>Further reading: <a href="#disk-io--scheduler-io_uring-data-pages--wal-runtime">Disk I/O</a>,
<a href="#page-and-tuple-layout">Page &amp; Tuple Layout</a>,
<a href="#table-heap-and-mvcc">Table Heap &amp; MVCC</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="disk-io--scheduler-io_uring-data-pages--wal-runtime"><a class="header" href="#disk-io--scheduler-io_uring-data-pages--wal-runtime">Disk I/O — Scheduler, io_uring Data Pages &amp; WAL Runtime</a></h1>
<h2 id="1-architecture"><a class="header" href="#1-architecture">1. Architecture</a></h2>
<ul>
<li><strong>Request Path</strong>: foreground components enqueue <code>DiskRequest</code> objects via <code>DiskScheduler::{schedule_read, schedule_write, …}</code>. A dispatcher thread drains the global channel and distributes work round-robin to N io_uring workers. Each worker owns its own ring and file-descriptor cache, so once a request is forwarded, execution proceeds entirely off the foreground thread.</li>
<li><strong>Stable APIs</strong>: <code>schedule_read(page_id)</code>, <code>schedule_write(page_id, Bytes)</code>, <code>schedule_read_pages(Vec&lt;PageId&gt;)</code>, <code>schedule_allocate()</code>, <code>schedule_deallocate(page_id)</code> — every call returns a channel the caller can block on or poll.</li>
<li><strong>Batch Reads</strong>: <code>ReadPages</code> fans out per-page SQEs while a shared <code>BatchState</code> tracks completions. Even if the kernel completes I/O out of order, the caller receives a <code>Vec&lt;BytesMut&gt;</code> that preserves the original page order.</li>
</ul>
<h2 id="2-wal-runtime-buffered-io"><a class="header" href="#2-wal-runtime-buffered-io">2. WAL Runtime (buffered I/O)</a></h2>
<ul>
<li>Dedicated WAL runtime threads handle sequential WAL appends/reads using buffered I/O. They now keep a per-thread cache of open segment files, eliminating repeated <code>open()</code>/<code>close()</code> on every log record.</li>
<li>Worker count defaults to <code>max(1, available_parallelism / 2)</code> but is tunable through <code>IOSchedulerConfig</code>.</li>
<li>Optional <code>sync</code> on a request triggers <code>sync_data</code> / <code>fdatasync</code> so <code>WalManager</code> can honour synchronous commit or checkpoint barriers. Data pages stay on the io_uring dataplane; WAL always uses buffered writes.</li>
</ul>
<h2 id="3-io_uring-backend-linux"><a class="header" href="#3-io_uring-backend-linux">3. io_uring Backend (Linux)</a></h2>
<ul>
<li>Each worker owns an <code>IoUring</code> with configurable <code>queue_depth</code>, optional SQPOLL idle timeout, and a pool of registered fixed buffers sized to <code>PAGE_SIZE</code>. Workers submit SQEs asynchronously and drain CQEs in small batches to keep the ring warm.</li>
<li>Read batching relies on shared <code>BatchState</code> instances (<code>Rc&lt;RefCell&lt;_&gt;&gt;</code>) so multi-page callers see ordered results without blocking the kernel on serialization.</li>
<li>Writes keep their payload alive until completion; if a fixed buffer slot is available we reuse it, otherwise we fall back to heap buffers. A companion <code>WriteState</code> tracks an optional <code>fdatasync</code> so the caller still observes exactly one <code>Result&lt;()&gt;</code> once all CQEs land.</li>
<li>Errors (short read/write, errno) are normalised into <code>QuillSQLError</code> values that flow back on the original channel.</li>
</ul>
<h2 id="4-configuration"><a class="header" href="#4-configuration">4. Configuration</a></h2>
<ul>
<li><code>config::IOSchedulerConfig</code> controls:
<ul>
<li><code>workers</code>: number of io_uring workers (default = available parallelism).</li>
<li><code>wal_workers</code>: WAL runtime threads (default workers / 2).</li>
<li><code>iouring_queue_depth</code>, <code>iouring_fixed_buffers</code>, <code>iouring_sqpoll_idle_ms</code>.</li>
<li><code>fsync_on_write</code>: whether data-page writes also issue <code>fdatasync</code> (WAL sync is managed separately by <code>WalManager</code>).</li>
</ul>
</li>
</ul>
<h2 id="5-concurrency--safety"><a class="header" href="#5-concurrency--safety">5. Concurrency &amp; Safety</a></h2>
<ul>
<li>Worker-local file descriptors plus positional I/O remove shared mutable state on the hot path. The new per-worker handle cache further reduces syscall overhead.</li>
<li>Shutdown sequence: enqueue <code>Shutdown</code>, dispatcher forwards it to every worker, each worker drains outstanding SQEs/CQEs, and finally dispatcher + workers are joined.</li>
<li>BufferPool and TableHeap integrate via the same scheduler channels; inflight guards
prevent duplicate page fetches even when multiple scans touch adjacent pages.</li>
</ul>
<h2 id="6-performance-notes"><a class="header" href="#6-performance-notes">6. Performance Notes</a></h2>
<ul>
<li>Random page access benefits from fewer syscalls and deeper outstanding queue depth than the blocking fallback.</li>
<li>Only the io_uring backend currently ships (Linux x86_64). A portable fallback remains future work.</li>
<li>For large sequential scans, rely on the buffer pool’s sequential access pattern or add
a custom iterator on top of <code>ReadPages</code> if you want to experiment with direct I/O.</li>
</ul>
<h2 id="7-future-work"><a class="header" href="#7-future-work">7. Future Work</a></h2>
<ul>
<li>Queue-depth aware scheduling and CQE bulk harvesting.</li>
<li>Optional group commit (aggregate writes, single fsync) behind configuration.</li>
<li>Metrics hooks (queue depth, submit/complete throughput, latency percentiles, error codes).</li>
<li>Cross-platform fallback backend and richer prioritisation/throttling policies.</li>
<li>Control-plane knobs for throttling individual background workers.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="page-and-tuple-layout"><a class="header" href="#page-and-tuple-layout">Page and Tuple Layout</a></h1>
<h2 id="1-the-page-the-atomic-unit-of-io"><a class="header" href="#1-the-page-the-atomic-unit-of-io">1. The Page: The Atomic Unit of I/O</a></h2>
<p>A database file is not treated as one continuous stream of data. Instead, it is broken down into fixed-size blocks called <strong>pages</strong>. A page is the atomic unit of transfer between the disk and the in-memory <a href="#buffer-manager">Buffer Pool</a>. Whenever the database needs to read a piece of data (like a single row), it must load the <em>entire page</em> containing that data into memory.</p>
<p>In QuillSQL, the page size is a constant defined at <code>quill-sql/src/buffer/mod.rs</code>:</p>
<ul>
<li><strong><code>PAGE_SIZE</code></strong>: 4096 bytes (4 KB)</li>
</ul>
<p>This fixed-size approach simplifies buffer management and allows for efficient, aligned I/O operations, especially when using Direct I/O to bypass the OS cache.</p>
<h2 id="2-tablepage-the-slotted-page-layout"><a class="header" href="#2-tablepage-the-slotted-page-layout">2. <code>TablePage</code>: The Slotted Page Layout</a></h2>
<p>While a page is a generic 4KB block of bytes, pages that store actual table data are structured in a specific way. QuillSQL uses a classic <strong>Slotted Page</strong> layout, which is a core concept in database implementation (as taught in CMU 15-445).</p>
<p>A <code>TablePage</code> is organized into three main parts:</p>
<pre><code>&lt;------------------------------ 4KB ------------------------------&gt;
+----------------+-----------------+-----------------+--------------+
|  Page Header   |   Slot Array    |      Free       |   Tuple      |
| (grows -&gt;)     |   (grows -&gt;)    |      Space      |     Data     |
|                |                 |                 | (&lt;- grows)   |
+----------------+-----------------+-----------------+--------------+
</code></pre>
<ol>
<li><strong>Page Header (<code>TablePageHeader</code>)</strong>: Located at the beginning of the page. It contains metadata about the page itself.</li>
<li><strong>Slot Array (<code>tuple_infos</code>)</strong>: An array of <code>TupleInfo</code> structs that grows from after the header. Each entry in this array acts as a “pointer” or “directory entry” for a tuple on the page.</li>
<li><strong>Tuple Data</strong>: The actual raw data of the tuples is stored starting from the <strong>end</strong> of the page, growing backwards towards the middle.</li>
</ol>
<p>This design has a key advantage: <strong>it decouples a tuple’s logical identifier from its physical location on the page.</strong></p>
<h3 id="the-recordid-rid"><a class="header" href="#the-recordid-rid">The <code>RecordId</code> (RID)</a></h3>
<p>A specific tuple is uniquely identified by a <code>RecordId</code> (RID). The RID is a stable pointer composed of two parts:</p>
<ul>
<li><strong><code>page_id</code></strong>: The ID of the page where the tuple resides.</li>
<li><strong><code>slot_num</code></strong>: The <strong>index</strong> into the Slot Array on that page.</li>
</ul>
<p>So, <code>RID = (page_id, slot_num)</code>.</p>
<p>When the database needs to delete a tuple or if a variable-length tuple is updated and grows in size, the tuple’s data might need to be moved within the page (for compaction). In a slotted page design, we only need to update the <code>offset</code> in the corresponding slot array entry. The tuple’s RID (<code>page_id</code>, <code>slot_num</code>) <strong>remains unchanged</strong>. This prevents a cascade of updates to all secondary indexes that might be pointing to that tuple.</p>
<h3 id="tablepageheader-and-slot-tupleinfo"><a class="header" href="#tablepageheader-and-slot-tupleinfo"><code>TablePageHeader</code> and Slot (<code>TupleInfo</code>)</a></h3>
<p>Let’s look at the physical layout, as defined in <code>storage/codec/table_page.rs</code>:</p>
<ul>
<li>
<p><strong><code>TablePageHeader</code></strong>:</p>
<ul>
<li><code>lsn</code>: The Log Sequence Number of the last change made to this page, crucial for WAL recovery.</li>
<li><code>next_page_id</code>: The ID of the next page in this table, forming a linked list of pages.</li>
<li><code>num_tuples</code>: The number of active tuples on the page.</li>
<li><code>num_deleted_tuples</code>: The number of “dead” or deleted tuples.</li>
<li><code>tuple_infos</code>: The slot array itself.</li>
</ul>
</li>
<li>
<p><strong><code>TupleInfo</code></strong> (A single slot in the array):</p>
<ul>
<li><code>offset</code>: The byte offset from the beginning of the page where the tuple’s data begins.</li>
<li><code>size</code>: The size of the tuple’s data in bytes.</li>
<li><code>meta</code>: A nested <code>TupleMeta</code> struct containing critical information for concurrency control.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="for-study--discussion-4"><a class="header" href="#for-study--discussion-4">For Study &amp; Discussion</a></h2>
<ol>
<li>
<p><strong>Layout Trade-offs</strong>: What is the main benefit of having the tuple data grow from the end of the page backwards, while the header and slot array grow from the beginning forwards? What happens when they meet?</p>
</li>
<li>
<p><strong>Record ID Stability</strong>: Why is it so important that a tuple’s <code>RecordId</code> does not change even if the tuple’s physical data is moved within the page? What would break if the RID was just a direct byte offset?</p>
</li>
<li>
<p><strong>Large Objects</strong>: The current design assumes a tuple fits entirely on one page. How would you modify this page layout to support tuples that are larger than 4KB (e.g., a long blog post stored in a <code>VARCHAR</code> column)? Research how systems like PostgreSQL handle this with their “TOAST” (The Oversized-Attribute Storage Technique) mechanism.</p>
</li>
<li>
<p><strong>Programming Exercise</strong>: Implement a <code>defragment()</code> method for the <code>TablePage</code>. After several insertions and deletions, the free space on a page can become fragmented into small, unusable chunks. This method should reorganize the page by moving the existing tuples to be contiguous, creating a single, large block of free space. Remember to update the <code>offset</code> in each <code>TupleInfo</code> slot after moving its corresponding tuple data!</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="table-heap-and-mvcc"><a class="header" href="#table-heap-and-mvcc">Table Heap and MVCC</a></h1>
<p>The <code>TableHeap</code> (<code>storage/table_heap.rs</code>) is the component responsible for managing the collection of pages that belong to a single table. While the <code>TablePage</code> defines the <em>layout</em> within a single page, the <code>TableHeap</code> provides the high-level API for inserting, updating, and deleting tuples, making it central to the implementation of MVCC.</p>
<h2 id="tablebinding--storageengine"><a class="header" href="#tablebinding--storageengine">TableBinding &amp; StorageEngine</a></h2>
<p>From the executor’s perspective, heap access is routed through <code>storage::engine::TableBinding</code>. A binding is produced by the <code>StorageEngine</code> (consulting the catalog) and carries:</p>
<ul>
<li>An <code>Arc&lt;TableHeap&gt;</code> for physical page access.</li>
<li>An <code>MvccHeap</code> wrapper that maintains version chains.</li>
<li>All indexes defined on the table.</li>
</ul>
<p>The binding exposes ergonomic methods such as <code>scan</code>, <code>index_scan</code>, <code>insert</code>, <code>update</code>, <code>delete</code>, and <code>prepare_row_for_write</code>. Each method internally uses the <code>TableHeap</code> + <code>MvccHeap</code> pair, appends the appropriate logical WAL record (HeapInsert/HeapDelete), and keeps indexes in sync. This keeps physical operators extremely small and makes it easy to swap out the storage engine for experiments.</p>
<h2 id="tuple-serialization"><a class="header" href="#tuple-serialization"><code>Tuple</code> Serialization</a></h2>
<p>A logical <code>Tuple</code> struct in memory must be converted into a byte array to be stored on a page. This process is handled by <code>storage/codec/tuple.rs</code>.</p>
<p>The serialized format of a tuple consists of two parts:</p>
<ol>
<li><strong>Null Bitmap</strong>: A compact bitmap at the beginning of the tuple data. Each bit corresponds to a column in the schema; if the bit is <code>1</code>, the column’s value is <code>NULL</code>. This avoids storing any data for null fields.</li>
<li><strong>Attribute Data</strong>: The actual data for all non-null columns, serialized one after another.</li>
</ol>
<h2 id="tuplemeta-the-heart-of-mvcc"><a class="header" href="#tuplemeta-the-heart-of-mvcc"><code>TupleMeta</code>: The Heart of MVCC</a></h2>
<p>The most important part of a tuple’s on-disk metadata is the <code>TupleMeta</code> struct, which is stored directly within the <code>TupleInfo</code> slot in the page header. This is the heart of QuillSQL’s <strong>Multi-Version Concurrency Control (MVCC)</strong> implementation.</p>
<ul>
<li><strong><code>insert_txn_id</code></strong>: The ID of the transaction that created this version of the tuple.</li>
<li><strong><code>delete_txn_id</code></strong>: The ID of the transaction that “deleted” this version. (A value of <code>0</code> or <code>INVALID</code> means it’s not deleted).</li>
<li><strong><code>is_deleted</code></strong>: A boolean flag indicating the tuple version is considered deleted.</li>
<li><strong><code>prev_version: Option&lt;RecordId&gt;</code></strong>: A link (RID) to the <em>previous</em> version of this logical row.</li>
<li><strong><code>next_version: Option&lt;RecordId&gt;</code></strong>: A link (RID) to the <em>next</em> version of this logical row.</li>
</ul>
<p>These fields allow QuillSQL to maintain a <strong>version chain</strong> for each logical row. When a row is updated, the <code>TableHeap</code>’s <code>mvcc_update</code> method is called, which, instead of overwriting the data, performs the following steps:</p>
<ol>
<li>Creates a new tuple version with the new data by calling <code>insert_tuple</code>.</li>
<li>Sets the <code>prev_version</code> pointer of this new version to the RID of the old version.</li>
<li>Updates the <code>next_version</code> pointer of the old version to point to the new version.</li>
<li>Sets the <code>delete_txn_id</code> on the old version to mark it as “dead”.</li>
</ol>
<p>A transaction can then traverse this chain and use the transaction IDs in the <code>TupleMeta</code> to determine which version of a row is visible to it based on its own transaction ID and isolation level, thus achieving transaction isolation without long-held read locks.</p>
<h2 id="logical-logging-redo--undo"><a class="header" href="#logical-logging-redo--undo">Logical Logging (Redo + Undo)</a></h2>
<p>Every heap mutation emits a logical WAL record before the page frame is dirtied:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Payload</th><th>Redo</th><th>Undo</th></tr>
</thead>
<tbody>
<tr><td>Insert</td><td><code>HeapInsertPayload</code></td><td>Re-insert tuple bytes into the slot</td><td>Remove the tuple (implicit via delete logic)</td></tr>
<tr><td>Delete</td><td><code>HeapDeletePayload</code> (new tombstone + old tuple)</td><td>Mark slot deleted and update version chain</td><td>Recreate the prior tuple image</td></tr>
</tbody>
</table>
</div>
<p>This makes crash recovery straightforward: redo simply replays the payload, and undo uses the “old” portion of the payload even if the page is currently inconsistent. Physical <code>PageWrite</code>/<code>PageDelta</code> records are still used for metadata-heavy pages (meta, freelist, etc.) to guarantee a consistent starting point, but ordinary table DML lives entirely in these logical heap records.</p>
<hr>
<h2 id="for-study--discussion-5"><a class="header" href="#for-study--discussion-5">For Study &amp; Discussion</a></h2>
<ol>
<li>
<p><strong>Version Chain Traversal</strong>: Imagine a transaction with ID <code>T10</code> needs to read a row. It finds a version of the row that was inserted by <code>T5</code> (committed) but deleted by <code>T12</code> (in-progress). Should <code>T10</code> see this version? What if the deleter was <code>T8</code> (committed)? What if the deleter was <code>T10</code> itself? Walk through the visibility check logic.</p>
</li>
<li>
<p><strong>Garbage Collection</strong>: The MVCC model creates many “dead” tuple versions that are no longer visible to any active or future transaction. What is the long-term problem with leaving these dead versions in the database? This problem is typically solved by a process called <strong>vacuuming</strong> or garbage collection. When is it safe to physically remove a dead tuple version?</p>
</li>
<li>
<p><strong>Programming Exercise (Advanced)</strong>: Implement a basic <code>VACUUM</code> function for a <code>TableHeap</code>. This function should scan the table and identify dead tuple versions that are no longer visible to <em>any</em> currently active transaction. Once identified, it should physically remove them from their pages. This is a challenging exercise that touches transaction management, storage, and concurrency.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="buffer-manager"><a class="header" href="#buffer-manager">Buffer Manager</a></h1>
<p>The buffer manager (<code>src/buffer/</code>) implements QuillSQL’s shared buffer pool, bridging the
speed gap between RAM and disk. It lets storage/execution read and write pages safely
while coordinating with WAL and asynchronous I/O.</p>
<hr>
<h2 id="responsibilities-6"><a class="header" href="#responsibilities-6">Responsibilities</a></h2>
<ul>
<li>Maintain a fixed-size set of page frames caching <code>TableHeap</code> and B+Tree pages.</li>
<li>Expose RAII-style guards (pin/unpin) that enforce safe concurrent access.</li>
<li>Keep the page table, replacement policy, dirty-page tracking, and WAL coordination in
sync.</li>
<li>Submit async I/O through <code>DiskScheduler</code>.</li>
</ul>
<hr>
<h2 id="directory-layout-6"><a class="header" href="#directory-layout-6">Directory Layout</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Path</th><th>Description</th><th>Key Types</th></tr>
</thead>
<tbody>
<tr><td><code>buffer_manager.rs</code></td><td>Core buffer pool.</td><td><code>BufferManager</code>, <code>BufferFrame</code></td></tr>
<tr><td><code>page.rs</code></td><td>Guard types and pin/unpin logic.</td><td><code>ReadPageGuard</code>, <code>WritePageGuard</code></td></tr>
<tr><td><code>replacer.rs</code></td><td>LRU-K + TinyLFU replacement.</td><td><code>Replacer</code></td></tr>
<tr><td><code>metrics.rs</code></td><td>Optional instrumentation hooks.</td><td><code>BufferMetrics</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="key-mechanisms"><a class="header" href="#key-mechanisms">Key Mechanisms</a></h2>
<h3 id="guard-model"><a class="header" href="#guard-model">Guard Model</a></h3>
<ul>
<li><code>ReadPageGuard</code>, <code>WritePageGuard</code>, and <code>UpgradeableGuard</code> ensure only compatible access
modes coexist on a page.</li>
<li>Guards drop automatically to release pins; paired with Rust’s borrow checker, they make
latch semantics tangible.</li>
</ul>
<h3 id="replacement-policy"><a class="header" href="#replacement-policy">Replacement Policy</a></h3>
<ul>
<li><strong>LRU-K</strong> tracks the last K touches to protect hot pages from scan pollution.</li>
<li><strong>TinyLFU</strong> decides whether a new page should enter the cache, offering probabilistic
admission against noisy workloads.</li>
</ul>
<h3 id="wal-coordination"><a class="header" href="#wal-coordination">WAL Coordination</a></h3>
<ul>
<li>Before flushing a dirty page, the buffer checks <code>page_lsn</code> and asks <code>WalManager</code> to
flush up to that LSN (write-ahead rule).</li>
<li><code>set_wal_manager</code> wires the buffer to WAL so checkpoints can inspect the oldest dirty
LSN.</li>
</ul>
<h3 id="disk-scheduler"><a class="header" href="#disk-scheduler">Disk Scheduler</a></h3>
<ul>
<li>All physical reads/writes go through <code>DiskScheduler::submit_*</code>, sharing worker threads
with WAL and demonstrating the benefits of a unified I/O layer.</li>
</ul>
<hr>
<h2 id="interactions-8"><a class="header" href="#interactions-8">Interactions</a></h2>
<ul>
<li><strong>Storage engine</strong> – <code>TableHeap</code> and <code>BPlusTreeIndex</code> access pages exclusively through
the buffer manager.</li>
<li><strong>Recovery</strong> – checkpoints consult the buffer’s dirty page table to build the ARIES DPT.</li>
<li><strong>Background writer</strong> – periodically walks <code>dirty_frames</code> to flush pages in the
background.</li>
</ul>
<hr>
<h2 id="teaching-ideas-8"><a class="header" href="#teaching-ideas-8">Teaching Ideas</a></h2>
<ul>
<li>Disable TinyLFU via feature flag, rerun sqllogictest, and compare hit rates.</li>
<li>Swap the replacement policy with CLOCK to experiment with cache algorithms.</li>
<li>Enable <code>RUST_LOG=buffer=debug</code> and trace the pin/unpin lifecycle of hot pages.</li>
</ul>
<hr>
<p>Further reading: <a href="#page--page-guards">Page &amp; Page Guards</a>,
<a href="#the-buffer-pool-architecture-and-lifecycle">The Buffer Pool</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="page--page-guards"><a class="header" href="#page--page-guards">Page &amp; Page Guards</a></h1>
<p>Before the Buffer Manager can hand out a reference to a page in memory, it must ensure that the page won’t be evicted while it’s being used by another thread. This is accomplished by <strong>pinning</strong>.</p>
<h2 id="pinning"><a class="header" href="#pinning">Pinning</a></h2>
<p>Pinning simply means incrementing a “pin count” associated with the page’s frame in the buffer pool. A frame with a pin count greater than zero is forbidden from being chosen as a victim by the page replacer.</p>
<ul>
<li>When a thread wants to use a page, it must first pin it.</li>
<li>When the thread is finished with the page, it must <strong>unpin</strong> it (decrementing the count).</li>
</ul>
<p>Manually managing pin counts is tedious and error-prone. Forgetting to unpin a page leads to a memory leak, as the frame can never be evicted. To solve this, QuillSQL uses a common and powerful C++ and Rust pattern: <strong>Resource Acquisition Is Initialization (RAII)</strong>.</p>
<h2 id="readpageguard-and-writepageguard"><a class="header" href="#readpageguard-and-writepageguard"><code>ReadPageGuard</code> and <code>WritePageGuard</code></a></h2>
<p>Instead of returning a raw pointer to the page memory, the <code>BufferManager</code>’s <code>fetch_page_*</code> methods return a <strong>guard</strong> object: <code>ReadPageGuard</code> or <code>WritePageGuard</code>.</p>
<p>These guards are responsible for the lifetime of the pin and the lock on the page:</p>
<ol>
<li>
<p><strong>Acquisition</strong>: When a <code>PageGuard</code> is created, its constructor acquires the appropriate lock (<code>RwLock</code>) on the page’s frame and increments the frame’s pin count.</p>
<ul>
<li><code>ReadPageGuard</code> takes a read lock, allowing multiple concurrent readers.</li>
<li><code>WritePageGuard</code> takes an exclusive write lock.</li>
</ul>
</li>
<li>
<p><strong>Usage</strong>: The calling code uses the guard object to access the page’s data. The guard provides safe, locked access to the underlying byte array.</p>
</li>
<li>
<p><strong>Release</strong>: When the guard variable goes out of scope (e.g., at the end of a function), its <code>drop()</code> method is automatically called by the Rust compiler. This <code>drop()</code> implementation handles all the cleanup:</p>
<ul>
<li>It decrements the pin count.</li>
<li>It releases the lock on the frame.</li>
<li>If it’s a <code>WritePageGuard</code> and the data was modified, it informs the <code>BufferManager</code> that the page is now <strong>dirty</strong>.</li>
</ul>
</li>
</ol>
<p>This RAII pattern makes using the buffer pool much safer and more ergonomic, as it makes it impossible to forget to unpin a page or release a lock.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-buffer-pool-architecture-and-lifecycle"><a class="header" href="#the-buffer-pool-architecture-and-lifecycle">The Buffer Pool: Architecture and Lifecycle</a></h1>
<h2 id="1-core-components--architecture"><a class="header" href="#1-core-components--architecture">1. Core Components &amp; Architecture</a></h2>
<p>QuillSQL’s buffer management is split into two main structs, reflecting a separation of concerns:</p>
<ul>
<li><strong><code>BufferPool</code> (<code>buffer/buffer_pool.rs</code>)</strong>: A low-level, “dumb” container. It owns the actual memory arena for pages and provides basic mapping from a <code>PageId</code> to a memory location (<code>FrameId</code>).</li>
<li><strong><code>BufferManager</code> (<code>buffer/buffer_manager.rs</code>)</strong>: The high-level, “smart” coordinator. It contains the <code>BufferPool</code> and implements all the logic for fetching pages, choosing which pages to evict, and interacting with other database components like the transaction and recovery managers.</li>
</ul>
<p>This architecture is centered around three key data structures:</p>
<ol>
<li>
<p><strong>Frames (The Arena)</strong>: The <code>BufferPool</code> pre-allocates a large, contiguous block of memory on the heap. This block is divided into a fixed number of smaller chunks called <strong>frames</strong>. Each frame is exactly <code>PAGE_SIZE</code> (4KB) and can hold the contents of one disk page.</p>
</li>
<li>
<p><strong>Page Table (<code>page_table</code>)</strong>: A hash map (specifically, a concurrent <code>DashMap</code>) that maps a logical <code>PageId</code> to the <code>FrameId</code> where it currently resides in memory. This provides fast O(1) lookups to check if a page is already in the buffer pool.</p>
</li>
<li>
<p><strong>Replacer (<code>LRUKReplacer</code>)</strong>: When a requested page is not in memory and the buffer pool is full, one of the existing pages must be <strong>evicted</strong> to make room. The <code>Replacer</code> is the component that implements the page replacement policy and decides which page is the best candidate for eviction. QuillSQL uses an <strong>LRU-K</strong> replacement policy, a sophisticated variant of the classic Least Recently Used (LRU) algorithm.</p>
</li>
</ol>
<h2 id="2-the-lifecycle-of-a-page-request"><a class="header" href="#2-the-lifecycle-of-a-page-request">2. The Lifecycle of a Page Request</a></h2>
<p>When another part of the database (e.g., the execution engine) needs to access a page, it calls <code>buffer_manager.fetch_page_read(page_id)</code> or <code>fetch_page_write(page_id)</code>. This initiates a critical sequence of events.</p>
<p>The flow is as follows:</p>
<ol>
<li>
<p><strong>Request</strong>: An executor requests Page <code>P</code>.</p>
</li>
<li>
<p><strong>Lookup</strong>: The <code>BufferManager</code> consults the <code>PageTable</code>.</p>
</li>
<li>
<p><strong>Case 1: Cache Hit</strong></p>
<ul>
<li>The <code>PageTable</code> contains an entry for <code>P</code>, mapping it to <code>FrameId</code> <code>F</code>.</li>
<li>The <code>BufferManager</code> increments the pin count for frame <code>F</code>.</li>
<li>It informs the <code>LRUKReplacer</code> that the page has been accessed (updating its priority).</li>
<li>It returns a <code>PageGuard</code> wrapping a reference to the memory in frame <code>F</code>.</li>
</ul>
</li>
<li>
<p><strong>Case 2: Cache Miss</strong></p>
<ul>
<li>The <code>PageTable</code> has no entry for <code>P</code>.</li>
<li>The <code>BufferManager</code> must bring the page from disk. It asks the <code>Replacer</code> to choose a <strong>victim frame</strong> <code>F_v</code> to evict.</li>
<li><strong>If the victim frame <code>F_v</code> is dirty</strong>: The <code>BufferManager</code> first writes the contents of <code>F_v</code> back to disk via the <code>DiskScheduler</code>. This is essential for data durability.</li>
<li>The <code>PageTable</code> entry for the old page residing in <code>F_v</code> is removed.</li>
<li>The <code>BufferManager</code> issues a read request to the <code>DiskScheduler</code> to load page <code>P</code>’s data from disk into frame <code>F_v</code>.</li>
<li>The <code>PageTable</code> is updated with the new mapping: <code>P -&gt; F_v</code>.</li>
<li>The process then continues like a cache hit: frame <code>F_v</code> is pinned and a <code>PageGuard</code> is returned.</li>
</ul>
</li>
</ol>
<h2 id="3-concurrency"><a class="header" href="#3-concurrency">3. Concurrency</a></h2>
<p>The buffer pool is a shared resource accessed by many concurrent threads. QuillSQL uses a combination of locking strategies:</p>
<ul>
<li><strong>Page Table</strong>: A <code>DashMap</code> is used for the page table, which is highly optimized for concurrent reads and writes.</li>
<li><strong>Frame-Level Locks</strong>: Each frame in the pool has its own <code>RwLock</code>. A <code>ReadPageGuard</code> acquires a read lock on the frame, allowing multiple threads to read the same page concurrently. A <code>WritePageGuard</code> acquires an exclusive write lock, ensuring that only one thread can modify a page at a time.</li>
<li><strong>Replacer/Free List</strong>: These shared structures are protected by a <code>Mutex</code>.</li>
</ul>
<h2 id="4-integration-with-wal-and-recovery"><a class="header" href="#4-integration-with-wal-and-recovery">4. Integration with WAL and Recovery</a></h2>
<p>The Buffer Manager is a key player in the ARIES recovery protocol.</p>
<ul>
<li><strong>Dirty Pages</strong>: When a <code>WritePageGuard</code> is dropped, if it has modified the page, it marks the page as <strong>dirty</strong>. The <code>BufferManager</code> maintains a <code>dirty_page_table</code> that tracks all dirty pages and the Log Sequence Number (LSN) of the first WAL record that caused the page to become dirty.</li>
<li><strong>Forced WAL (Write-Ahead Logging)</strong>: Before a dirty page can be written back to disk (either during eviction or a checkpoint), the <code>BufferManager</code> must ensure that all WAL records up to that page’s current LSN have been flushed to durable storage. This is the fundamental <strong>WAL rule</strong> and is enforced by the <code>flush_page</code> method, which calls <code>wal_manager.flush(lsn)</code> before writing the page to disk.</li>
</ul>
<hr>
<h2 id="for-study--discussion-6"><a class="header" href="#for-study--discussion-6">For Study &amp; Discussion</a></h2>
<ol>
<li>
<p><strong>Replacement Policies</strong>: QuillSQL uses LRU-K. What are the potential advantages of LRU-K over a simple LRU policy? What kind of workload would benefit most? Conversely, what are the trade-offs of using Clock/Second-Chance instead?</p>
</li>
<li>
<p><strong>The “Double Caching” Problem</strong>: We mentioned that using Direct I/O helps avoid double caching. If Direct I/O is disabled, how does the database’s buffer pool interact with the operating system’s file system cache? Why can this lead to suboptimal performance?</p>
</li>
<li>
<p><strong>Programming Exercise</strong>: Implement a <code>ClockReplacer</code> that adheres to the <code>Replacer</code> trait. Modify the <code>BufferManager</code> to use your new replacer instead of <code>LRUKReplacer</code>. Run the benchmark suite and compare the performance. Does it change?</p>
</li>
<li>
<p><strong>Programming Exercise</strong>: Add metrics to the <code>BufferManager</code> to track the buffer pool hit rate (i.e., <code>num_hits / (num_hits + num_misses)</code>). You could expose this via a new <code>SHOW BUFFER_STATS;</code> SQL command.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="index-module"><a class="header" href="#index-module">Index Module</a></h1>
<p>Indexes live in <code>src/storage/index/</code>. QuillSQL currently ships a B+Tree (B-link variant)
that is exposed to execution via <code>IndexHandle</code>. Indexes allow point lookups and range
scans in O(log n), dramatically reducing the need for full table scans.</p>
<hr>
<h2 id="responsibilities-7"><a class="header" href="#responsibilities-7">Responsibilities</a></h2>
<ul>
<li>Maintain an ordered key → <code>RecordId</code> mapping per indexed table.</li>
<li>Support point probes, range scans, insert/update/delete maintenance.</li>
<li>Cooperate with MVCC: entries reference heap tuples while visibility checks remain in
execution/transaction code.</li>
<li>Provide <code>IndexHandle::range_scan</code>, returning a <code>TupleStream</code> so physical operators don’t
need to know tree internals.</li>
</ul>
<hr>
<h2 id="directory-layout-7"><a class="header" href="#directory-layout-7">Directory Layout</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Path</th><th>Purpose</th><th>Key Types</th></tr>
</thead>
<tbody>
<tr><td><code>btree_index.rs</code></td><td>Core B+Tree, page formats, insert/delete logic.</td><td><code>BPlusTreeIndex</code></td></tr>
<tr><td><code>btree_iterator.rs</code></td><td>Range-scan iterator with sibling traversal.</td><td><code>TreeIndexIterator</code></td></tr>
<tr><td><code>btree_codec.rs</code></td><td>Page encode/decode utilities.</td><td><code>BPlusTreeLeafPageCodec</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h2>
<h3 id="b-link-structure"><a class="header" href="#b-link-structure">B-link Structure</a></h3>
<p>Each leaf stores a pointer to its right sibling. Iterators use this to keep scanning even
if a concurrent split occurs, avoiding restarts from the root and enabling latch-free
range scans.</p>
<h3 id="latch-crabbing"><a class="header" href="#latch-crabbing">Latch Crabbing</a></h3>
<p>Insert/delete operations climb the tree with shared latches and upgrade only when
necessary (e.g., right before splitting), reducing contention.</p>
<h3 id="range-scan--tuplestream"><a class="header" href="#range-scan--tuplestream">Range Scan → TupleStream</a></h3>
<p><code>IndexHandle::range_scan</code> wraps <code>TreeIndexIterator</code> and automatically fetches heap tuples,
returning <code>(rid, meta, tuple)</code> triples. Execution remains storage-agnostic.</p>
<h3 id="inline-maintenance"><a class="header" href="#inline-maintenance">Inline Maintenance</a></h3>
<p>Index inserts/updates/deletes modify the tree immediately and emit logical WAL for redo.
There is no deferred “index vacuum”; once a heap tuple is deleted its index entry is
removed in the same transaction.</p>
<hr>
<h2 id="interactions-9"><a class="header" href="#interactions-9">Interactions</a></h2>
<ul>
<li><strong>Catalog</strong> – stores <code>Arc&lt;BPlusTreeIndex&gt;</code> instances alongside table metadata so
execution can fetch handles directly.</li>
<li><strong>Execution</strong> – <code>PhysicalIndexScan</code> uses <code>ExecutionContext::index_stream</code>; DML operators
call <code>insert_tuple_with_indexes</code> so heap writes and index maintenance stay in sync.</li>
<li><strong>Transaction/MVCC</strong> – heaps store transaction metadata; indexes just reference RIDs, so
MVCC visibility is enforced when tuples are materialised.</li>
<li><strong>Recovery</strong> – WAL contains <code>IndexInsert/IndexDelete</code> records to replay structural
changes after crashes.</li>
</ul>
<hr>
<h2 id="teaching-ideas-9"><a class="header" href="#teaching-ideas-9">Teaching Ideas</a></h2>
<ul>
<li>Build a covering index example to show how avoiding heap lookups improves latency.</li>
<li>Instrument <code>TreeIndexIterator</code> to visualise sibling traversal during range scans.</li>
<li>Compare SeqScan vs IndexScan on selective predicates to highlight indexing benefits.</li>
</ul>
<hr>
<p>Further reading: <a href="#b-tree-index--architecture-and-concurrency">B+Tree internals</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="b-tree-index--architecture-and-concurrency"><a class="header" href="#b-tree-index--architecture-and-concurrency">B+ Tree Index — Architecture and Concurrency</a></h1>
<h2 id="1-architecture-overview"><a class="header" href="#1-architecture-overview">1. Architecture Overview</a></h2>
<h3 id="11-node-and-page-structure"><a class="header" href="#11-node-and-page-structure">1.1 Node and Page Structure</a></h3>
<ul>
<li><strong>Node Types</strong>: <code>Internal</code> and <code>Leaf</code>.
<ul>
<li><strong>Internal Nodes</strong>: Store separator keys and pointers to child pages. The first pointer is a “sentinel” that points to the subtree for all keys less than the first key in the node.</li>
<li><strong>Leaf Nodes</strong>: Store <code>(key, RecordId)</code> pairs in sorted order. Leaves are linked together in a singly linked list (<code>next_page_id</code>) to allow for efficient range scans.</li>
</ul>
</li>
<li><strong>Header Page</strong>: A fixed page (<code>header_page_id</code>) that acts as the entry point to the tree. It stores the <code>root_page_id</code>, allowing for atomic updates to the tree root when it splits or shrinks.</li>
<li><strong>Page Layout</strong>:
<ul>
<li><strong>Internal Page</strong>: <code>{Header, High Key, Array&lt;(Key, ChildPageId)&gt;}</code>. The <code>High Key</code> is part of the B-link optimization.</li>
<li><strong>Leaf Page</strong>: <code>{Header, Array&lt;(Key, RID)&gt;}</code>.</li>
</ul>
</li>
</ul>
<h3 id="12-b-link-structure"><a class="header" href="#12-b-link-structure">1.2 B-link Structure</a></h3>
<p>The tree uses B-link pointers (<code>next_page_id</code>) on all levels (both internal and leaf nodes). This creates a “side-link” to the right sibling. This is crucial for concurrency, as it allows readers to recover from transient inconsistent states caused by concurrent page splits by “chasing” the link to the right sibling.</p>
<pre><code>              +------------------+
              |   Root (Int)     |
              +------------------+
             /         |         \
   +--------+      +--------+      +--------+
   | Int P1 |-----&gt;| Int P2 |-----&gt;| Int P3 |  (Internal B-link pointers)
   +--------+      +--------+      +--------+
   /   |   \      /   |   \      /   |   \
+----+ +----+  +----+ +----+  +----+ +----+
| L1 |-| L2 |-&gt;| L3 |-| L4 |-&gt;| L5 |-| L6 | (Leaf chain / B-links)
+----+ +----+  +----+ +----+  +----+ +----+
</code></pre>
<h2 id="2-concurrency-control"><a class="header" href="#2-concurrency-control">2. Concurrency Control</a></h2>
<p>The B+Tree employs a sophisticated, lock-free read path and a high-concurrency write path using latch crabbing.</p>
<h3 id="21-read-path-optimistic-lock-coupling-olc-with-b-links"><a class="header" href="#21-read-path-optimistic-lock-coupling-olc-with-b-links">2.1 Read Path: Optimistic Lock Coupling (OLC) with B-links</a></h3>
<ul>
<li>Readers traverse the tree from the root without taking any locks.</li>
<li>On each page, a <code>version</code> number is read before and after processing the page’s contents. If the version changes, it indicates a concurrent modification, and the read operation restarts from the root.</li>
<li>If a reader is traversing an internal node and the search key is greater than or equal to the node’s <code>high_key</code>, it knows a split has occurred. Instead of restarting, it can use the <code>next_page_id</code> B-link to “chase” to the right sibling and continue the search, minimizing restarts.</li>
</ul>
<h3 id="22-write-path-latch-crabbing"><a class="header" href="#22-write-path-latch-crabbing">2.2 Write Path: Latch Crabbing</a></h3>
<p>Writers (insert/delete) use a technique called <strong>latch crabbing</strong> (or lock coupling) to ensure safe concurrent modifications.</p>
<ul>
<li><strong>Process</strong>: A writer acquires a write latch on a parent node before fetching and latching a child node. Once the child is latched, the writer checks if the child is “safe” for the operation (i.e., not full for an insert, not at minimum size for a delete).
<ul>
<li>If the child is <strong>safe</strong>, the latch on the parent (and all other ancestors) is released.</li>
<li>If the child is <strong>unsafe</strong>, the parent latch is held, as the child might need to split or merge, which would require modifying the parent.</li>
</ul>
</li>
<li><strong><code>Context</code> Struct</strong>: This process is managed by a <code>Context</code> struct that holds the stack of write guards (<code>write_set</code>) for the current traversal path. Releasing ancestor latches is as simple as clearing this stack.</li>
</ul>
<pre><code>Latch Crabbing on Insert:
1. Latch(Root)
2. Descend to Child C1. Latch(C1).
3. Check if C1 is safe (not full).
   IF SAFE:
     ReleaseLatch(Root). Path is now just {C1}.
   IF UNSAFE (full):
     Keep Latch(Root). Path is {Root, C1}.
4. Descend from C1 to C2. Latch(C2).
5. Check if C2 is safe... and so on.
</code></pre>
<h3 id="23-deadlock-avoidance"><a class="header" href="#23-deadlock-avoidance">2.3 Deadlock Avoidance</a></h3>
<p>When modifying siblings (during merge or redistribution), deadlocks are possible if two threads try to acquire latches on the same two pages in opposite orders. This is prevented by enforcing a strict <strong>PageId-ordered locking</strong> protocol. When two sibling pages must be latched, the page with the lower <code>PageId</code> is always latched first.</p>
<h2 id="3-key-algorithms--features"><a class="header" href="#3-key-algorithms--features">3. Key Algorithms &amp; Features</a></h2>
<ul>
<li><strong>Parent-Guided Redirection</strong>: During an insert or delete, after a writer has descended to a leaf, it re-validates its position using the parent (if a latch is still held). If a concurrent split has moved the target key range to a different sibling, the writer can jump directly to the correct page instead of traversing the leaf chain, preventing race conditions.</li>
<li><strong>Iterator</strong>: The iterator performs a forward scan by following the leaf chain (<code>next_page_id</code>). It uses a lightweight form of OLC, checking the leaf page version to detect concurrent modifications and restart if necessary to ensure it doesn’t miss keys.
<ul>
<li>Sequential Scan Optimization (RingBuffer): For large range scans, the iterator switches to a “synchronous batch fetch + local ring buffer” mode. It fills a small <code>RingBuffer&lt;BytesMut&gt;</code> with consecutive leaf pages (by following <code>next_page_id</code>) and then decodes KVs locally without holding page guards for long. This reduces buffer pool pollution and syscall/lock overhead.</li>
<li>Two Iteration Modes:
<ul>
<li>Guard Mode: Keep a <code>ReadPageGuard</code> and decode per step; prefetch next leaf best-effort.</li>
<li>Bytes Mode: After switching, decode from <code>BytesMut</code> buffers in the local ring; when a leaf is exhausted, pop next bytes from the ring or refill by following the chain.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Prefix Compression</strong>: Keys in internal nodes are prefix-compressed to save space. Each key is stored as <code>(lcp, suffix_len, suffix)</code>. This reduces the size of internal pages, increasing the tree’s fanout and reducing its height, which improves cache performance and reduces I/O.</li>
<li><strong>Split/Merge Safety</strong>:
<ul>
<li><strong>Split</strong>: When a node splits, the new right sibling is written first. Then, the B-link pointer and separator key are published atomically by updating the left sibling and parent. This ensures readers can always navigate the structure correctly.</li>
<li><strong>Merge/Redistribute</strong>: When a node is underfull, the implementation first tries to borrow an entry from a sibling (redistribute). If both siblings are at minimum size, it merges with a sibling. All these operations carefully maintain the B-link chain and parent pointers.</li>
</ul>
</li>
</ul>
<h2 id="4-benchmarks--performance"><a class="header" href="#4-benchmarks--performance">4. Benchmarks &amp; Performance</a></h2>
<h3 id="41-example-range-scan-benchmark"><a class="header" href="#41-example-range-scan-benchmark">4.1 Example: Range Scan Benchmark</a></h3>
<p>This benchmark measures the efficiency of the leaf-chain traversal, which is critical for <code>SELECT</code> queries with <code>WHERE</code> clauses on indexed columns. It benefits from iterator prefetching and prefix compression.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pseudo-code for a range scan benchmark
use std::time::Instant;

fn benchmark_range_scan(index: Arc&lt;BPlusTreeIndex&gt;, num_keys: i64, num_passes: usize) {
    // 1. Populate the index with sequential keys
    for key in 1..=num_keys {
        let tuple = create_tuple_from_key(key, index.key_schema.clone());
        index.insert(&amp;tuple, create_rid_from_key(key)).unwrap();
    }

    // 2. Run the benchmark
    let start = Instant::now();
    let mut count = 0;
    for _ in 0..num_passes {
        // Create an iterator over the full key range
        let mut iter = TreeIndexIterator::new(index.clone(), ..);
        while let Some(_) = iter.next().unwrap() {
            count += 1;
        }
    }
    let elapsed = start.elapsed();
    let total_items_scanned = num_keys as usize * num_passes;
    let items_per_sec = total_items_scanned as f64 / elapsed.as_secs_f64();

    println!(
        "Range Scan: Scanned {} items in {:?}. Throughput: {:.2} items/sec",
        total_items_scanned, elapsed, items_per_sec
    );
}
<span class="boring">}</span></code></pre>
<h3 id="42-performance-notes"><a class="header" href="#42-performance-notes">4.2 Performance Notes</a></h3>
<ul>
<li><strong>Hot Reads</strong>: Performance on hot-spot reads depends on keeping upper levels and hot leaves resident in the buffer pool. Warm up the cache for read-heavy benchmarks. Protect hot pages from pollution by enabling TinyLFU admission.</li>
<li><strong>Large Range Scans</strong>: Prefer table SeqScan with ring buffer (bypass) when scanning most of the table. For index scans over very large ranges, consider future Bitmap Heap Scan rather than bypassing the pool for leaves.</li>
</ul>
<h3 id="43-configuration"><a class="header" href="#43-configuration">4.3 Configuration</a></h3>
<ul>
<li><code>config::BTreeConfig</code> controls iterator behavior:
<ul>
<li><code>seq_batch_enable</code> (bool): enable batch mode with local ring buffer.</li>
<li><code>seq_window</code> (usize): number of leaf pages to prefill into the ring per refill.</li>
<li><code>prefetch_enable</code>/<code>prefetch_window</code>: guard-mode prefetch hints to buffer pool.
Defaults are conservative; increase <code>seq_window</code> for long scans to reduce I/O hop.</li>
</ul>
</li>
</ul>
<h2 id="5-future-work"><a class="header" href="#5-future-work">5. Future Work</a></h2>
<ul>
<li>Stronger OLC with bounded retries and telemetry.</li>
<li>CSB+-like internal layout and columnar key prefixing.</li>
<li>NUMA-aware partitioning and router.</li>
<li>WAL/MVCC for crash recovery and snapshot isolation.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="recovery--wal-module"><a class="header" href="#recovery--wal-module">Recovery / WAL Module</a></h1>
<p><code>src/recovery/</code> guarantees the Durability part of ACID. Through WAL, checkpoints, and the
ARIES algorithm, QuillSQL can recover to a consistent state after crashes.</p>
<hr>
<h2 id="responsibilities-8"><a class="header" href="#responsibilities-8">Responsibilities</a></h2>
<ul>
<li>Generate WAL records for every change and assign monotonically increasing LSNs.</li>
<li>Manage WAL buffers, synchronous flushes, and the optional background WAL writer.</li>
<li>Run the ARIES Analysis → Redo → Undo sequence during startup.</li>
<li>Maintain the control file so the latest checkpoint and log truncation point are known.</li>
</ul>
<hr>
<h2 id="directory-layout-8"><a class="header" href="#directory-layout-8">Directory Layout</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Path</th><th>Description</th><th>Key Types</th></tr>
</thead>
<tbody>
<tr><td><code>recovery/wal/</code></td><td>Log writer, buffer, storage, background writer runtime.</td><td><code>WalManager</code>, <code>WalBuffer</code>, <code>WalStorage</code></td></tr>
<tr><td><code>recovery/wal_record.rs</code></td><td>Serialized record variants exposed to subsystems.</td><td><code>WalRecordPayload</code>, <code>ResourceManagerId</code></td></tr>
<tr><td><code>recovery/resource_manager.rs</code></td><td>Registry that maps payloads to redo/undo handlers.</td><td><code>ResourceManager</code>, <code>RedoContext</code>, <code>UndoContext</code></td></tr>
<tr><td><code>recovery/recovery_manager.rs</code></td><td>ARIES driver.</td><td><code>RecoveryManager</code>, <code>RecoverySummary</code></td></tr>
<tr><td><code>recovery/control_file.rs</code></td><td>Persistent metadata (checkpoint info).</td><td><code>ControlFileManager</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="walmanager--io-pipeline"><a class="header" href="#walmanager--io-pipeline">WalManager &amp; I/O pipeline</a></h2>
<ul>
<li><strong>Buffering</strong> – <code>WalManager</code> uses a lock-free <code>WalBuffer</code> ring. <code>append_record_with</code>
attaches an LSN, encodes the frame, pushes it into the ring, and auto-flushes when
either record count or byte thresholds (<code>max_buffer_records</code>,
<code>flush_coalesce_bytes</code>, or a full WAL page) are met. Writers never block on Vec
reallocation and thus scale with concurrent transactions.</li>
<li><strong>Physical logging</strong> – <code>log_page_update</code> emits 4 KiB <code>PageWrite</code> FPWs on first touch
(tracked via <code>DashSet&lt;PageId&gt;</code>) or when logical redo is unavailable. Payloads carry
the previous <code>page_lsn</code> so redo can enforce the WAL rule.</li>
<li><strong>Segmentation &amp; flush</strong> – <code>WalStorage</code> appends frames to rolling segments under the
configured WAL directory, queues async write/fsync tickets via the <code>DiskScheduler</code>
sink, and recycles sealed segments after checkpoints. <code>flush()</code> drains buffered
records up to an optional target LSN, waits for outstanding tickets, updates
<code>durable_lsn</code>, and optionally persists the control file snapshot.</li>
<li><strong>Background writer</strong> – <code>start_background_flush</code> spawns <code>WalWriterRuntime</code>, which
periodically calls <code>flush(None)</code>; <code>WalWriterHandle</code> lives in the background worker
registry so shutdown is coordinated with the db lifecycle.</li>
<li><strong>Checkpoints</strong> – <code>log_checkpoint</code> writes a <code>Checkpoint</code> frame containing ATT/DPT,
forces a flush, clears the “first-touch” set (so new FPWs are generated as needed),
and updates <code>checkpoint_redo_start</code> in the control file. Recovery uses this redo
start to avoid rescanning the whole log.</li>
<li><strong>Readers &amp; durability waits</strong> – <code>WalManager::reader</code> iterates frames straight from
the WAL directory. <code>wait_for_durable</code> is the gate that synchronous commits call
after emitting a commit record; it reuses <code>flush_with_mode</code> and condition variables
to block until <code>durable_lsn &gt;= target</code>.</li>
</ul>
<h2 id="record-types--resource-managers"><a class="header" href="#record-types--resource-managers">Record types &amp; resource managers</a></h2>
<p>All log frames share the envelope defined in <code>wal_record.rs</code> and are routed by
<code>ResourceManagerId</code>:</p>
<ul>
<li><strong>Page (<code>ResourceManagerId::Page</code>)</strong> – purely physical <code>PageWrite</code> payloads. The page
resource manager checks <code>page_lsn</code> (buffer pool if available) before rewriting the
page on redo. No undo is required because these are low-level physical changes.</li>
<li><strong>Heap (<code>ResourceManagerId::Heap</code>)</strong> – logical payloads include relation id, page/slot,
tuple metadata, and tuple bytes. <code>HeapResourceManager</code> applies inserts/overwrites at
the slot level with LSN checks and repacks slotted pages. Undo uses the stored
before-image (metadata + bytes) for loser transactions.</li>
<li><strong>Index (<code>ResourceManagerId::Index</code>)</strong> – logs leaf inserts/deletes plus structural
changes (split/merge/redistribute, parent updates, root install/adopt/reset). Redo
mutates leaves or rebuilds structural pages with LSN/version guards; undo mirrors
leaf inserts/deletes only. Heap and index WAL remain independent.</li>
<li><strong>Transaction / CLR / Checkpoint</strong> – <code>TransactionPayload</code> (BEGIN/COMMIT/ABORT)
enables the undo index to link per-transaction log records. <code>ClrPayload</code> documents
each undo step so the recovery process can survive crashes mid-undo. Checkpoints
snapshot ATT + DPT for the analysis phase.</li>
</ul>
<p><code>ensure_default_resource_managers_registered</code> wires Page, Heap, and Index resource
managers together so both redo (<code>RedoExecutor</code>) and undo (<code>UndoExecutor</code>) can dispatch
records uniformly.</p>
<h2 id="heap--index-wal-design"><a class="header" href="#heap--index-wal-design">Heap / Index WAL design</a></h2>
<ul>
<li><strong>Heap</strong> – Execution operators call <code>ExecutionContext::insert_tuple_with_indexes</code>
(and friends), which ultimately invoke <code>MvccHeap</code> to write WAL before dirtying the
page. Each tuple carries <code>TupleMetaRepr</code> (insert/delete txn + CID, MVCC chain
pointers) plus encoded column bytes. During redo, <code>HeapResourceManager</code> applies
inserts or overwrites at the slot level with LSN checks and repacks the slotted page
before writing it back via <code>TableHeap::recovery_view</code>. Undo leverages the stored
before-image to restore bytes or toggle delete flags; vacuum code can later reclaim
dead slots once <code>safe_xmin</code> passes them.</li>
<li><strong>Index</strong> – B+Tree leaf operations log the logical key/value change, plus structural
records for split/merge/redistribute/parent updates and root install/adopt/reset.
Redo loads or rebuilds pages (buffer pool or disk), checks page LSN/version to avoid
reapplying newer changes, and performs the requested mutation. Undo mirrors
leaf-level inserts/deletes only. Heap and index WAL stay independent.</li>
<li><strong>Page images</strong> – For heap/index structural changes that rewrite large sections (e.g.,
new heap page, B+Tree splits), page guards still emit FPWs through
<code>WalManager::log_page_update</code>. Logical heap/index WAL ensures redo still works even
when FPWs are skipped after the first touch.</li>
</ul>
<hr>
<h2 id="aries-recovery"><a class="header" href="#aries-recovery">ARIES Recovery</a></h2>
<ol>
<li><strong>Analysis</strong> – read the latest checkpoint, rebuild the Dirty Page Table (DPT) and
Active Transaction Table (ATT).</li>
<li><strong>Redo</strong> – scan forward from the checkpoint LSN, reapplying operations when the DPT
indicates a page may be out of date.</li>
<li><strong>Undo</strong> – roll back transactions still in ATT, writing Compensation Log Records (CLR)
so the process is idempotent even if another crash happens mid-undo.</li>
</ol>
<p><code>RecoverySummary</code> reports how many records were redone and which transactions require
manual attention—great for classroom demonstrations.</p>
<hr>
<h2 id="interactions-10"><a class="header" href="#interactions-10">Interactions</a></h2>
<ul>
<li><strong>TransactionManager</strong> – emits <code>Begin</code>, <code>Commit</code>, <code>Abort</code> records and supplies undo
information.</li>
<li><strong>BufferManager</strong> – links to WAL via <code>set_wal_manager</code>; checkpoints rely on the buffer’s
dirty page metadata.</li>
<li><strong>Background workers</strong> – WAL writer and checkpoint worker live in <code>background</code> and use
handles exposed by <code>WalManager</code>.</li>
</ul>
<hr>
<h2 id="teaching-ideas-10"><a class="header" href="#teaching-ideas-10">Teaching Ideas</a></h2>
<ul>
<li>Simulate crashes (e.g., panic right after <code>wal_manager.flush(None)</code>) and inspect log
output on restart.</li>
<li>Add a new WAL record type (like <code>CreateIndex</code>) to see how <code>RecoveryManager</code> must be
extended.</li>
<li>Compare physical vs logical redo costs to discuss ARIES trade-offs.</li>
</ul>
<h2 id="recovery-lab-playbook-cmu-15-445-style"><a class="header" href="#recovery-lab-playbook-cmu-15-445-style">Recovery Lab Playbook (CMU 15-445 style)</a></h2>
<ol>
<li><strong>Mini ARIES</strong> – Disable the background WAL writer, perform a few INSERT/UPDATE
operations, crash the process mid-transaction, and single-step through
<code>analysis_pass.rs</code> to observe ATT/DPT reconstruction.</li>
<li><strong>Logical vs physical redo</strong> – Comment out <code>WalManager::log_page_update</code> for heap
pages and re-run the experiment. Recovery still succeeds thanks to logical heap
payloads; re-enable FPWs to contrast log volume.</li>
<li><strong>Index crash test</strong> – Inject a panic after <code>BPlusTreeIndex::insert</code> logs a leaf
insert. On restart, watch the undo phase remove the stray key before replay finishes.</li>
<li><strong>Group commit tuning</strong> – Play with <code>WalOptions::flush_coalesce_bytes</code>,
<code>writer_interval_ms</code>, and <code>synchronous_commit</code> to demonstrate how throughput vs
latency tradeoffs mirror the 15-445 checkpoints/commit labs.</li>
</ol>
<hr>
<p>Further reading: <a href="#the-aries-recovery-protocol">ARIES details</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-aries-recovery-protocol"><a class="header" href="#the-aries-recovery-protocol">The ARIES Recovery Protocol</a></h1>
<p>Of the four ACID properties, <strong>Durability</strong> is the one that guarantees that once a transaction is committed, its changes will survive any subsequent system failure. In a disk-based database, this is achieved through a careful and robust recovery protocol. QuillSQL implements a recovery strategy inspired by the well-known <strong>ARIES</strong> (Algorithm for Recovery and Isolation Exploiting Semantics) protocol, centered around a <strong>Write-Ahead Log (WAL)</strong>.</p>
<h2 id="1-the-write-ahead-logging-wal-principle"><a class="header" href="#1-the-write-ahead-logging-wal-principle">1. The Write-Ahead Logging (WAL) Principle</a></h2>
<p>The fundamental rule of WAL is simple but powerful:</p>
<blockquote>
<p><strong>Before a modified data page is ever written from memory back to disk, the log record describing that modification must first be written to durable storage (the log file).</strong></p>
</blockquote>
<p>This allows the database to perform most of its data modifications in memory on the <a href="#buffer-manager">Buffer Pool</a> without needing to synchronously write every changed page to disk, which would be extremely slow. In case of a crash, the database can use the log to reconstruct the state of the system and ensure all committed changes are present and all uncommitted changes are undone.</p>
<h3 id="log-records-walrecord"><a class="header" href="#log-records-walrecord">Log Records (<code>WalRecord</code>)</a></h3>
<p>The WAL is a sequential, append-only file composed of <strong>log records</strong>. Each record is assigned a unique, monotonically increasing <strong>Log Sequence Number (LSN)</strong>. A log record in QuillSQL (<code>src/recovery/wal_record.rs</code>) generally contains:</p>
<ul>
<li><strong>LSN</strong>: The address of the log record.</li>
<li><strong>Transaction ID</strong>: The ID of the transaction that generated this record.</li>
<li><strong>Payload</strong>: The actual content of the log record, which varies by type.</li>
</ul>
<p>QuillSQL uses several types of log records:</p>
<ul>
<li><strong><code>Transaction</code></strong>: Marks the <code>BEGIN</code>, <code>COMMIT</code>, or <code>ABORT</code> of a transaction.</li>
<li><strong><code>PageWrite</code></strong>: Physical records describing a change to a page. <code>PageWrite</code> contains a full image of the page (used for first-touch or when logical redo is unavailable), a First-Page-Write (FPW) style safeguard.</li>
<li><strong><code>HeapInsert</code> / <code>HeapDelete</code></strong>: Logical tuple-level records. Each delete carries the full before-image so undo can always restore bytes/metadata.</li>
<li><strong><code>Index*</code></strong>: Logical B+Tree records covering leaf inserts/deletes and structural changes (split/merge/redistribute, parent updates, root install/adopt/reset).</li>
<li><strong><code>Checkpoint</code></strong>: A special record that marks a point of partial durability, allowing the log to be truncated.</li>
<li><strong><code>CLR</code> (Compensation Log Record)</strong>: A special record written during recovery to describe an <strong>undo</strong> action. CLRs are redo-only and are never undone themselves.</li>
</ul>
<h2 id="2-the-aries-recovery-protocol"><a class="header" href="#2-the-aries-recovery-protocol">2. The ARIES Recovery Protocol</a></h2>
<p>On database startup, the <code>RecoveryManager</code> (<code>recovery/recovery_manager.rs</code>) is invoked to <code>replay()</code> the WAL. This process follows the three phases of ARIES.</p>
<h3 id="phase-1-analysis"><a class="header" href="#phase-1-analysis">Phase 1: Analysis</a></h3>
<p>The goal of the Analysis phase (<code>recovery/analysis.rs</code>) is to figure out the state of the database at the exact moment of the crash.</p>
<ol>
<li>It starts by finding the last successful <code>Checkpoint</code> record in the WAL.</li>
<li>It then scans the log <strong>forward</strong> from that checkpoint to the end of the log.</li>
<li>During this scan, it builds two critical data structures:
<ul>
<li><strong>Active Transaction Table (ATT)</strong>: A list of all transactions that have a <code>BEGIN</code> record but no corresponding <code>COMMIT</code> or <code>ABORT</code> record. These are the potential “loser” transactions that will need to be undone.</li>
<li><strong>Dirty Page Table (DPT)</strong>: A list of all pages that were modified in the buffer pool but might not have been written to disk before the crash. For each dirty page, it records the LSN of the <em>first</em> log record that made it dirty (this is called the <code>recLSN</code>).</li>
</ul>
</li>
</ol>
<p>At the end of this phase, the <code>RecoveryManager</code> knows exactly which transactions to roll back and the earliest point in the log from which it needs to start re-applying changes.</p>
<h3 id="phase-2-redo-repeating-history"><a class="header" href="#phase-2-redo-repeating-history">Phase 2: Redo (Repeating History)</a></h3>
<p>The goal of the Redo phase (<code>recovery/redo.rs</code>) is to restore the database to its exact state at the moment of the crash, including all changes from both committed and uncommitted (loser) transactions.</p>
<ol>
<li>The Redo phase finds the smallest <code>recLSN</code> from the Dirty Page Table built during Analysis. This LSN is the starting point for the redo scan.</li>
<li>It scans the log <strong>forward</strong> from this starting point.</li>
<li>For every log record it encounters that describes a change to a page (e.g., <code>PageWrite</code>, <code>Heap*</code>, <code>Index*</code>), it re-applies the change. This is idempotent: if the change is already present on the page (because it was successfully flushed to disk before the crash), re-applying it does no harm.</li>
</ol>
<p>At the end of this phase, the database state on disk is identical to how it was in memory right before the crash.</p>
<h3 id="phase-3-undo-rolling-back-losers"><a class="header" href="#phase-3-undo-rolling-back-losers">Phase 3: Undo (Rolling Back Losers)</a></h3>
<p>The final phase (<code>recovery/undo.rs</code>) is responsible for rolling back all the “loser” transactions identified during Analysis.</p>
<ol>
<li>The <code>UndoExecutor</code> takes the list of loser transactions.</li>
<li>For each loser transaction, it scans the WAL <strong>backwards</strong>, following the chain of log records for that transaction.</li>
<li>For each operation record (like <code>HeapInsert</code>, <code>HeapDelete</code>), it performs the logical inverse operation:
<ul>
<li>To undo an <code>Insert</code>, it performs a <code>Delete</code>.</li>
<li>To undo a <code>Delete</code>, it restores the deleted data.</li>
</ul>
</li>
<li><strong>Crucially</strong>, for every undo action it performs, it writes a <strong>Compensation Log Record (CLR)</strong> to the WAL. The CLR contains information about the undo action and, importantly, a pointer to the <em>next</em> log record that needs to be undone for that transaction.</li>
</ol>
<p>This use of CLRs makes the recovery process itself crash-proof. If the system crashes <em>during the undo phase</em>, the next time recovery runs, it will see the CLRs. It will simply continue the undo process from where it left off by following the pointers in the CLRs, without ever having to undo an undo action.</p>
<h2 id="3-checkpoints"><a class="header" href="#3-checkpoints">3. Checkpoints</a></h2>
<p>If the log were allowed to grow forever, recovery would become slower and slower. <strong>Checkpoints</strong> are a background process that periodically creates a point of partial durability.</p>
<p>A checkpoint does the following:</p>
<ol>
<li>Temporarily stops new transactions from starting.</li>
<li>Writes a <code>BEGIN_CHECKPOINT</code> record to the WAL, containing the current ATT and DPT.</li>
<li>Flushes all dirty pages from the buffer pool to disk.</li>
<li>Writes an <code>END_CHECKPOINT</code> record to the WAL.</li>
</ol>
<p>Once a checkpoint is complete, the <code>RecoveryManager</code> knows that all changes described in log records before the <code>BEGIN_CHECKPOINT</code> record are safely on disk. Therefore, those older parts of the WAL file are no longer needed for recovery and can be truncated or recycled, keeping the recovery process efficient.</p>
<hr>
<h2 id="for-study--discussion-7"><a class="header" href="#for-study--discussion-7">For Study &amp; Discussion</a></h2>
<ol>
<li>
<p><strong>Repeating History</strong>: The Redo phase re-applies changes from <em>all</em> transactions, including those that will be undone later (the “losers”). This seems wasteful. Why is this “repeating history” approach a core principle of ARIES? What would go wrong if we tried to only redo changes from committed transactions?</p>
</li>
<li>
<p><strong>Compensation Log Records (CLRs)</strong>: What specific problem would occur if the system crashed during the Undo phase and we <em>didn’t</em> write CLRs? How does a CLR’s “redo-only” nature make the recovery process idempotent and robust against repeated crashes?</p>
</li>
<li>
<p><strong>Checkpointing Frequency</strong>: What are the performance trade-offs between checkpointing very frequently versus very infrequently? Consider both normal runtime performance and the time it takes to recover after a crash.</p>
</li>
<li>
<p><strong>Programming Exercise</strong>: Add a new WAL record type. For example, a <code>HeapReclaim</code> record that logs the physical removal of a dead tuple by a vacuum process. To do this, you would need to:
a.  Add a variant to the <code>HeapRecordPayload</code> enum in <code>wal_record.rs</code>.
b.  Update the <code>codec</code> functions to handle its serialization.
c.  Decide what information the <code>HeapReclaim</code> record needs to contain.
d.  Implement the <code>redo</code> logic for this new record in the appropriate <code>ResourceManager</code>. What should happen when you redo a <code>HeapReclaim</code> record?</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="write-ahead-logging"><a class="header" href="#write-ahead-logging">Write-Ahead Logging</a></h1>
<p>This note dives into the WAL subsystem that powers QuillSQL’s recovery story. It
explains how frames are generated, buffered, flushed, and replayed, and why logical
heap/index records complement traditional physical FPWs.</p>
<hr>
<h2 id="1-component-map"><a class="header" href="#1-component-map">1. Component map</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Layer</th><th>Location</th><th>Responsibility</th></tr>
</thead>
<tbody>
<tr><td><strong>WalManager</strong></td><td><code>src/recovery/wal/mod.rs</code></td><td>Assigns LSNs, encodes <code>WalRecordPayload</code>, enqueues frames, and drives <code>WalStorage::flush</code>.</td></tr>
<tr><td><strong>WalBuffer</strong></td><td><code>src/recovery/wal/buffer.rs</code></td><td>Lock-free ring buffer (<code>ConcurrentRingBuffer</code>) that tracks pending frame count, bytes, and highest end LSN.</td></tr>
<tr><td><strong>WalStorage</strong></td><td><code>src/recovery/wal/storage.rs</code></td><td>Maintains WAL directory/segments, builds <code>WalPage</code>s, and dispatches write/fsync tickets to a <code>WalSink</code> (default: <code>DiskSchedulerWalSink</code>).</td></tr>
<tr><td><strong>WalWriterRuntime</strong></td><td><code>src/recovery/wal/writer.rs</code></td><td>Background thread that periodically calls <code>WalManager::flush(None)</code>.</td></tr>
<tr><td><strong>ControlFileManager</strong></td><td><code>src/recovery/control_file.rs</code></td><td>Persists <code>durable_lsn</code>, <code>max_assigned_lsn</code>, checkpoint metadata, and redo start for fast crash recovery.</td></tr>
<tr><td><strong>Resource managers</strong></td><td><code>src/recovery/resource_manager.rs</code>, <code>storage/*/heap_recovery.rs</code>, <code>storage/*/index_recovery.rs</code></td><td>Decode payloads per <code>ResourceManagerId</code> and execute redo/undo logic for heap/index/page operations.</td></tr>
</tbody>
</table>
</div>
<p>End-to-end DML flow:</p>
<ol>
<li><code>ExecutionContext</code> mutates tuples/index entries via <code>TableHeap</code> / <code>BPlusTreeIndex</code>.</li>
<li>Operators invoke <code>WalManager::append_record_with</code> or <code>log_page_update</code> after data-page
changes succeed.</li>
<li>Frames enter <code>WalBuffer</code>. Once thresholds are met, <code>flush()</code> drains frames into
<code>WalStorage</code>, which schedules asynchronous writes/fsyncs.</li>
<li>During commit, <code>TransactionManager</code> waits on <code>WalManager::wait_for_durable(lsn)</code> to
guarantee WAL persistence before releasing locks.</li>
</ol>
<hr>
<h2 id="2-frame--record-taxonomy"><a class="header" href="#2-frame--record-taxonomy">2. Frame &amp; record taxonomy</a></h2>
<p><code>wal_record.rs</code> defines the canonical envelope. <code>encode_frame(lsn, prev_lsn, payload)</code>
serializes a record, while <code>WalAppendContext</code> reports the LSN range back to the caller.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>ResourceManagerId</th><th>Payload</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Page</code></td><td><code>PageWritePayload</code></td><td>Full-page image (FPW) on first-touch; also used when logical redo is not available.</td></tr>
<tr><td><code>Heap</code></td><td><code>HeapRecordPayload::{Insert,Delete}</code></td><td>Logical tuple records carrying relation id, page/slot, <code>TupleMetaRepr</code>, and tuple bytes (delete payloads always carry the before-image).</td></tr>
<tr><td><code>Index</code></td><td><code>IndexRecordPayload::{LeafInsert,LeafDelete,Leaf/Internal Split/Merge/Redistribute,Parent*,Root*}</code></td><td>Logical B+Tree leaf mutations plus structural changes (split/merge/redistribute, parent updates, root install/adopt/reset).</td></tr>
<tr><td><code>Transaction</code></td><td><code>TransactionPayload</code></td><td>BEGIN / COMMIT / ABORT markers that seed Undo’s per-txn chains.</td></tr>
<tr><td><code>Checkpoint</code></td><td><code>CheckpointPayload</code></td><td>Captures ATT/DPT snapshots plus redo start.</td></tr>
<tr><td><code>Clr</code></td><td><code>ClrPayload</code></td><td>Compensation Log Records documenting each undo step and its <code>undo_next_lsn</code>.</td></tr>
</tbody>
</table>
</div>
<p><code>ResourceManagerId</code> determines how <code>RedoExecutor</code> / <code>UndoExecutor</code> route frames:
Page → physical redo only; Heap/Index → logical redo/undo using storage helpers;
Transaction/CLR/Checkpoint → interpreted by the analysis/undo phases.</p>
<hr>
<h2 id="3-heap-wal-mvcc-aware-logical-logging"><a class="header" href="#3-heap-wal-mvcc-aware-logical-logging">3. Heap WAL: MVCC-aware logical logging</a></h2>
<ul>
<li><strong>Emission points</strong> – <code>TableHeap::{insert,update,delete}_tuple</code> call
<code>append_heap_record</code> (see <code>src/storage/heap/mvcc_heap.rs</code>) before the data page is
overwritten. Each record stores the relation identifier, page/slot, tuple metadata,
and tuple bytes (delete payloads include the exact before-image).</li>
<li><strong>Encoding</strong> – <code>src/storage/heap/wal_codec.rs</code> serializes <code>TupleMeta</code> (insert/delete
txn id, command id, MVCC chain pointers) plus tuple bytes in a compact layout.</li>
<li><strong>Redo</strong> – <code>HeapResourceManager</code> (<code>src/storage/heap/heap_recovery.rs</code>) decodes the
payload and applies it at the slot level (insert/overwrite) with an LSN check; it
repacks the slotted page layout to keep offsets consistent and sets page LSN to the
frame LSN.</li>
<li><strong>Undo</strong> – Always restores the stored before-image (metadata + tuple bytes) for loser
transactions, removing the optional/branchy path.</li>
<li><strong>Interaction with FPW</strong> – Heap logical redo handles tuple-level replay; FPWs are only
used on first-touch or when no logical log exists for a page.</li>
</ul>
<hr>
<h2 id="4-index-wal-logical-btree-leaf-operations"><a class="header" href="#4-index-wal-logical-btree-leaf-operations">4. Index WAL: logical B+Tree leaf operations</a></h2>
<ul>
<li><strong>Emission points</strong> – <code>BPlusTreeIndex</code> logs every leaf insert/delete and all structural
changes (split/merge/redistribute, parent updates, root install/adopt/reset) via
<code>append_index_record</code> (<code>src/storage/index/btree_index.rs</code>), using
<code>src/storage/index/wal_codec.rs</code> to encode key schema, key bytes, page ids, and txns.</li>
<li><strong>Redo</strong> (<code>src/storage/index/index_recovery.rs</code>) steps:
<ol>
<li>Decode the key with <code>TupleCodec</code> using the stored schema.</li>
<li>Fetch the target page through the buffer pool (preferred) or <code>DiskScheduler</code>.</li>
<li>Skip if <code>page_lsn &gt;= frame_lsn</code>; otherwise apply the logical mutation/structural
rebuild and bump the page version.</li>
<li>Write the updated page back with the frame LSN (including header root pointer for
root install/adopt/reset).</li>
</ol>
</li>
<li><strong>Undo</strong> – Inverts leaf inserts/deletes for loser transactions. Structural records are
redo-only (idempotent via LSN/version checks).</li>
<li><strong>Benefits</strong> – Heap and index WAL are decoupled; logical leaf updates and structured
payloads avoid full-page writes while remaining crash-safe for splits/merges/root
changes.</li>
</ul>
<hr>
<h2 id="5-buffering--flush-strategy"><a class="header" href="#5-buffering--flush-strategy">5. Buffering &amp; flush strategy</a></h2>
<ul>
<li><strong>Thresholds</strong> – <code>max_buffer_records</code> (from <code>WalOptions::buffer_capacity</code>),
<code>flush_coalesce_bytes</code>, and one WAL page (4 KiB) trigger batched flushes.</li>
<li><strong>Flush mechanics</strong> – <code>WalManager::flush_with_mode</code> drains frames up to a target LSN,
asks <code>WalStorage::append_records</code> to write them, then waits on all <code>WalFlushTicket</code>s.
<code>flush_until</code> forces durability before commit or after undo.</li>
<li><strong>Checkpoints</strong> – <code>log_checkpoint</code> forces a flush, records <code>checkpoint_redo_start</code> in
the control file, and clears the “touched pages” set so new FPWs fire only once per
checkpoint interval.</li>
<li><strong>Background writer</strong> – <code>WalWriterRuntime</code> runs when <code>WalOptions::writer_interval_ms</code>
is non-zero, smoothing out flush pressure even when foreground transactions are light.</li>
</ul>
<hr>
<h2 id="6-relation-to-aries"><a class="header" href="#6-relation-to-aries">6. Relation to ARIES</a></h2>
<ol>
<li><strong>Analysis</strong> – <code>AnalysisPass</code> parses the latest checkpoint, reconstructs ATT/DPT by
scanning the tail of the log, and chooses a redo start (<code>min(dpt.rec_lsn)</code>).</li>
<li><strong>Redo (repeat history)</strong> – <code>RedoExecutor</code> iterates from <code>start_lsn</code>, invoking the
appropriate resource manager for each frame. Page RM checks pageLSN before applying
FPW/delta; Heap/Index RMs use logical payloads to rebuild tuples or leaf entries.</li>
<li><strong>Undo</strong> – <code>UndoExecutor</code> chains loser transactions backwards, calling each resource
manager’s undo method and emitting CLRs with <code>undo_next_lsn</code>. If recovery crashes
mid-undo, the next run resumes at the recorded <code>undo_next_lsn</code>.</li>
</ol>
<hr>
<h2 id="7-tuning--troubleshooting"><a class="header" href="#7-tuning--troubleshooting">7. Tuning &amp; troubleshooting</a></h2>
<ul>
<li><strong>Configuration</strong> – <code>WalOptions</code> inside <code>DatabaseOptions</code> expose <code>segment_size</code>,
<code>sync_on_flush</code>, <code>writer_interval_ms</code>, <code>synchronous_commit</code>, <code>retain_segments</code>, etc.</li>
<li><strong>Introspection</strong> – <code>WalManager::pending_records()</code> dumps in-memory frames for
debugging; <code>background::BackgroundWorkers::snapshot()</code> reports WAL writer/checkpoint
worker metadata. Enabling <code>RUST_LOG=trace</code> reveals FPW vs delta decisions and flush
cadence.</li>
<li><strong>Crash testing</strong> – Insert a forced <code>std::process::exit(1)</code> after specific DMLs, then
restart and inspect <code>RecoverySummary</code> (redo count + loser transactions) to ensure
heap/index WAL cover the intended cases.</li>
</ul>
<hr>
<p>With logical heap/index records plus FPWs as a safety net, QuillSQL’s WAL stays
teaching-friendly while mirroring production-grade recoverability. When introducing
new components (e.g., custom indexes or vacuum steps), define a payload + resource
manager and they will automatically participate in ARIES.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="background-services"><a class="header" href="#background-services">Background Services</a></h1>
<p><code>src/background/</code> hosts the asynchronous workers that keep a database healthy: WAL
writers, checkpoints, buffer flushers, and MVCC vacuum. A central registry makes it easy
to start/stop workers together—ideal for teaching how background maintenance supports
foreground queries.</p>
<hr>
<h2 id="responsibilities-9"><a class="header" href="#responsibilities-9">Responsibilities</a></h2>
<ul>
<li>Start workers according to configuration (<code>WalOptions</code>, <code>MvccVacuumConfig</code>, etc.).</li>
<li>Define lightweight traits (<code>CheckpointWal</code>, <code>BufferMaintenance</code>, <code>TxnSnapshotOps</code>) so
workers can run without pulling in an async runtime.</li>
<li>Provide <code>BackgroundWorkers</code>, a registry that tracks <code>WorkerHandle</code>s and shuts them down
when <code>Database</code> drops.</li>
</ul>
<hr>
<h2 id="built-in-workers"><a class="header" href="#built-in-workers">Built-in Workers</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Worker</th><th>Trigger</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td>WAL writer</td><td><code>wal_writer_interval_ms</code></td><td>Calls <code>WalManager::background_flush</code> to durably write log buffers.</td></tr>
<tr><td>Checkpoint</td><td><code>checkpoint_interval_ms</code></td><td>Captures dirty page / active txn tables and emits <code>Checkpoint</code> records to bound recovery.</td></tr>
<tr><td>Buffer writer</td><td><code>bg_writer_interval</code></td><td>Flushes dirty frames to reduce checkpoint pressure.</td></tr>
<tr><td>MVCC vacuum</td><td><code>MvccVacuumConfig</code></td><td>Removes obsolete tuple versions once <code>safe_xmin</code> advances.</td></tr>
</tbody>
</table>
</div>
<p>Every worker registers itself with <code>BackgroundWorkers</code>; <code>shutdown_all()</code> ensures threads
exit cleanly during tests or process teardown.</p>
<hr>
<h2 id="interactions-11"><a class="header" href="#interactions-11">Interactions</a></h2>
<ul>
<li><strong>WalManager</strong> – WAL writer and checkpoint workers operate on <code>Arc&lt;dyn CheckpointWal&gt;</code>.</li>
<li><strong>BufferManager</strong> – background flushers inspect dirty frames and help checkpoints
capture consistent snapshots.</li>
<li><strong>TransactionManager</strong> – MVCC vacuum queries <code>TxnSnapshotOps</code> for <code>safe_xmin</code>.</li>
</ul>
<hr>
<h2 id="teaching-ideas-11"><a class="header" href="#teaching-ideas-11">Teaching Ideas</a></h2>
<ul>
<li>Tune <code>MvccVacuumConfig::batch_limit</code> and chart how quickly old tuple versions disappear.</li>
<li>Disable a worker in tests to show why unflushed WAL or missing checkpoints lengthen
recovery.</li>
<li>Enable <code>RUST_LOG=background=info</code> to trace how these tasks complement foreground load.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="configuration--runtime-options"><a class="header" href="#configuration--runtime-options">Configuration &amp; Runtime Options</a></h1>
<p><code>src/config/</code> centralizes tunables used by <code>DatabaseOptions</code>, the CLI/HTTP front-ends, and
background workers. Keeping knobs in one place makes it easy to demonstrate how WAL,
buffering, or vacuum behavior changes under different settings.</p>
<hr>
<h2 id="key-types"><a class="header" href="#key-types">Key Types</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>DatabaseOptions</code></td><td>Top-level options when constructing a database (WAL config, default isolation, etc.).</td></tr>
<tr><td><code>WalOptions</code></td><td>WAL directory, segment size, flush strategy, writer interval, sync mode.</td></tr>
<tr><td><code>IndexVacuumConfig</code> / <code>MvccVacuumConfig</code></td><td>Background worker intervals (buffer writer, MVCC vacuum).</td></tr>
<tr><td><code>BufferPoolConfig</code></td><td>Optional overrides for pool size, TinyLFU, and replacement policy details.</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<ul>
<li>CLI/HTTP front-ends parse env vars or config files into <code>DatabaseOptions</code> and pass them
to <code>Database::new_*</code>.</li>
<li>During <code>bootstrap_storage</code>, the database wires these options into <code>WalManager</code>,
<code>DiskScheduler</code>, and <code>BackgroundWorkers</code>.</li>
<li>Workers and execution components receive <code>Arc</code> references to the relevant configs so
they can adapt at runtime without global state.</li>
</ul>
<hr>
<h2 id="teaching-ideas-12"><a class="header" href="#teaching-ideas-12">Teaching Ideas</a></h2>
<ul>
<li>Toggle <code>WalOptions::synchronous_commit</code> to discuss commit latency vs durability.</li>
<li>Shrink the buffer pool to highlight eviction behavior under different replacement
policies.</li>
<li>Adjust <code>MvccVacuumConfig</code> intervals and measure how vacuum frequency affects foreground
write throughput.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="front-ends-cli--http"><a class="header" href="#front-ends-cli--http">Front-Ends (CLI / HTTP)</a></h1>
<p>The <code>bin/</code> directory contains the user-facing entry points. Both binaries embed the same
<code>Database</code> type, so they demonstrate how the core engine can power different UIs.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Binary</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>client.rs</code></td><td>Interactive CLI (REPL) that reads SQL, executes it, and prints tabular output.</td></tr>
<tr><td><code>server.rs</code></td><td>HTTP + JSON API for integration tests or web UIs.</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="cli-binclientrs"><a class="header" href="#cli-binclientrs">CLI (<code>bin/client.rs</code>)</a></h2>
<ul>
<li>Uses <code>rustyline</code> to provide history, multi-line editing, and familiar shell shortcuts.</li>
<li>Each command calls <code>database.run(sql)</code> and formats the resulting <code>Vec&lt;Tuple&gt;</code>.</li>
<li>Supports meta commands (e.g., <code>.tables</code>) that expose catalog metadata—great for
teaching how logical objects map to physical handles.</li>
</ul>
<h2 id="http-binserverrs"><a class="header" href="#http-binserverrs">HTTP (<code>bin/server.rs</code>)</a></h2>
<ul>
<li>Built with <code>axum</code>/<code>hyper</code> (depending on the current <code>Cargo.toml</code>), exposing endpoints such as:
<ul>
<li><code>POST /query</code> – run arbitrary SQL and return rows or an error payload.</li>
<li>Health/metrics endpoints—which you can extend in labs to surface background worker
status or buffer metrics.</li>
</ul>
</li>
<li>Configuration comes from <code>QUILL_DB_FILE</code>, <code>QUILL_HTTP_ADDR</code>, <code>PORT</code>, etc., mirroring
how production services inject settings.</li>
</ul>
<hr>
<h2 id="teaching-ideas-13"><a class="header" href="#teaching-ideas-13">Teaching Ideas</a></h2>
<ul>
<li>Extend the CLI with <code>\describe table</code> to practice catalog lookups.</li>
<li>Add transaction endpoints (BEGIN/COMMIT) to the HTTP server to demonstrate how
<code>SessionContext</code> scopes transactions per connection.</li>
<li>Combine CLI interaction with <code>RUST_LOG</code> tracing to walk through the entire query
lifecycle.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="testing--documentation"><a class="header" href="#testing--documentation">Testing &amp; Documentation</a></h1>
<p>QuillSQL is intended for teaching, so the repo invests heavily in examples and automated
verification. The <code>tests/</code> tree and this mdBook work together to illustrate every module.</p>
<hr>
<h2 id="test-suite"><a class="header" href="#test-suite">Test Suite</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Location</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>tests/sql_example/*.slt</code></td><td><a href="https://www.sqlite.org/sqllogictest.html">sqllogictest</a> suites covering DDL, DML, transactions, and indexes.</td></tr>
<tr><td><code>tests/transaction_tests.rs</code></td><td>Rust unit tests that stress MVCC visibility, lock conflicts, and isolation semantics.</td></tr>
<tr><td><code>tests/storage_*</code></td><td>Component tests for heap/index/buffer internals—perfect references for lab exercises.</td></tr>
</tbody>
</table>
</div>
<p>Common commands:</p>
<pre><code class="language-bash">cargo test -q
# focused run
cargo test tests::transaction_tests::repeatable_read_sees_consistent_snapshot_after_update -- --nocapture
</code></pre>
<p>For long-running suites, wrap with <code>timeout</code> to guard against hangs.</p>
<hr>
<h2 id="documentation-mdbook"><a class="header" href="#documentation-mdbook">Documentation (mdBook)</a></h2>
<ul>
<li>The <code>docs/</code> directory is an mdBook; run <code>mdbook serve docs</code> to browse locally.</li>
<li>Each module, including this page, has a dedicated chapter so instructors can teach
subsystem by subsystem.</li>
<li>Anchor chapters such as <code>architecture.md</code>, <code>transactions.md</code>, and <code>wal.md</code> walk through
end-to-end flows and subsystem deep dives.</li>
</ul>
<hr>
<h2 id="teaching-ideas-14"><a class="header" href="#teaching-ideas-14">Teaching Ideas</a></h2>
<ul>
<li>Require sqllogictest additions alongside code changes to reinforce “tests as docs”.</li>
<li>Use the mdBook site during lectures to connect diagrams with source files.</li>
<li>Assign “doc walk-through” tasks where students extend diagrams or add experiment
instructions to existing chapters.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid-eefea253.min.js"></script>
        <script src="mermaid-init-ccf746f1.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
